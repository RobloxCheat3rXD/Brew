local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local CoreGui = game:GetService("CoreGui")
local LocalPlayer = Players.LocalPlayer
local RequestCommandSilent = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent


local function giveBtools()
	pcall(function()
		RequestCommandSilent:InvokeServer(";btools")
	end)
end

local function refreshCommand()
	pcall(function()
		RequestCommandSilent:InvokeServer(";refresh")
	end)
end

local function stopSounds()
	pcall(function()
		RequestCommandSilent:InvokeServer(";unmusic")
	end)
end

local function setR6()
	pcall(function()
		RequestCommandSilent:InvokeServer(";r6")
	end)
end

local function playK00pTheme()
	pcall(function()
		RequestCommandSilent:InvokeServer(";music 1839246711 ;pitch 0.9 ;volume inf") -- Replace with actual k00p's theme ID if different
	end)
end

giveBtools()

LocalPlayer.CharacterAdded:Connect(function()
	task.wait(1)
	giveBtools()
end)


local K0OL = Instance.new("ScreenGui")
K0OL.Name = "k00pgui"
K0OL.ResetOnSpawn = false
K0OL.IgnoreGuiInset = false
K0OL.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
K0OL.Parent = CoreGui

local k00p = Instance.new("Frame")
k00p.Size = UDim2.new(0, 607, 0, 405)
k00p.Position = UDim2.new(0.5, -303, 0.5, -392)
k00p.BackgroundColor3 = Color3.new(0, 0, 0)
k00p.BorderColor3 = Color3.fromRGB(0, 53, 11)
k00p.BorderSizePixel = 5
k00p.Active = true
k00p.Draggable = true
k00p.Parent = K0OL

local scroll = Instance.new("ScrollingFrame")
scroll.Size = UDim2.new(0, 590, 0, 305)
scroll.Position = UDim2.new(0, 10, 0, 70)
scroll.BackgroundColor3 = Color3.fromRGB(8, 8, 8)
scroll.ScrollBarThickness = 8
scroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
scroll.ClipsDescendants = true
scroll.Parent = k00p

local title = Instance.new("TextLabel")
title.Text = "k00pgui private"
title.TextSize = 24
title.TextColor3 = Color3.new(1, 1, 1)
title.BackgroundTransparency = 1
title.Size = UDim2.new(1, 0, 0, 60)
title.Position = UDim2.new(0.0124216368, 0, -0.00999999978, 0)
title.TextScaled = true
title.Parent = k00p

local r6Button = Instance.new("TextButton")
r6Button.Text = "R6"
r6Button.TextSize = 14
r6Button.TextColor3 = Color3.new(1, 1, 1)
r6Button.BackgroundColor3 = Color3.new(0, 0, 0)
r6Button.BorderColor3 = Color3.fromRGB(0, 53, 11)
r6Button.BorderSizePixel = 2
r6Button.Size = UDim2.new(0, 80, 0, 30)
r6Button.Position = UDim2.new(0, 10, 0, 15)
r6Button.Parent = k00p

local themeButton = Instance.new("TextButton")
themeButton.Text = "Play k00p's Theme"
themeButton.TextSize = 12
themeButton.TextColor3 = Color3.new(1, 1, 1)
themeButton.BackgroundColor3 = Color3.new(0, 0, 0)
themeButton.BorderColor3 = Color3.fromRGB(0, 53, 11)
themeButton.BorderSizePixel = 2
themeButton.Size = UDim2.new(0, 100, 0, 30)  -- Increased width from 80 to 100
themeButton.Position = UDim2.new(0, 10, 0, 50)
themeButton.Parent = k00p

local refreshButton = Instance.new("TextButton")
refreshButton.Text = "Refresh"
refreshButton.TextSize = 14
refreshButton.TextColor3 = Color3.new(1, 1, 1)
refreshButton.BackgroundColor3 = Color3.new(0, 0, 0)
refreshButton.BorderColor3 = Color3.fromRGB(0, 53, 11)
refreshButton.BorderSizePixel = 2
refreshButton.Size = UDim2.new(0, 80, 0, 30)
refreshButton.Position = UDim2.new(1, -90, 0, 15)
refreshButton.Parent = k00p

local stopSoundsButton = Instance.new("TextButton")
stopSoundsButton.Text = "Stop Sounds"
stopSoundsButton.TextSize = 14
stopSoundsButton.TextColor3 = Color3.new(1, 1, 1)
stopSoundsButton.BackgroundColor3 = Color3.new(0, 0, 0)
stopSoundsButton.BorderColor3 = Color3.fromRGB(0, 53, 11)
stopSoundsButton.BorderSizePixel = 2
stopSoundsButton.Size = UDim2.new(0, 80, 0, 30)
stopSoundsButton.Position = UDim2.new(1, -90, 0, 50)
stopSoundsButton.Parent = k00p

local title2 = Instance.new("TextLabel")
title2.Text = ""
title2.TextSize = 18
title2.TextColor3 = Color3.new(1, 1, 1)
title2.BackgroundTransparency = 1
title2.Size = UDim2.new(1, 0, 0, 60)
title2.Position = UDim2.new(0, 0, 0.08, 0)
title2.Parent = k00p

local layout = Instance.new("UIGridLayout")
layout.CellSize = UDim2.new(0, 160, 0, 77)
layout.CellPadding = UDim2.new(0, 10, 0, 10)
layout.FillDirection = Enum.FillDirection.Horizontal
layout.FillDirectionMaxCells = 3
layout.HorizontalAlignment = Enum.HorizontalAlignment.Left
layout.VerticalAlignment = Enum.VerticalAlignment.Top
layout.SortOrder = Enum.SortOrder.LayoutOrder
layout.Parent = scroll

function BT(text, func)
	local button = Instance.new("TextButton")
	button.BackgroundColor3 = Color3.new(0, 0, 0)
	button.BorderColor3 = Color3.fromRGB(0, 53, 11)
	button.BorderSizePixel = 1
	button.TextColor3 = Color3.new(1, 1, 1)
	button.TextSize = 14
	button.TextScaled = true
	button.Text = text
	button.Size = UDim2.new(0, 300, 0, 200)
	button.Parent = scroll
	button.MouseButton1Click:Connect(func)
end


refreshButton.MouseButton1Click:Connect(refreshCommand)
stopSoundsButton.MouseButton1Click:Connect(stopSounds)
r6Button.MouseButton1Click:Connect(setR6)
themeButton.MouseButton1Click:Connect(playK00pTheme)
BT("Decal", function()
	
    local player = game.Players.LocalPlayer
			local char = player.Character
			local tool
			for i,v in player:GetDescendants() do
				if v.Name == "SyncAPI" then
					tool = v.Parent
				end
			end
			for i,v in game.ReplicatedStorage:GetDescendants() do
				if v.Name == "SyncAPI" then
					tool = v.Parent
				end
			end
			remote = tool.SyncAPI.ServerEndpoint
			function _(args)
				remote:InvokeServer(unpack(args))
			end
			function SetCollision(part,boolean)
				local args = {
					[1] = "SyncCollision",
					[2] = {
						[1] = {
							["Part"] = part,
							["CanCollide"] = boolean
						}
					}
				}
				_(args)
			end
			function SetAnchor(boolean,part)
				local args = {
					[1] = "SyncAnchor",
					[2] = {
						[1] = {
							["Part"] = part,
							["Anchored"] = boolean
						}
					}
				}
				_(args)
			end
			function CreatePart(cf,parent)
				local args = {
					[1] = "CreatePart",
					[2] = "Normal",
					[3] = cf,
					[4] = parent
				}
				_(args)
			end
			function DestroyPart(part)
				local args = {
					[1] = "Remove",
					[2] = {
						[1] = part
					}
				}
				_(args)
			end
			function MovePart(part,cf)
				local args = {
					[1] = "SyncMove",
					[2] = {
						[1] = {
							["Part"] = part,
							["CFrame"] = cf
						}
					}
				}
				_(args)
			end
			function Resize(part,size,cf)
				local args = {
					[1] = "SyncResize",
					[2] = {
						[1] = {
							["Part"] = part,
							["CFrame"] = cf,
							["Size"] = size
						}
					}
				}
				_(args)
			end
			function AddMesh(part)
				local args = {
					[1] = "CreateMeshes",
					[2] = {
						[1] = {
							["Part"] = part
						}
					}
				}
				_(args)
			end
	
			function SetMesh(part,meshid)
				local args = {
					[1] = "SyncMesh",
					[2] = {
						[1] = {
							["Part"] = part,
							["MeshId"] = "rbxassetid://"..meshid
						}
					}
				}
				_(args)
			end
			function SetTexture(part, texid)
				local args = {
					[1] = "SyncMesh",
					[2] = {
						[1] = {
							["Part"] = part,
							["TextureId"] = "rbxassetid://"..texid
						}
					}
				}
				_(args)
			end
			function SetName(part, stringg)
				local args = {
					[1] = "SetName",
					[2] = {
						[1] = part
					},
					[3] = stringg
				}
	
				_(args)
			end
			function MeshResize(part,size)
				local args = {
					[1] = "SyncMesh",
					[2] = {
						[1] = {
							["Part"] = part,
							["Scale"] = size
						}
					}
				}
				_(args)
			end
			function Weld(part1, part2,lead)
				local args = {
					[1] = "CreateWelds",
					[2] = {
						[1] = part1,
						[2] = part2
					},
					[3] = lead
				}
				_(args)
	
			end
			function SetLocked(part,boolean)
				local args = {
					[1] = "SetLocked",
					[2] = {
						[1] = part
					},
					[3] = boolean
				}
				_(args)
			end
			function SetTrans(part,int)
				local args = {
					[1] = "SyncMaterial",
					[2] = {
						[1] = {
							["Part"] = part,
							["Transparency"] = int
						}
					}
				}
				_(args)
			end
			function CreateSpotlight(part)
				local args = {
					[1] = "CreateLights",
					[2] = {
						[1] = {
							["Part"] = part,
							["LightType"] = "SpotLight"
						}
					}
				}
				_(args)
			end
			function SyncLighting(part,brightness)
				local args = {
					[1] = "SyncLighting",
					[2] = {
						[1] = {
							["Part"] = part,
							["LightType"] = "SpotLight",
							["Brightness"] = brightness
						}
					}
				}
				_(args)
			end
			function Color(part,color)
				local args = {
					[1] = "SyncColor",
					[2] = {
						[1] = {
							["Part"] = part,
							["Color"] = color --[[Color3]],
							["UnionColoring"] = false
						}
					}
				}
				_(args)
			end
			function SpawnDecal(part,side)
				local args = {
					[1] = "CreateTextures",
					[2] = {
						[1] = {
							["Part"] = part,
							["Face"] = side,
							["TextureType"] = "Decal"
						}
					}
				}
	
				_(args)
			end
			function AddDecal(part,asset,side)
				local args = {
					[1] = "SyncTexture",
					[2] = {
						[1] = {
							["Part"] = part,
							["Face"] = side,
							["TextureType"] = "Decal",
							["Texture"] = "rbxassetid://".. asset
						}
					}
				}
				_(args)
			end
	
			function spam(id)
				for i,v in game.workspace:GetDescendants() do
					if v:IsA("BasePart") then
						spawn(function()
							SetLocked(v,false)
							SpawnDecal(v,Enum.NormalId.Front)
							AddDecal(v,id,Enum.NormalId.Front)
	
							SpawnDecal(v,Enum.NormalId.Back)
							AddDecal(v,id,Enum.NormalId.Back)
	
							SpawnDecal(v,Enum.NormalId.Right)
							AddDecal(v,id,Enum.NormalId.Right)
	
							SpawnDecal(v,Enum.NormalId.Left)
							AddDecal(v,id,Enum.NormalId.Left)
	
							SpawnDecal(v,Enum.NormalId.Bottom)
							AddDecal(v,id,Enum.NormalId.Bottom)
	
							SpawnDecal(v,Enum.NormalId.Top)
							AddDecal(v,id,Enum.NormalId.Top)
						end)
					end
				end 
			end
			spam("9422866248")
end)
BT("SkyBox", function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";fogcolor black ;time 0")
        
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

local tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)
    remote:InvokeServer(unpack(args))
end

function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end

function SetAnchor(part, state)
    _({"SyncAnchor", {{["Part"] = part, ["Anchored"] = state}}})
end

function AddMesh(part)
    _({"CreateMeshes", {{["Part"] = part}}})
end

function SetMesh(part, meshid)
    _({"SyncMesh", {{["Part"] = part, ["MeshId"] = "rbxassetid://" .. meshid}}})
end

function SetTexture(part, texid)
    _({"SyncMesh", {{["Part"] = part, ["TextureId"] = "rbxassetid://" .. texid}}})
end

function MeshResize(part, size)
    _({"SyncMesh", {{["Part"] = part, ["Scale"] = size}}})
end

function SetVertexColor(part, color)
    _({"SyncMesh", {{["Part"] = part, ["VertexColor"] = color}}})
end

function Sky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = hrp.CFrame
    
    CreatePart(CFrame.new(cf.Position + Vector3.new(0, 6, 0)), workspace)
    
    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") and v.Position == cf.Position + Vector3.new(0, 6, 0) then
            SetAnchor(v, true)
            AddMesh(v)
            SetMesh(v, "111891702759441")
            SetTexture(v, id)
            SetVertexColor(v, Vector3.new(4, 4, 4))
            MeshResize(v, Vector3.new(109888, 109888, 109888))
        end
    end
end
Sky("9422866248")
end)

BT("SkyBox 2", function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";fogcolor black ;time 0")
        
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

local tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)
    remote:InvokeServer(unpack(args))
end

function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end

function SetAnchor(part, state)
    _({"SyncAnchor", {{["Part"] = part, ["Anchored"] = state}}})
end

function AddMesh(part)
    _({"CreateMeshes", {{["Part"] = part}}})
end

function SetMesh(part, meshid)
    _({"SyncMesh", {{["Part"] = part, ["MeshId"] = "rbxassetid://" .. meshid}}})
end

function SetTexture(part, texid)
    _({"SyncMesh", {{["Part"] = part, ["TextureId"] = "rbxassetid://" .. texid}}})
end

function MeshResize(part, size)
    _({"SyncMesh", {{["Part"] = part, ["Scale"] = size}}})
end

function SetVertexColor(part, color)
    _({"SyncMesh", {{["Part"] = part, ["VertexColor"] = color}}})
end

function Sky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = hrp.CFrame
    
    CreatePart(CFrame.new(cf.Position + Vector3.new(0, 6, 0)), workspace)
    
    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") and v.Position == cf.Position + Vector3.new(0, 6, 0) then
            SetAnchor(v, true)
            AddMesh(v)
            SetMesh(v, "111891702759441")
            SetTexture(v, id)
            SetVertexColor(v, Vector3.new(4, 4, 4))
            MeshResize(v, Vector3.new(109888, 109888, 109888))
        end
    end
end
Sky("11426185601")
end)

BT("Hint", function()
	RequestCommandSilent:InvokeServer(";sh TEAM K00PKIDD HAS HACKED THIS GAME.")
end)

BT("Particles", function()
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
        break
    end
end
if not tool then
    for _, v in game.ReplicatedStorage:GetDescendants() do
        if v.Name == "SyncAPI" then
            tool = v.Parent
            break
        end
    end
end
if not tool then
    error("wheres the is fucking f3x skid")
end

local remote = tool.SyncAPI.ServerEndpoint

local function _(args)
    remote:InvokeServer(unpack(args))
end

local function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end
local function SetAnchor(part, state)
    _({"SyncAnchor", {{Part = part, Anchored = state}}})
end
local function SetCollision(part, state)
    _({"SyncCollision", {{Part = part, CanCollide = state}}})
end
local function AddMesh(part)
    _({"CreateMeshes", {{Part = part}}})
end
local function SetMesh(part, meshid)
    _({"SyncMesh", {{Part = part, MeshId = "rbxassetid://" .. meshid}}})
end
local function SetTexture(part, texid)
    _({"SyncMesh", {{Part = part, TextureId = "rbxassetid://" .. texid}}})
end
local function MeshResize(part, size)
    _({"SyncMesh", {{Part = part, Scale = size}}})
end
local function SetLocked(part, state)
    _({"SetLocked", {part}, state})
end
local function Resize(part, size, cf)
    _({"SyncResize", {{Part = part, CFrame = cf, Size = size}}})
end
local function SpawnDecal(part, face)
    _({"CreateTextures", {{Part = part, Face = face, TextureType = "Decal"}}})
end
local function AddDecal(part, asset, face)
    _({"SyncTexture", {{Part = part, Face = face, TextureType = "Decal", Texture = "rbxassetid://"..asset}}})
end
local function SetName(part, name)
    _({"SetName", {part}, name})
end
local function SetTrans(part, val)
    _({"SyncMaterial", {{Part = part, Transparency = val}}})
end
local function delete(part)
    _({"Remove", {part}})
end

local activeParticles = {}
local particleCooldowns = {}

local function createParticleForPlayer(targetPlayer, textureId)
    local character = targetPlayer.Character
    if not character then
        targetPlayer.CharacterAdded:Wait()
        character = targetPlayer.Character
    end
    
    local humanoid = character:WaitForChild("Humanoid")
    local playerKey = targetPlayer.UserId
    
    local cooldownKey = playerKey .. "_" .. textureId
    particleCooldowns[cooldownKey] = particleCooldowns[cooldownKey] or 0
    
    while true do
        local currentTime = tick()
        
        if currentTime - particleCooldowns[cooldownKey] >= 2 then
            particleCooldowns[cooldownKey] = currentTime
            
            if not targetPlayer or not targetPlayer.Parent or not character or not character.Parent or humanoid.Health <= 0 then
                break
            end
            
            local head = character:FindFirstChild("Head")
            if not head then
                task.wait(1)
                continue
            end

            local spawnCFrame = head.CFrame + Vector3.new(0, 3, 0)
            
            task.spawn(function()  
                CreatePart(spawnCFrame, workspace)  
                task.wait(0.1)  
                
                local newPart = nil
                for _, v in workspace:GetChildren() do  
                    if v:IsA("Part") and (v.Position - spawnCFrame.Position).Magnitude < 1 then  
                        newPart = v
                        break
                    end  
                end
                
                if newPart then
                    SetName(newPart, "particle_" .. targetPlayer.Name .. "_" .. textureId)  
                    Resize(newPart, Vector3.new(6, 6, 0.001), newPart.CFrame)  
                    SetCollision(newPart, false)  
                    SetTrans(newPart, 1)  
                    SetAnchor(newPart, true)  
                    newPart.Orientation = Vector3.new(0, 0, 0)  

                    SpawnDecal(newPart, Enum.NormalId.Front)  
                    AddDecal(newPart, textureId, Enum.NormalId.Front)  
                    SpawnDecal(newPart, Enum.NormalId.Back)  
                    AddDecal(newPart, textureId, Enum.NormalId.Back)  

                    local particleId = #activeParticles + 1
                    activeParticles[particleId] = newPart

                    for i = 1, 40 do  -- Reduced frames for faster cleanup
                        if newPart and newPart.Parent and head and head.Parent then  
                            local currentHeadPos = head.Position
                            local newPosition = Vector3.new(
                                currentHeadPos.X,
                                spawnCFrame.Position.Y + (i * 2),  -- Move up 2 studs per frame
                                currentHeadPos.Z
                            )
                            local newCFrame = CFrame.new(newPosition)
                            Resize(newPart, newPart.Size, newCFrame)  
                            task.wait(0.05)  -- Slightly faster animation
                        else
                            break
                        end
                    end  
                    
                    if newPart and newPart.Parent then
                        delete(newPart)  
                    end
                    activeParticles[particleId] = nil
                end  
            end)  
        end
        
        task.wait(0.5) -- Check every 0.5 seconds instead of 0.1
    end
end

local function startParticleSystem()
    local textureIds = {"90174292761643"}
    local activeConnections = {}
    
    local function startForPlayer(player)
        for _, texId in ipairs(textureIds) do
            coroutine.wrap(function()
                createParticleForPlayer(player, texId)
            end)()
        end
    end
    
    local function stopForPlayer(player)
        for particleId, part in pairs(activeParticles) do
            if part.Name:find(player.Name) and part.Parent then
                delete(part)
                activeParticles[particleId] = nil
            end
        end
    end
    
    for _, existingPlayer in ipairs(Players:GetPlayers()) do
        startForPlayer(existingPlayer)
    end
    
    Players.PlayerAdded:Connect(function(newPlayer)
        startForPlayer(newPlayer)
    end)
    
    Players.PlayerRemoving:Connect(function(leavingPlayer)
        stopForPlayer(leavingPlayer)
    end)
end

local function setupCleanup()
    while true do
        task.wait(10) -- Clean up every 10 seconds
        for particleId, part in pairs(activeParticles) do
            if not part or not part.Parent then
                activeParticles[particleId] = nil
            end
        end
    end
end

startParticleSystem()
coroutine.wrap(setupCleanup)()
end)
BT("Particles 2", function()
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
        break
    end
end
if not tool then
    for _, v in game.ReplicatedStorage:GetDescendants() do
        if v.Name == "SyncAPI" then
            tool = v.Parent
            break
        end
    end
end
if not tool then
    error("SyncAPI tool not found")
end

local remote = tool.SyncAPI.ServerEndpoint

local function _(args)
    remote:InvokeServer(unpack(args))
end

local function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end
local function SetAnchor(part, state)
    _({"SyncAnchor", {{Part = part, Anchored = state}}})
end
local function SetCollision(part, state)
    _({"SyncCollision", {{Part = part, CanCollide = state}}})
end
local function AddMesh(part)
    _({"CreateMeshes", {{Part = part}}})
end
local function SetMesh(part, meshid)
    _({"SyncMesh", {{Part = part, MeshId = "rbxassetid://" .. meshid}}})
end
local function SetTexture(part, texid)
    _({"SyncMesh", {{Part = part, TextureId = "rbxassetid://" .. texid}}})
end
local function MeshResize(part, size)
    _({"SyncMesh", {{Part = part, Scale = size}}})
end
local function SetLocked(part, state)
    _({"SetLocked", {part}, state})
end
local function Resize(part, size, cf)
    _({"SyncResize", {{Part = part, CFrame = cf, Size = size}}})
end
local function SpawnDecal(part, face)
    _({"CreateTextures", {{Part = part, Face = face, TextureType = "Decal"}}})
end
local function AddDecal(part, asset, face)
    _({"SyncTexture", {{Part = part, Face = face, TextureType = "Decal", Texture = "rbxassetid://"..asset}}})
end
local function SetName(part, name)
    _({"SetName", {part}, name})
end
local function SetTrans(part, val)
    _({"SyncMaterial", {{Part = part, Transparency = val}}})
end
local function delete(part)
    _({"Remove", {part}})
end

local activeParticles = {}
local particleCooldowns = {}

local function createParticleForPlayer(targetPlayer, textureId)
    local character = targetPlayer.Character
    if not character then
        targetPlayer.CharacterAdded:Wait()
        character = targetPlayer.Character
    end
    
    local humanoid = character:WaitForChild("Humanoid")
    local playerKey = targetPlayer.UserId
    
    local cooldownKey = playerKey .. "_" .. textureId
    particleCooldowns[cooldownKey] = particleCooldowns[cooldownKey] or 0
    
    while true do
        local currentTime = tick()
        
        if currentTime - particleCooldowns[cooldownKey] >= 2 then
            particleCooldowns[cooldownKey] = currentTime
            
            if not targetPlayer or not targetPlayer.Parent or not character or not character.Parent or humanoid.Health <= 0 then
                break
            end
            
            local head = character:FindFirstChild("Head")
            if not head then
                task.wait(1)
                continue
            end

            local spawnCFrame = head.CFrame + Vector3.new(0, 3, 0)
            
            task.spawn(function()  
                CreatePart(spawnCFrame, workspace)  
                task.wait(0.1)  
                
                local newPart = nil
                for _, v in workspace:GetChildren() do  
                    if v:IsA("Part") and (v.Position - spawnCFrame.Position).Magnitude < 1 then  
                        newPart = v
                        break
                    end  
                end
                
                if newPart then
                    SetName(newPart, "particle_" .. targetPlayer.Name .. "_" .. textureId)  
                    Resize(newPart, Vector3.new(6, 6, 0.001), newPart.CFrame)  
                    SetCollision(newPart, false)  
                    SetTrans(newPart, 1)  
                    SetAnchor(newPart, true)  
                    newPart.Orientation = Vector3.new(0, 0, 0)  

                    SpawnDecal(newPart, Enum.NormalId.Front)  
                    AddDecal(newPart, textureId, Enum.NormalId.Front)  
                    SpawnDecal(newPart, Enum.NormalId.Back)  
                    AddDecal(newPart, textureId, Enum.NormalId.Back)  

                    local particleId = #activeParticles + 1
                    activeParticles[particleId] = newPart

                    for i = 1, 40 do  -- Reduced frames for faster cleanup
                        if newPart and newPart.Parent and head and head.Parent then  
                            local currentHeadPos = head.Position
                            local newPosition = Vector3.new(
                                currentHeadPos.X,
                                spawnCFrame.Position.Y + (i * 2),  -- Move up 2 studs per frame
                                currentHeadPos.Z
                            )
                            local newCFrame = CFrame.new(newPosition)
                            Resize(newPart, newPart.Size, newCFrame)  
                            task.wait(0.05)  -- Slightly faster animation
                        else
                            break
                        end
                    end  
                    
                    if newPart and newPart.Parent then
                        delete(newPart)  
                    end
                    activeParticles[particleId] = nil
                end  
            end)  
        end
        
        task.wait(0.5) -- Check every 0.5 seconds instead of 0.1
    end
end

local function startParticleSystem()
    local textureIds = {"11426291165"}
    local activeConnections = {}
    
    local function startForPlayer(player)
        for _, texId in ipairs(textureIds) do
            coroutine.wrap(function()
                createParticleForPlayer(player, texId)
            end)()
        end
    end
    
    local function stopForPlayer(player)
        for particleId, part in pairs(activeParticles) do
            if part.Name:find(player.Name) and part.Parent then
                delete(part)
                activeParticles[particleId] = nil
            end
        end
    end
    
    for _, existingPlayer in ipairs(Players:GetPlayers()) do
        startForPlayer(existingPlayer)
    end
    
    Players.PlayerAdded:Connect(function(newPlayer)
        startForPlayer(newPlayer)
    end)
    
    Players.PlayerRemoving:Connect(function(leavingPlayer)
        stopForPlayer(leavingPlayer)
    end)
end

local function setupCleanup()
    while true do
        task.wait(10) -- Clean up every 10 seconds
        for particleId, part in pairs(activeParticles) do
            if not part or not part.Parent then
                activeParticles[particleId] = nil
            end
        end
    end
end

startParticleSystem()
coroutine.wrap(setupCleanup)()
end)

BT("666", function()
	
local player = game.Players.LocalPlayer
    local char = player.Character
    local tool
    for i,v in player:GetDescendants() do
        if v.Name == "SyncAPI" then
            tool = v.Parent
        end
    end
    for i,v in game.ReplicatedStorage:GetDescendants() do
        if v.Name == "SyncAPI" then
            tool = v.Parent
        end
    end
    remote = tool.SyncAPI.ServerEndpoint
    function _(args)
        remote:InvokeServer(unpack(args))
    end
    function SetCollision(part,boolean)
        local args = {
            [1] = "SyncCollision",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["CanCollide"] = boolean
                }
            }
        }
        _(args)
    end
    function SetAnchor(boolean,part)
        local args = {
            [1] = "SyncAnchor",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["Anchored"] = boolean
                }
            }
        }
        _(args)
    end
    function CreatePart(cf,parent)
        local args = {
            [1] = "CreatePart",
            [2] = "Normal",
            [3] = cf,
            [4] = parent
        }
        _(args)
    end
    function DestroyPart(part)
        local args = {
            [1] = "Remove",
            [2] = {
                [1] = part
            }
        }
        _(args)
    end
    function MovePart(part,cf)
        local args = {
            [1] = "SyncMove",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["CFrame"] = cf
                }
            }
        }
        _(args)
    end
    function Resize(part,size,cf)
        local args = {
            [1] = "SyncResize",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["CFrame"] = cf,
                    ["Size"] = size
                }
            }
        }
        _(args)
    end
    function AddMesh(part)
        local args = {
            [1] = "CreateMeshes",
            [2] = {
                [1] = {
                    ["Part"] = part
                }
            }
        }
        _(args)
    end
 
    function SetMesh(part,meshid)
        local args = {
            [1] = "SyncMesh",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["MeshId"] = "rbxassetid://"..meshid
                }
            }
        }
        _(args)
    end
    function SetTexture(part, texid)
        local args = {
            [1] = "SyncMesh",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["TextureId"] = "rbxassetid://"..texid
                }
            }
        }
        _(args)
    end
    function SetName(part, stringg)
        local args = {
            [1] = "SetName",
            [2] = {
                [1] = part
            },
            [3] = stringg
        }
 
        _(args)
    end
    function MeshResize(part,size)
        local args = {
            [1] = "SyncMesh",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["Scale"] = size
                }
            }
        }
        _(args)
    end
    function Weld(part1, part2,lead)
        local args = {
            [1] = "CreateWelds",
            [2] = {
                [1] = part1,
                [2] = part2
            },
            [3] = lead
        }
        _(args)
 
    end
    function SetLocked(part,boolean)
        local args = {
            [1] = "SetLocked",
            [2] = {
                [1] = part
            },
            [3] = boolean
        }
        _(args)
    end
    function SetTrans(part,int)
        local args = {
            [1] = "SyncMaterial",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["Transparency"] = int
                }
            }
        }
        _(args)
    end
    function CreateSpotlight(part)
        local args = {
            [1] = "CreateLights",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["LightType"] = "SpotLight"
                }
            }
        }
        _(args)
    end
    function SyncLighting(part,brightness)
        local args = {
            [1] = "SyncLighting",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["LightType"] = "SpotLight",
                    ["Brightness"] = brightness
                }
            }
        }
        _(args)
    end
    function Color(part,color)
        local args = {
            [1] = "SyncColor",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["Color"] = color --[[Color3]],
                    ["UnionColoring"] = false
                }
            }
        }
        _(args)
    end
    function SpawnDecal(part,side)
        local args = {
            [1] = "CreateTextures",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["Face"] = side,
                    ["TextureType"] = "Decal"
                }
            }
        }
 
        _(args)
    end
    function AddDecal(part,asset,side)
        local args = {
            [1] = "SyncTexture",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["Face"] = side,
                    ["TextureType"] = "Decal",
                    ["Texture"] = "rbxassetid://".. asset
                }
            }
        }
        _(args)
    end
 
    function spam(id)
        for i,v in game.workspace:GetDescendants() do
            if v:IsA("BasePart") then
                spawn(function()
task.wait(0.1)
                    SetLocked(v,false)
                     
                    SpawnDecal(v,Enum.NormalId.Front)
                    AddDecal(v,id,Enum.NormalId.Front)
 
                    SpawnDecal(v,Enum.NormalId.Back)
                    AddDecal(v,id,Enum.NormalId.Back)
 
                    SpawnDecal(v,Enum.NormalId.Right)
                    AddDecal(v,id,Enum.NormalId.Right)
 
                    SpawnDecal(v,Enum.NormalId.Left)
                    AddDecal(v,id,Enum.NormalId.Left)
 
                    SpawnDecal(v,Enum.NormalId.Bottom)
                    AddDecal(v,id,Enum.NormalId.Bottom)
 
                    SpawnDecal(v,Enum.NormalId.Top)
                    AddDecal(v,id,Enum.NormalId.Top)
                end)
            end
        end 
    end
    spam("90095903128986")



    		local function applyDecorationToPart(part)
			local argsCreate = {
				[1] = "CreateDecorations",
				[2] = {
					[1] = {
						["Part"] = part,
						["DecorationType"] = "Fire"
					}
				}
			}

			local argsSync = {
				[1] = "SyncDecorate",
				[2] = {
					[1] = {
						["Part"] = part,
						["DecorationType"] = "Fire",
						["Size"] = 15
					}
				}
			}

			local buildingTools = nil
			local player = game:GetService("Players").LocalPlayer

			for _, item in pairs(player.Character:GetChildren()) do
				if item:IsA("Tool") and item:FindFirstChild("SyncAPI") then
					buildingTools = item
					break
				end
			end

			if not buildingTools then
				for _, item in pairs(player.Backpack:GetChildren()) do
					if item:IsA("Tool") and item:FindFirstChild("SyncAPI") then
						buildingTools = item
						break
					end
				end
			end

			if buildingTools then
				buildingTools.SyncAPI.ServerEndpoint:InvokeServer(unpack(argsCreate))
				buildingTools.SyncAPI.ServerEndpoint:InvokeServer(unpack(argsSync))
			elseif not warned then
				warn("Building tool not found")
				warned = true
			end
		end

		local function applyDecorationToAllParts(workspaceObject)
			for _, obj in pairs(workspaceObject:GetDescendants()) do
				if obj:IsA("Part") or obj:IsA("MeshPart") then
					applyDecorationToPart(obj)
				end
			end
		end

		applyDecorationToAllParts(workspace)


        local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local tool


for _, v in ipairs(LocalPlayer:GetDescendants()) do
	if v.Name == "SyncAPI" then
		tool = v.Parent
		break
	end
end

if not tool then
	for _, v in ipairs(ReplicatedStorage:GetDescendants()) do
		if v.Name == "SyncAPI" then
			tool = v.Parent
			break
		end
	end
end

if not tool then
	warn("dumbass")
	return
end

local remote = tool:WaitForChild("SyncAPI"):WaitForChild("ServerEndpoint")


local function invoke(args)
	remote:InvokeServer(unpack(args))
end


local function applyRedLight(part)
	if not part or not part:IsA("BasePart") then return end


	local createArgs = {
		"CreateLights",
		{
			{
				Part = part,
				LightType = "PointLight"
			}
		}
	}


	local syncArgs = {
		"SyncLighting",
		{
			{
				Part = part,
				LightType = "PointLight",
				Color = Color3.fromRGB(255, 0, 0),
				Range = 60,
				Brightness = 20
			}
		}
	}

	invoke(createArgs)
	invoke(syncArgs)
end

local function applyLightsToAllParts(root)
	for _, obj in ipairs(root:GetDescendants()) do
		if obj:IsA("Part") or obj:IsA("MeshPart") then
			applyRedLight(obj)
		end
	end
end

applyLightsToAllParts(workspace)

RequestCommandSilent:InvokeServer(";titler all 666 666 666 666")
end)

BT("UnAnchor", function()
	local player = game.Players.LocalPlayer

local char = player.Character or player.CharacterAdded:Wait()

local tool

for _, v in player:GetDescendants() do

	if v.Name == "SyncAPI" then

		tool = v.Parent

	end

end

for _, v in game.ReplicatedStorage:GetDescendants() do

	if v.Name == "SyncAPI" then

		tool = v.Parent

	end

end

if not tool or not tool:FindFirstChild("SyncAPI") then

	warn("SyncAPI tool not found!")

	return

end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)

	remote:InvokeServer(unpack(args))

end

function SetCollision(part, boolean)

	local args = {

		"SyncCollision",

		{

			{

				Part = part,

				CanCollide = boolean

			}

		}

	}

	_(args)

end

function SetAnchor(boolean, part)

	local args = {

		"SyncAnchor",

		{

			{

				Part = part,

				Anchored = boolean

			}

		}

	}

	_(args)

end

function CreatePart(cf, parent)

	local args = {

		"CreatePart",

		"Normal",

		cf,

		parent

	}

	_(args)

end

function DestroyPart(part)

	local args = {

		"Remove",

		{

			part

		}

	}

	_(args)

end

function MovePart(part, cf)

	local args = {

		"SyncMove",

		{

			{

				Part = part,

				CFrame = cf

			}

		}

	}

	_(args)

end

function Resize(part, size, cf)

	local args = {

		"SyncResize",

		{

			{

				Part = part,

				CFrame = cf,

				Size = size

			}

		}

	}

	_(args)

end

function AddMesh(part)

	local args = {

		"CreateMeshes",

		{

			{

				Part = part

			}

		}

	}

	_(args)

end

function SetMesh(part, meshid)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				MeshId = "rbxassetid://" .. meshid

			}

		}

	}

	_(args)

end

function SetTexture(part, texid)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				TextureId = "rbxassetid://" .. texid

			}

		}

	}

	_(args)

end

function SetName(part, name)

	local args = {

		"SetName",

		{

			part

		},

		name

	}

	_(args)

end

function MeshResize(part, size)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				Scale = size

			}

		}

	}

	_(args)

end

function Weld(part1, part2, lead)

	local args = {

		"CreateWelds",

		{

			part1,

			part2

		},

		lead

	}

	_(args)

end

function SetLocked(part, boolean)

	local args = {

		"SetLocked",

		{

			part

		},

		boolean

	}

	_(args)

end

function SetTrans(part, int)

	local args = {

		"SyncMaterial",

		{

			{

				Part = part,

				Transparency = int

			}

		}

	}

	_(args)

end

function CreateSpotlight(part)

	local args = {

		"CreateLights",

		{

			{

				Part = part,

				LightType = "SpotLight"

			}

		}

	}

	_(args)

end

function SyncLighting(part, brightness)

	local args = {

		"SyncLighting",

		{

			{

				Part = part,

				LightType = "SpotLight",

				Brightness = brightness

			}

		}

	}

	_(args)

end

function Unanchor()

	for _, v in workspace:GetDescendants() do

		if v:IsA("BasePart") then

			task.spawn(function()

				SetLocked(v, false)

				SetAnchor(false, v)

			end)

		end

	end

end

Unanchor()
end)

BT("Shutdown", function()
	local plr = game:GetService("Players").LocalPlayer
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local RequestCommandSilent = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
	RequestCommandSilent:InvokeServer(";kick all Teh Game Iz Duked Up!1!")
	wait(1)
	plr:Kick("Teh Game Iz Duked Up!1!")
end)

BT("disco", function()
	RequestCommandSilent:InvokeServer(";disco")
end)

BT("Gravity Hammer", function()
		local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local player = game.Players.LocalPlayer
	local char = player.Character
	local hum = char.Humanoid
	local hed = char.Head
	local tool
	for i,v in player:GetDescendants() do
		if v.Name == "SyncAPI" then
			tool = v.Parent
		end
	end
	for i,v in game.ReplicatedStorage:GetDescendants() do
		if v.Name == "SyncAPI" then
			tool = v.Parent
		end
	end
	remote = tool.SyncAPI.ServerEndpoint
	function _(args)
		remote:InvokeServer(unpack(args))
	end


	function SetCollision(part,boolean)
		local args = {
			[1] = "SyncCollision",
			[2] = {
				[1] = {
					["Part"] = part,
					["CanCollide"] = boolean
				}
			}
		}
		_(args)
	end
	function SetAnchor(boolean,part)
		local args = {
			[1] = "SyncAnchor",
			[2] = {
				[1] = {
					["Part"] = part,
					["Anchored"] = boolean
				}
			}
		}
		_(args)
	end
	function CreatePart(cf,parent)
		local args = {
			[1] = "CreatePart",
			[2] = "Normal",
			[3] = cf,
			[4] = parent
		}
		_(args)
	end
	function DestroyPart(part)
		local args = {
			[1] = "Remove",
			[2] = {
				[1] = part
			}
		}
		_(args)
	end
	function MovePart(part,cf)
		local args = {
			[1] = "SyncMove",
			[2] = {
				[1] = {
					["Part"] = part,
					["CFrame"] = cf
				}
			}
		}
		_(args)
	end
	function CreateFire(part)
		local args = {
			[1] = "CreateDecorations",
			[2] = {
				[1] = {
					["Part"] = part,
					["DecorationType"] = "Fire"
				}
			}
		}
		spawn(function()
			_(args)
		end)
		local args2 = {
			[1] = "SyncDecorate",
			[2] = {
				[1] = {
					["Part"] = part,
					["DecorationType"] = "Fire",
					["Size"] = 3.5,
					["Heat"] = 25,
					["Color"]=Color3.fromRGB(255, 115, 0),
					["SecondaryColor"]=Color3.fromRGB(255, 75, 10),
				}
			}
		}
		spawn(function()
			_(args2)
		end)
	end
	function Resize(part,size,cf)
		local args = {
			[1] = "SyncResize",
			[2] = {
				[1] = {
					["Part"] = part,
					["CFrame"] = cf,
					["Size"] = size
				}
			}
		}
		_(args)
	end
	function AddMesh(part)
		local args = {
			[1] = "CreateMeshes",
			[2] = {
				[1] = {
					["Part"] = part
				}
			}
		}
		_(args)
	end
	function reflect(part,int)
		local args = {
			[1] = "SyncMaterial",
			[2] = {
				[1] = {
					["Part"] = part,
					["Reflectance"] = int
				}
			}
		}
		_(args)
	end
	function SetMesh(part,meshid,offset)
		local args = {
			[1] = "SyncMesh",
			[2] = {
				[1] = {
					["Part"] = part,
					["MeshId"] = "rbxassetid://"..meshid,
					["Offset"] = offset
				}
			}
		}
		_(args)
	end
	function SetTexture(part, texid)
		local args = {
			[1] = "SyncMesh",
			[2] = {
				[1] = {
					["Part"] = part,
					["TextureId"] = "rbxassetid://"..texid
				}
			}
		}
		_(args)
	end
	function breakWelds(part)
		local welds = {}
		for _, weld in ipairs(part:GetDescendants()) do
			if weld:IsA("WeldConstraint") or weld:IsA("Weld") or weld:IsA("Motor6D") then
				table.insert(welds, weld)
			end
		end

		if #welds == 0 then
			return false
		end

		local args = {
			"RemoveWelds",
			welds
		}
		_(args)
		return true
	end
	function SetName(part, stringg)
		local args = {
			[1] = "SetName",
			[2] = {
				[1] = part
			},
			[3] = stringg
		}

		_(args)
	end
	function MeshResize(part,size)
		local args = {
			[1] = "SyncMesh",
			[2] = {
				[1] = {
					["Part"] = part,
					["Scale"] = size
				}
			}
		}
		_(args)
	end
	function Weld(part1, part2,lead)
		local args = {
			[1] = "CreateWelds",
			[2] = {
				[1] = part1,
				[2] = part2
			},
			[3] = lead
		}
		_(args)

	end
	function SetLocked(part,boolean)
		local args = {
			[1] = "SetLocked",
			[2] = {
				[1] = part
			},
			[3] = boolean
		}
		_(args)
	end

	function SetTrans(part,int)
		local args = {
			[1] = "SyncMaterial",
			[2] = {
				[1] = {
					["Part"] = part,
					["Transparency"] = int
				}
			}
		}
		_(args)
	end
	function CreatePointlight(part)
		local args = {
			[1] = "CreateLights",
			[2] = {
				[1] = {
					["Part"] = part,
					["LightType"] = "PointLight"
				}
			}
		}
		_(args)
	end
	function CreateLight(part)
		local args = {
			"CreateLights",
			{
				{
					["Part"] = part,
					["LightType"] = "PointLight"
				}
			}
		}
		spawn(function()
			_(args)
		end)
		local args2 = {
			"SyncLighting",
			{
				{
					["Part"] = part,
					["LightType"] = "PointLight",
					["Color"] = Color3.fromRGB(255,125,0),
					["Range"] = 18,
					["Brightness"] = 5,
				}
			}
		}
		spawn(function()
			_(args2)
		end)
	end
	function playSFX(id,parent)
		local SFX = Instance.new('Sound',parent)
		SFX.Volume = 1
		SFX.SoundId = "rbxassetid://" ..id
		SFX:Play()
		return SFX
	end
	function SyncLighting(part,brightness,color,range)
		local args2 = {
			"SyncLighting",
			{
				{
					["Part"] = part,
					["LightType"] = "PointLight",
					["Color"] = color,
					["Range"] = range,
					["Brightness"] = brightness,
				}
			}
		}
		_(args2)
	end
	function Color(part,color)
		local args = {
			[1] = "SyncColor",
			[2] = {
				[1] = {
					["Part"] = part,
					["Color"] = color --[[Color3]],
					["UnionColoring"] = false
				}
			}
		}
		_(args)
	end
	function SpawnDecal(part,side)
		local args = {
			[1] = "CreateTextures",
			[2] = {
				[1] = {
					["Part"] = part,
					["Face"] = side,
					["TextureType"] = "Decal"
				}
			}
		}

		_(args)
	end
	function AddDecal(part,asset,side)
		local args = {
			[1] = "SyncTexture",
			[2] = {
				[1] = {
					["Part"] = part,
					["Face"] = side,
					["TextureType"] = "Decal",
					["Texture"] = "rbxassetid://".. asset
				}
			}
		}
		_(args)
	end
	local Animations = {"rbxassetid://74897796","rbxassetid://74813494","rbxassetid://54432537"}
	local sound = "rbxassetid://1255794"

	local Hammer = remote:InvokeServer("CreatePart","Normal",CFrame.new(0,0,0),char)
	local FireEffect = remote:InvokeServer("CreatePart","Normal",CFrame.new(0,0,0),char)
	spawn(function()
		AddMesh(Hammer)
	end)
	spawn(function()
		SetMesh(Hammer,"1256290", Vector3.new(0, 0, 0))
	end)
	spawn(function()
		SetTexture(Hammer,"1256283")
	end)
	spawn(function()
		SetName(Hammer,"Gravity Hammer")
	end)
	spawn(function()
		SetCollision(Hammer,false)
	end)
	spawn(function()
		CreatePointlight(Hammer)
	end)
	spawn(function()
		MeshResize(Hammer, Vector3.new(0.05,0.05,0.05))
	end)
	spawn(function()
		Resize(Hammer, Vector3.new(2.6,0.5,9.7),Hammer.CFrame)
	end)
	spawn(function()
		MovePart(Hammer, char["Right Arm"].CFrame *CFrame.new(0,-0.6,-3) * CFrame.Angles(math.rad(180),0,math.rad(-90)))
	end)
	spawn(function()
		Weld(Hammer,char["Right Arm"],Hammer)
	end)
	spawn(function()
		SetAnchor(false,Hammer)
	end)
	spawn(function()
		SetTrans(Hammer,1)
	end)

	spawn(function()
		MovePart(FireEffect, char["Right Arm"].CFrame *CFrame.new(0,-0.6,1.5) * CFrame.Angles(math.rad(270),0,0))
	end)
	spawn(function()
		Weld(FireEffect,Hammer,FireEffect)
	end)
	spawn(function()
		SetAnchor(false,FireEffect)
	end)
	spawn(function()
		--CreateFire(FireEffect)
	end)
	spawn(function()
		SetTrans(FireEffect,1)
	end)
	spawn(function()
		SetCollision(FireEffect,false)
	end)




	local GravityHammer = Instance.new('Tool',player.Backpack)
	GravityHammer.Name = "Gravity Hammer"
	GravityHammer.RequiresHandle = false
	GravityHammer.TextureId = "rbxassetid://13643093001"
	hold=Instance.new('Animation')
	hold.AnimationId='rbxassetid://182393478'
	hoId=char.Humanoid:LoadAnimation(hold)
	hoId.Looped=true

	local SFX = Instance.new('Sound',Hammer)
	SFX.Volume = 1
	SFX.SoundId = sound


	GravityHammer.Activated:connect(function()
		AnimationId = Animations[math.random(1,#Animations)]
		local anim = Instance.new("Animation")
		anim.AnimationId = AnimationId
		local Anima = char.Humanoid:LoadAnimation(anim)
		Anima:Play()
		Anima:AdjustSpeed(2)
		SFX:Play()

		local connect
		connect = Hammer.Touched:connect(function(hit)
			if hit:IsA("BasePart") then
				local hitChar = hit.Parent  
				if not hitChar then return end

				if hitChar == char then return end
				spawn(function()
					pcall(function()
						SetAnchor(false, hit)
					end)

					wait(0.3)
					if connect then 
						connect:Disconnect()
					end
				end)

				local otherPlayer = game.Players:GetPlayerFromCharacter(hitChar)
				if otherPlayer and otherPlayer ~= game.Players.LocalPlayer then
					if hitPlayer.Character and hitPlayer.Character:FindFirstChild("Humanoid") then
						spawn(function()
							Resize(hitPlayer.Character.Head, hitPlayer.Character.Head.Size, hitPlayer.Character.Head.CFrame)
						end)
					end
				end
			end
		end)
	end)

	GravityHammer.Equipped:Connect(function()
		spawn(function()
			spawn(function()
				SetTrans(Hammer,0)
			end)
			hoId:Play()
			spawn(function()
				CreateFire(FireEffect)
			end)
			spawn(function()
				SyncLighting(Hammer,5,Color3.fromRGB(255,125,0),18)
			end)
		end)
	end)

	GravityHammer.Unequipped:Connect(function()
		spawn(function()
			spawn(function()
				SetTrans(Hammer,1)
			end)
			hoId:Stop()
			for i,v in FireEffect:GetDescendants() do
				if v:IsA("Fire") then
					spawn(function()
						DestroyPart(v)
					end)
				end
			end
			spawn(function()
				SyncLighting(Hammer,0,Color3.fromRGB(0,0,0),0)
			end)
		end)
	end)
end)


BT("Message", function()
	RequestCommandSilent:InvokeServer(";sm EL K0PARAZ HAXXORED THIS GAME1!1!1")
end)

BT("Toadroast", function()
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent

SilentRequest:InvokeServer(";music 79999206651848")
SilentRequest:InvokeServer(";pitch .22")
SilentRequest:InvokeServer(";volume inf")

local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

for i, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for i, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)
    remote:InvokeServer(unpack(args))
end

function SetCollision(part, boolean)
    local args = {
        [1] = "SyncCollision",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["CanCollide"] = boolean
            }
        }
    }
    _(args)
end

function SetAnchor(boolean, part)
    local args = {
        [1] = "SyncAnchor",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Anchored"] = boolean
            }
        }
    }
    _(args)
end

function CreatePart(cf, parent)
    local args = {
        [1] = "CreatePart",
        [2] = "Normal",
        [3] = cf,
        [4] = parent
    }
    _(args)
end

function Resize(part, size, cf)
    local args = {
        [1] = "SyncResize",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["CFrame"] = cf,
                ["Size"] = size
            }
        }
    }
    _(args)
end

function AddMesh(part)
    local args = {
        [1] = "CreateMeshes",
        [2] = {
            [1] = {
                ["Part"] = part
            }
        }
    }
    _(args)
end

function SetMesh(part, meshid)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["MeshId"] = "rbxassetid://" .. meshid
            }
        }
    }
    _(args)
end

function SetTexture(part, texid)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["TextureId"] = "rbxassetid://" .. texid
            }
        }
    }
    _(args)
end

function MeshResize(part, size)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Scale"] = size
            }
        }
    }
    _(args)
end

function SetVertexColor(part, color)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["VertexColor"] = color
            }
        }
    }
    _(args)
end

function SetName(part, stringg)
    local args = {
        [1] = "SetName",
        [2] = {
            [1] = workspace.Part
        },
        [3] = stringg
    }
    _(args)
end

function Sky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = hrp.CFrame
    CreatePart(CFrame.new(cf.Position + Vector3.new(0, 6, 0)), workspace)
    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") and v.CFrame.Position == cf.Position + Vector3.new(0, 6, 0) then
            SetAnchor(true, v)
            AddMesh(v)
            SetMesh(v, "111891702759441")
            SetTexture(v, id)
            SetVertexColor(v, Vector3.new(4, 4, 4))
            MeshResize(v, Vector3.new(109888, 109888, 109888))
        end
    end
end

local function createRainToads()
    while true do
        wait(0.3)
        if player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
            local hrpcf = player.Character.HumanoidRootPart.CFrame
            local x = hrpcf.x
            local z = hrpcf.z
            local randint = math.random(-600, 600)
            local randint2 = math.random(-600, 600)
            local xloc = randint + x
            local zloc = randint2 + z
            local cf = player.Character.HumanoidRootPart.CFrame.y + 800

            spawn(function()
                local newToad = CreatePart(CFrame.new(math.floor(xloc), math.random(cf, cf + 400), math.floor(zloc)), workspace)
                for i, v in game.Workspace:GetDescendants() do
                    if v.Name == "Part" and v.Parent == workspace and v.CFrame.x == math.floor(xloc) and v.CFrame.z == math.floor(zloc) then
                        SetName(v, "MiniToad")
                        SetAnchor(false, v)
                        AddMesh(v)
                        SetMesh(v, "7234998844")
                        SetTexture(v, "1009824086")
                        SetCollision(v, false)
                        v.Orientation = Vector3.new(0, 0, 0)
                        local sound = Instance.new("Sound", v)
                        sound.SoundId = "rbxassetid://153752123"
                        sound.Volume = 10
                        sound.PlayOnRemove = true
                        sound:Destroy()
                    end
                end
            end)
        else
            wait(1)
        end
    end
end

coroutine.wrap(createRainToads)()

Sky("201208408")

local player = game.Players.LocalPlayer
local char = player.Character
local tool

for i, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for i, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)
    remote:InvokeServer(unpack(args))
end

function DestroyPart(part)
    local args = {
        [1] = "Remove",
        [2] = {
            [1] = part
        }
    }
    _(args)
end

function Punish(player)
    local char = player.Character
    DestroyPart(char)
end

coroutine.wrap(function()
    while true do
        for i, v in game.Players:GetPlayers() do
            pcall(function()
                Punish(v)
            end)
        end
        task.wait(0.0)
    end
end)()

SilentRequest:InvokeServer(";time 0")
SilentRequest:InvokeServer(";fogcolor black")
end)
BT("Kill All", function()
	RequestCommandSilent:InvokeServer(";kill all")
end)
BT("become thomas [R6]", function()
	local player = game.Players.LocalPlayer
	local char = player.Character
	local tool
	for i,v in player:GetDescendants() do
		if v.Name == "SyncAPI" then
			tool = v.Parent
		end
	end
	for i,v in game.ReplicatedStorage:GetDescendants() do
		if v.Name == "SyncAPI" then
			tool = v.Parent
		end
	end
	remote = tool.SyncAPI.ServerEndpoint
	function _(args)
		remote:InvokeServer(unpack(args))
	end
	function SetCollision(part,boolean)
		local args = {
			[1] = "SyncCollision",
			[2] = {
				[1] = {
					["Part"] = part,
					["CanCollide"] = boolean
				}
			}
		}
		_(args)
	end
	function SetAnchor(boolean,part)
		local args = {
			[1] = "SyncAnchor",
			[2] = {
				[1] = {
					["Part"] = part,
					["Anchored"] = boolean
				}
			}
		}
		_(args)
	end
	function CreatePart(cf,parent)
		local args = {
			[1] = "CreatePart",
			[2] = "Normal",
			[3] = cf,
			[4] = parent
		}
		_(args)
	end
	function DestroyPart(part)
		local args = {
			[1] = "Remove",
			[2] = {
				[1] = part
			}
		}
		_(args)
	end
	function MovePart(part,cf)
		local args = {
			[1] = "SyncMove",
			[2] = {
				[1] = {
					["Part"] = part,
					["CFrame"] = cf
				}
			}
		}
		_(args)
	end
	function Resize(part,size,cf)
		local args = {
			[1] = "SyncResize",
			[2] = {
				[1] = {
					["Part"] = part,
					["CFrame"] = cf,
					["Size"] = size
				}
			}
		}
		_(args)
	end
	function AddMesh(part)
		local args = {
			[1] = "CreateMeshes",
			[2] = {
				[1] = {
					["Part"] = part
				}
			}
		}
		_(args)
	end

	function SetMesh(part,meshid)
		local args = {
			[1] = "SyncMesh",
			[2] = {
				[1] = {
					["Part"] = part,
					["MeshId"] = "rbxassetid://"..meshid
				}
			}
		}
		_(args)
	end
	function SetTexture(part, texid)
		local args = {
			[1] = "SyncMesh",
			[2] = {
				[1] = {
					["Part"] = part,
					["TextureId"] = "rbxassetid://"..texid
				}
			}
		}
		_(args)
	end
	function SetName(part, stringg)
		local args = {
			[1] = "SetName",
			[2] = {
				[1] = workspace.Part
			},
			[3] = stringg
		}

		_(args)
	end
	function MeshResize(part,size)
		local args = {
			[1] = "SyncMesh",
			[2] = {
				[1] = {
					["Part"] = part,
					["Scale"] = size
				}
			}
		}
		_(args)
	end
	function Weld(part1, part2,lead)
		local args = {
			[1] = "CreateWelds",
			[2] = {
				[1] = part1,
				[2] = part2
			},
			[3] = lead
		}
		_(args)

	end
	function SetLocked(part,boolean)
		local args = {
			[1] = "SetLocked",
			[2] = {
				[1] = part
			},
			[3] = boolean
		}
		_(args)
	end
	function SetTrans(part,int)
		local args = {
			[1] = "SyncMaterial",
			[2] = {
				[1] = {
					["Part"] = part,
					["Transparency"] = int
				}
			}
		}
		_(args)
	end
	function CreateSpotlight(part)
		local args = {
			[1] = "CreateLights",
			[2] = {
				[1] = {
					["Part"] = part,
					["LightType"] = "SpotLight"
				}
			}
		}
		_(args)
	end
	function SyncLighting(part,brightness)
		local args = {
			[1] = "SyncLighting",
			[2] = {
				[1] = {
					["Part"] = part,
					["LightType"] = "SpotLight",
					["Brightness"] = brightness
				}
			}
		}
		_(args)
	end
	local player = game.Players.LocalPlayer
	local char = player.Character

	function xd()
		spawn(function()
			local args = {
				[1] = "SyncMaterial",
				[2] = {
					[1] = {
						["Part"] = game:GetService("Players").LocalPlayer.Character.Torso,
						["Transparency"] = 1
					},
					[2] = {
						["Part"] = game:GetService("Players").LocalPlayer.Character:FindFirstChild("Left Leg"),
						["Transparency"] = 1
					},
					[3] = {
						["Part"] = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart,
						["Transparency"] = 1
					},
					[4] = {
						["Part"] = game:GetService("Players").LocalPlayer.Character:FindFirstChild("Right Leg"),
						["Transparency"] = 1
					},
					[5] = {
						["Part"] = game:GetService("Players").LocalPlayer.Character:FindFirstChild("Right Arm"),
						["Transparency"] = 1
					},
					[6] = {
						["Part"] = game:GetService("Players").LocalPlayer.Character:FindFirstChild("Left Arm"),
						["Transparency"] = 1
					},
					[7] = {
						["Part"] = game:GetService("Players").LocalPlayer.Character.Head,
						["Transparency"] = 1
					},
				}
			}

			_(args)

		end)
	end

	function Thomas(player)
		SetAnchor(true,char.HumanoidRootPart)
		CreatePart(char.HumanoidRootPart.CFrame,char,"Normal")
		SetCollision(char.Part,false)
		SetLocked(char.Part,false)
		Resize(char.Part,Vector3.new(5,5,10),char.HumanoidRootPart.CFrame)
		CreateSpotlight(char.Part)
		SyncLighting(char.Part,100)
		SetLocked(char.HumanoidRootPart,false)
		Weld(char.Part,char.HumanoidRootPart,char.Part)
		SetAnchor(false,char.Part)
		AddMesh(char.Part)
		MeshResize(char.Part,Vector3.new(2,2,1.5))
		SetMesh(char.Part,"2231280549")
		SetTexture(char.Part,"2231280614")
		SetAnchor(false,char.HumanoidRootPart)
		char.Humanoid.WalkSpeed = 80
		local function SFX(id) local s=Instance.new("Sound",char.Torso); s.SoundId = "rbxassetid://"..id; s.Volume = 1; return s; end
		char.Part.Touched:connect(function(p)
			if p.Parent then
				if p.Parent:IsA("Model") then
					if game.Players:FindFirstChild(p.Parent.Name) then
						if p.Parent.Name ~= game.Players.LocalPlayer.Name then
							spawn(function()
								DestroyPart(game.Players:FindFirstChild(p.Parent.Name).Character.Head)
							end)
							local Whistle = SFX(475073913)
							Whistle:Play()
						end
					end
				end
			end
		end)

		local Music = SFX(0)
		Music.Pitch = 1.15
		Music:Play()

		game:GetService("RunService").RenderStepped:Connect(function()
			for i,v in char:GetDescendants() do
				if v:IsA("BasePart") then
					char.Humanoid.WalkSpeed = 80
					v.CanCollide = false
				end
			end
		end)
	end
	Thomas(player)
	xd()
end)
BT("Explode random", function()
	local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local backpack = player.Backpack

local function getf3x()
	for _, v in ipairs(backpack:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	for _, v in ipairs(char:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	return nil
end

local f3x = getf3x()
if not f3x then
	warn("No F3X found!")
	return
end

local remote = f3x.SyncAPI.ServerEndpoint
local function invokeServer(...)
	return remote:InvokeServer(...)
end

local function createPart(cf)
	return invokeServer("CreatePart", "Normal", cf, workspace)
end

local function resize(part, size)
	invokeServer("SyncResize", {{Part = part, CFrame = part.CFrame, Size = size}})
end

local function color(part, color3)
	invokeServer("SyncColor", {{Part = part, Color = color3, UnionColoring = false}})
end

local function addFire(part, size, heat)
	invokeServer("CreateDecorations", {{Part = part, DecorationType = "Fire"}})
	invokeServer("SyncDecorate", {{
		Part = part,
		DecorationType = "Fire",
		Size = size,    -- BIGGER FIRE SIZE
		Heat = heat     -- HOTTER FIRE
	}})
end

local function addLight(part, brightness, color)
	invokeServer("CreateLights", {{Part = part, LightType = "PointLight"}})
	invokeServer("SyncLighting", {{
		Part = part,
		LightType = "PointLight",
		Brightness = brightness,
		Color = color
	}})
end

local function anchor(part, anchored)
	invokeServer("SyncAnchor", {{Part = part, Anchored = anchored}})
end

local function destroy(part)
	invokeServer("Remove", {part})
end

local function spawnFireball(pos)
	local part = createPart(CFrame.new(pos))
	if not part then return end
	
	resize(part, Vector3.new(0.1, 0.1, 0.1))
	color(part, Color3.new(0,0,0))
	anchor(part, true)
	
	addFire(part, 80, 100)         -- way bigger than default
	addLight(part, 50, Color3.new(1, 0.4, 0)) -- bright flash
	
	task.delay(0.4, function()
		destroy(part)
	end)
end

local root = char:WaitForChild("HumanoidRootPart")

while task.wait(0.08) do
	for _ = 1, 6 do
		task.spawn(function()
			local x = root.Position.X + math.random(-300, 300)
			local y = root.Position.Y + math.random(100, 400)
			local z = root.Position.Z + math.random(-300, 300)
			spawnFireball(Vector3.new(x, y, z))
		end)
	end
end
end)
BT("raining fire", function()
	local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

local tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end
for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

if not tool then
    warn("No F3X tool found!")
    return
end

local remote = tool.SyncAPI.ServerEndpoint
local function call(args)
    remote:InvokeServer(unpack(args))
end

local function CreatePart(cf)
    return remote:InvokeServer("CreatePart", "Normal", cf, workspace)
end

local function Resize(part, size)
    call({"SyncResize", {{Part = part, CFrame = part.CFrame, Size = size}}})
end

local function SetShape(part, shape)
    call({"SyncShape", {{Part = part, Shape = shape}}})
end

local function SetCollision(part, bool)
    call({"SyncCollision", {{Part = part, CanCollide = bool}}})
end

local function Anchor(part, bool)
    call({"SyncAnchor", {{Part = part, Anchored = bool}}})
end

local function AddFire(part)
    call({"CreateDecorations", {{Part = part, DecorationType = "Fire"}}})
    call({"SyncDecorate", {{
        Part = part,
        DecorationType = "Fire",
        Size = 25,
        Heat = 30
    }}})
end

local function SetColor(part, color3)
    call({"SyncColor", {{
        Part = part,
        Color = color3,
        UnionColoring = false
    }}})
end

local root = char:WaitForChild("HumanoidRootPart")

while task.wait(0.25) do
    local x = root.Position.X + math.random(-300, 300)
    local z = root.Position.Z + math.random(-300, 300)
    local y = root.Position.Y + math.random(250, 500)
    local cf = CFrame.new(x, y, z)

    task.spawn(function()
        local newPart = CreatePart(cf)
        task.wait(0.2) -- allow part to exist
        
        for _, v in workspace:GetChildren() do
            if v:IsA("Part") and (v.Position - cf.Position).Magnitude < 5 then
                Resize(v, Vector3.new(10, 10, 10)) -- medium meteor size
                SetShape(v, Enum.PartType.Ball)
                SetColor(v, Color3.new(0, 0, 0)) -- BLACK meteor
                AddFire(v)

                SetCollision(v, true)   -- collide with floor
                Anchor(v, false)        -- unanchored so it falls
                
                break
            end
        end
    end)
end
end)
BT("Destroy. [ONLY FOR EMERGENCY]", function()
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
pcall(function()
    RequestCommand:InvokeServer(";btools me")
    RequestCommand:InvokeServer(";fogcolor black")
    task.wait(0.4)
    RequestCommand:InvokeServer(";punish all")
end)

local backpack = player.Backpack
local function getf3x()
    for _, v in ipairs(backpack:GetChildren()) do
        if v:FindFirstChild("SyncAPI") then return v end
    end
    for _, v in ipairs(char:GetChildren()) do
        if v:FindFirstChild("SyncAPI") then return v end
    end
    return nil
end

local f3x = getf3x()
if not f3x then
    warn("You don't have F3X")
    return
end
local syncapi = f3x.SyncAPI
local serverendpoint = syncapi.ServerEndpoint

local function fastInvoke(args)
    task.spawn(function()
        pcall(function()
            serverendpoint:InvokeServer(unpack(args))
        end)
    end)
end

local function delete(part)
    fastInvoke({"Remove",{part}})
end

for _, v in ipairs(workspace:GetDescendants()) do
    if v:IsA("BasePart") or v:IsA("UnionOperation") then
        task.spawn(function()
            pcall(function() delete(v) end)
        end)
    end
end

print("All parts deleted (fast).")

local function _(args) serverendpoint:InvokeServer(unpack(args)) end
local function MovePart(part, cf) _( {"SyncMove", { { Part = part, CFrame = cf } } } ) end
local function resize(part, size, cf) _( {"SyncResize", { { Part = part, CFrame = cf, Size = size } } } ) end
local function transparency(part, trans) _( {"SyncMaterial", { { Part = part, Transparency = trans } } } ) end
local function color(part, color3) _( {"SyncColor", { { Part = part, Color = color3, UnionColoring = false } } } ) end
local function makemesh(part) _( {"CreateMeshes", { { Part = part } } } ) end
local function syncmeshid(part, id) _( {"SyncMesh", { { Part = part, MeshId = "rbxassetid://"..id } } } ) end
local function syncmeshsize(part, size) _( {"SyncMesh", { { Part = part, Scale = size } } } ) end
local function syncmeshtexture(part, id) _( {"SyncMesh", { { Part = part, TextureId = "rbxassetid://"..id } } } ) end
local function name(part, str) _( {"SetName", { part }, str} ) end
local function createtexture(part, face) _( {"CreateTextures", { { Part = part, Face = face, TextureType = "Texture" } } } ) end
local function createdecal(part, face) _( {"CreateTextures", { { Part = part, Face = face, TextureType = "Decal" } } } ) end
local function setdecal(part, asset, face) _( {"SyncTexture", { { Part = part, Face = face, TextureType = "Decal", Texture = "rbxassetid://"..asset } } } ) end
local function floor(part, face) _( {"SyncTexture", { { Part = part, Face = face, TextureType = "Texture", Texture = "rbxassetid://135172958780980", StudsPerTileV = 2, StudsPerTileU = 2 } } } ) end

local function CreatePart(cf, parent, ptype)
    return serverendpoint:InvokeServer("CreatePart", ptype or "Normal", cf, parent or workspace)
end

local function Sky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = CFrame.new(math.floor(hrp.Position.X), math.floor(hrp.Position.Y), math.floor(hrp.Position.Z)) + Vector3.new(0,6,0)
    local skyPart = CreatePart(cf, workspace)
    name(skyPart,"Sky")
    makemesh(skyPart)
    syncmeshid(skyPart,"111891702759441")
    syncmeshtexture(skyPart,id)
    syncmeshsize(skyPart,Vector3.new(61000,61000,61000))
end

local function RealmV2()
    local position = CFrame.new(-152.421, -46.197, -115.697)
    local base = CreatePart(position, workspace)
    resize(base, Vector3.new(869, 1, 543), position)
    color(base, Color3.fromRGB(71, 101, 76))
    createtexture(base, Enum.NormalId.Top)
    floor(base, Enum.NormalId.Top)

    local spawnpos = CFrame.new(42.125, -45.697, -48.895)
    local spawna = CreatePart(spawnpos, workspace, "Spawn")
    resize(spawna, Vector3.new(6, 1, 6), spawnpos)
    name(spawna, "SpawnLocation")
    createdecal(spawna, Enum.NormalId.Top)
    setdecal(spawna, "108356843475171", Enum.NormalId.Top)

    local wall = CFrame.new(64.885, -40.197, -74.988)
    local base2 = CreatePart(wall, workspace)
    resize(base2, Vector3.new(27, 12, 1), wall)
    transparency(base2, 1)
    createdecal(base2, Enum.NormalId.Back)
    setdecal(base2, "130387609774454", Enum.NormalId.Back)

    local pos1 = CFrame.new(49.037, -42.797, -75.077)
    local obj1 = CreatePart(pos1, workspace)
    makemesh(obj1)
    syncmeshid(obj1, "7879233630")
    syncmeshtexture(obj1, "113929343766399")
    MovePart(obj1, obj1.CFrame * CFrame.Angles(0, math.rad(180), 0))

    local pos2 = CFrame.new(36.46, -45.197, -76.523)
    local obj2 = CreatePart(pos2, workspace)
    makemesh(obj2)
    syncmeshid(obj2, "13846055645")
    syncmeshtexture(obj2, "13846055859")
    syncmeshsize(obj2, Vector3.new(5, 5, 5))
    MovePart(obj2, obj2.CFrame * CFrame.Angles(0, math.rad(90), 0))

    local pos3 = CFrame.new(35.793, -32.697, -104.497)
    local obj3 = CreatePart(pos3, workspace)
    makemesh(obj3)
    syncmeshid(obj3, "7879233630")
    syncmeshtexture(obj3, "125929634799364")
    syncmeshsize(obj3, Vector3.new(5, 5, 5))
    MovePart(obj3, obj3.CFrame * CFrame.Angles(0, math.rad(180), 0))

    local pos4 = CFrame.new(35.753, -19.697, -104.15)
    local obj4 = CreatePart(pos4, workspace)
    makemesh(obj4)
    syncmeshid(obj4, "5924046624")
    syncmeshtexture(obj4, "5924037225")
    syncmeshsize(obj4, Vector3.new(3, 3, 3))
end

local function realm()
    RealmV2()
    Sky("9820931824")
end

realm()

pcall(function()
    RequestCommand:InvokeServer(";time 6")
    task.wait(0.2)
    RequestCommand:InvokeServer(";res all")
task.wait(1.7)
RequestCommandSilent:InvokeServer(";music 1839246711 ;volume inf")
end)
end)
BT("KaaX Script", function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
SilentRequest:InvokeServer(";unfog")
SilentRequest:InvokeServer(";fogcolor black")
SilentRequest:InvokeServer(";time 0")

local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

local tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

local function _(args)
    remote:InvokeServer(unpack(args))
end

local function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end

local function SetAnchor(part, state)
    _({"SyncAnchor", {{Part = part, Anchored = state}}})
end

local function SetCollision(part, state)
    _({"SyncCollision", {{Part = part, CanCollide = state}}})
end

local function AddMesh(part)
    _({"CreateMeshes", {{Part = part}}})
end

local function SetMesh(part, meshid)
    _({"SyncMesh", {{Part = part, MeshId = "rbxassetid://" .. meshid}}})
end

local function SetTexture(part, texid)
    _({"SyncMesh", {{Part = part, TextureId = "rbxassetid://" .. texid}}})
end

local function MeshResize(part, size)
    _({"SyncMesh", {{Part = part, Scale = size}}})
end

local function SetLocked(part, state)
    _({"SetLocked", {part}, state})
end

local function SpawnDecal(part, side)
    _({"CreateTextures", {{Part = part, Face = side, TextureType = "Decal"}}})
end

local function AddDecal(part, asset, side)
    _({"SyncTexture", {{Part = part, Face = side, TextureType = "Decal", Texture = "rbxassetid://" .. asset}}})
end

local function SetVertexColor(part, color)
    _({"SyncMesh", {{Part = part, VertexColor = color}}})
end

local function GiantSky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = hrp.CFrame
    local pos = cf.Position + Vector3.new(0, 6, 0)
    CreatePart(CFrame.new(pos), workspace)
    task.wait(0.3)

    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") and (v.Position - pos).Magnitude < 1 then
            SetAnchor(v, true)
            AddMesh(v)
            SetMesh(v, "111891702759441")
            SetTexture(v, id)
            SetVertexColor(v, Vector3.new(4, 4, 4))
            MeshResize(v, Vector3.new(109888, 109888, 109888))
            SetCollision(v, false)
            SetLocked(v, true)
        end
    end
end

local function Spam(id)
    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") then
            task.spawn(function()
                SetLocked(v, false)
                for _, side in ipairs(Enum.NormalId:GetEnumItems()) do
                    SpawnDecal(v, side)
                    AddDecal(v, id, side)
                end
            end)
        end
    end
end

Spam("12330950245")
GiantSky("12330950245")

end)
BT("Shedletsky", function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
SilentRequest:InvokeServer(";time 6")
SilentRequest:InvokeServer(";fogcolor black")

local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
        break
    end
end

if not tool then
    for _, v in game.ReplicatedStorage:GetDescendants() do
        if v.Name == "SyncAPI" then
            tool = v.Parent
            break
        end
    end
end

if not tool then
    error("SyncAPI tool not found")
end

local remote = tool.SyncAPI.ServerEndpoint

local function _(args)
    remote:InvokeServer(unpack(args))
end

local function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end

local function SetAnchor(part, state)
    _({"SyncAnchor", {{Part = part, Anchored = state}}})
end

local function SetCollision(part, state)
    _({"SyncCollision", {{Part = part, CanCollide = state}}})
end

local function AddMesh(part)
    _({"CreateMeshes", {{Part = part}}})
end

local function SetMesh(part, meshid)
    _({"SyncMesh", {{Part = part, MeshId = "rbxassetid://" .. meshid}}})
end

local function SetTexture(part, texid)
    _({"SyncMesh", {{Part = part, TextureId = "rbxassetid://" .. texid}}})
end

local function MeshResize(part, size)
    _({"SyncMesh", {{Part = part, Scale = size}}})
end

local function SetVertexColor(part, color)
    _({"SyncMesh", {{Part = part, VertexColor = color}}})
end

local function SetLocked(part, state)
    _({"SetLocked", {part}, state})
end

local function Resize(part, size, cf)
    _({"SyncResize", {{Part = part, CFrame = cf, Size = size}}})
end

local function SpawnDecal(part, face)
    _({"CreateTextures", {{Part = part, Face = face, TextureType = "Decal"}}})
end

local function AddDecal(part, asset, face)
    _({"SyncTexture", {{Part = part, Face = face, TextureType = "Decal", Texture = "rbxassetid://" .. asset}}})
end

local function SetName(part, name)
    _({"SetName", {part}, name})
end

local function SetTrans(part, val)
    _({"SyncMaterial", {{Part = part, Transparency = val}}})
end

local function delete(part)
    _({"Remove", {part}})
end

local function GiantSky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local pos = hrp.Position + Vector3.new(0, 6, 0)

    CreatePart(CFrame.new(pos), workspace)
    task.wait(0.3)

    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") and (v.Position - pos).Magnitude < 1 then
            SetAnchor(v, true)
            AddMesh(v)
            SetMesh(v, "111891702759441")
            SetTexture(v, id)
            SetVertexColor(v, Vector3.new(4, 4, 4))
            MeshResize(v, Vector3.new(109888, 109888, 109888))
            SetCollision(v, false)
            SetLocked(v, true)
        end
    end
end

local activeParticles = {}
local particleCooldowns = {}

local function createParticleForPlayer(targetPlayer, textureId)
    local character = targetPlayer.Character
    if not character then
        targetPlayer.CharacterAdded:Wait()
        character = targetPlayer.Character
    end

    local humanoid = character:WaitForChild("Humanoid")
    local playerKey = targetPlayer.UserId
    local cooldownKey = playerKey .. "_" .. textureId
    particleCooldowns[cooldownKey] = particleCooldowns[cooldownKey] or 0

    while true do
        local currentTime = tick()

        if currentTime - particleCooldowns[cooldownKey] >= 2 then
            particleCooldowns[cooldownKey] = currentTime

            if not targetPlayer or not targetPlayer.Parent or not character or not character.Parent or humanoid.Health <= 0 then
                break
            end

            local head = character:FindFirstChild("Head")
            if not head then
                task.wait(1)
                continue
            end

            local spawnCFrame = head.CFrame + Vector3.new(0, 3, 0)

            task.spawn(function()
                CreatePart(spawnCFrame, workspace)
                task.wait(0.1)

                local newPart = nil
                for _, v in workspace:GetChildren() do
                    if v:IsA("Part") and (v.Position - spawnCFrame.Position).Magnitude < 1 then
                        newPart = v
                        break
                    end
                end

                if newPart then
                    SetName(newPart, "particle_" .. targetPlayer.Name .. "_" .. textureId)
                    Resize(newPart, Vector3.new(6, 6, 0.001), newPart.CFrame)
                    SetCollision(newPart, false)
                    SetTrans(newPart, 1)
                    SetAnchor(newPart, true)
                    newPart.Orientation = Vector3.new(0, 0, 0)

                    SpawnDecal(newPart, Enum.NormalId.Front)
                    AddDecal(newPart, textureId, Enum.NormalId.Front)
                    SpawnDecal(newPart, Enum.NormalId.Back)
                    AddDecal(newPart, textureId, Enum.NormalId.Back)

                    local particleId = #activeParticles + 1
                    activeParticles[particleId] = newPart

                    for i = 1, 40 do
                        if newPart and newPart.Parent and head and head.Parent then
                            local currentHeadPos = head.Position
                            local newPosition = Vector3.new(
                                currentHeadPos.X,
                                spawnCFrame.Position.Y + (i * 2),
                                currentHeadPos.Z
                            )
                            Resize(newPart, newPart.Size, CFrame.new(newPosition))
                            task.wait(0.05)
                        else
                            break
                        end
                    end

                    if newPart and newPart.Parent then
                        delete(newPart)
                    end
                    activeParticles[particleId] = nil
                end
            end)
        end

        task.wait(0.5)
    end
end

local function startParticleSystem()
    local textureIds = {"85312612489831"}

    local function startForPlayer(p)
        for _, texId in ipairs(textureIds) do
            coroutine.wrap(function()
                createParticleForPlayer(p, texId)
            end)()
        end
    end

    local function stopForPlayer(p)
        for id, part in pairs(activeParticles) do
            if part.Name:find(p.Name) and part.Parent then
                delete(part)
                activeParticles[id] = nil
            end
        end
    end

    for _, p in ipairs(Players:GetPlayers()) do
        startForPlayer(p)
    end

    Players.PlayerAdded:Connect(startForPlayer)
    Players.PlayerRemoving:Connect(stopForPlayer)
end

local function setupCleanup()
    while true do
        task.wait(10)
        for id, part in pairs(activeParticles) do
            if not part or not part.Parent then
                activeParticles[id] = nil
            end
        end
    end
end

GiantSky("172423468")
startParticleSystem()
coroutine.wrap(setupCleanup)()
end)
BT("c00lify", function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
SilentRequest:InvokeServer(";unfog")
SilentRequest:InvokeServer(";fogcolor black")
SilentRequest:InvokeServer(";time 0")

local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

local tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

local function _(args)
    remote:InvokeServer(unpack(args))
end

local function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end

local function SetAnchor(part, state)
    _({"SyncAnchor", {{Part = part, Anchored = state}}})
end

local function SetCollision(part, state)
    _({"SyncCollision", {{Part = part, CanCollide = state}}})
end

local function AddMesh(part)
    _({"CreateMeshes", {{Part = part}}})
end

local function SetMesh(part, meshid)
    _({"SyncMesh", {{Part = part, MeshId = "rbxassetid://" .. meshid}}})
end

local function SetTexture(part, texid)
    _({"SyncMesh", {{Part = part, TextureId = "rbxassetid://" .. texid}}})
end

local function MeshResize(part, size)
    _({"SyncMesh", {{Part = part, Scale = size}}})
end

local function SetLocked(part, state)
    _({"SetLocked", {part}, state})
end

local function SpawnDecal(part, side)
    _({"CreateTextures", {{Part = part, Face = side, TextureType = "Decal"}}})
end

local function AddDecal(part, asset, side)
    _({"SyncTexture", {{Part = part, Face = side, TextureType = "Decal", Texture = "rbxassetid://" .. asset}}})
end

local function SetVertexColor(part, color)
    _({"SyncMesh", {{Part = part, VertexColor = color}}})
end

local function GiantSky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = hrp.CFrame
    local pos = cf.Position + Vector3.new(0, 6, 0)
    CreatePart(CFrame.new(pos), workspace)
    task.wait(0.3)

    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") and (v.Position - pos).Magnitude < 1 then
            SetAnchor(v, true)
            AddMesh(v)
            SetMesh(v, "111891702759441")
            SetTexture(v, id)
            SetVertexColor(v, Vector3.new(4, 4, 4))
            MeshResize(v, Vector3.new(109888, 109888, 109888))
            SetCollision(v, false)
            SetLocked(v, true)
        end
    end
end

local function Spam(id)
    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") then
            task.spawn(function()
                SetLocked(v, false)
                for _, side in ipairs(Enum.NormalId:GetEnumItems()) do
                    SpawnDecal(v, side)
                    AddDecal(v, id, side)
                end
            end)
        end
    end
end

Spam("158118263")
GiantSky("139653027079448")
end)

BT("John Doe [R6]", function()
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

local scriptActive = true
local inputConnection
local descendantConnection

local function disableScript()
    scriptActive = false
    if inputConnection then
        inputConnection:Disconnect()
    end
    if descendantConnection then
        descendantConnection:Disconnect()
    end
end

for i,v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end
for i,v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

remote = tool.SyncAPI.ServerEndpoint
function _(args)
    remote:InvokeServer(unpack(args))
end

local function Color(part, color)
    local args = {
        "SyncColor",
        {
            {
                Part = part,
                Color = color,
                UnionColoring = false
            }
        }
    }
    _(args)
end

local function applyDecorationToPart(part)
    local argsCreate = {
        [1] = "CreateDecorations",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["DecorationType"] = "Fire"
            }
        }
    }
    local argsSync = {
        [1] = "SyncDecorate",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["DecorationType"] = "Fire",
                ["Size"] = 3,
                ["Heat"] = 25,
                ["Color"] = Color3.fromRGB(255, 0, 0),
                ["SecondaryColor"] = Color3.fromRGB(255, 0, 0)
            }
        }
    }
    _(argsCreate)
    _(argsSync)
end

local function Parter(part)
    local argsCreate = {
        [1] = "CreateDecorations",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["DecorationType"] = "Smoke"
            }
        }
    }
    local argsSync = {
        [1] = "SyncDecorate",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["DecorationType"] = "Smoke",
                ["Size"] = 3,
                ["Color"] = Color3.fromRGB(255, 0, 0),
            }
        }
    }
    _(argsCreate)
    _(argsSync)
end

local function eyePart(part)
    local argsCreate = {
        [1] = "CreateDecorations",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["DecorationType"] = "Fire"
            }
        }
    }
    local argsSync = {
        [1] = "SyncDecorate",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["DecorationType"] = "Fire",
                ["Size"] = 1,
                ["Heat"] = 12,
                ["Color"] = Color3.fromRGB(155, 0, 0),
                ["SecondaryColor"] = Color3.fromRGB(255, 0, 0)
            }
        }
    }
    _(argsCreate)
    _(argsSync)
end

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandModification

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

RequestCommand:InvokeServer(";removeaccessories")
RequestCommand:InvokeServer(";titlebk me John Doe")
wait(1)
RequestCommand:InvokeServer(";hat me 107676946962151")
wait(0.9)
RequestCommand:InvokeServer(";hat me 18196403126")
wait(1)
RequestCommand:InvokeServer(";hat me 18801497637")
wait(1)
RequestCommand:InvokeServer(";shirt me 100276101149100")
wait(1)
RequestCommand:InvokeServer(";head me 0")
RequestCommand:InvokeServer(";face me 144075659")
wait(1)
RequestCommand:InvokeServer(";shirt me 100276101149100")
RequestCommand:InvokeServer(";pants me 109662040845019")
wait(1.8)
RequestCommand:InvokeServer(";time 0")

local eye = char:FindFirstChild("Accessory (JohnEye)").Handle
local arm = char:FindFirstChild("Right Arm")
local tor = char:FindFirstChild("Torso")
local ar2 = char:FindFirstChild("Left Arm")
local RLeg = char:FindFirstChild("Right Leg")
local head = char:FindFirstChild("Head")
local LLeg = char:FindFirstChild("Left Leg")

applyDecorationToPart(arm)
applyDecorationToPart(ar2)
eyePart(eye)
Parter(tor)

Color(arm, Color3.fromRGB(252, 255, 150))
Color(ar2, Color3.fromRGB(252, 255, 150))
Color(head, Color3.fromRGB(252, 255, 150))
Color(tor, Color3.fromRGB(255, 255, 0))
Color(RLeg, Color3.fromRGB(0, 200, 255))
Color(LLeg, Color3.fromRGB(0, 200, 255))

local arm = character:FindFirstChild("Right Arm")
local humanoid = character:FindFirstChildOfClass("Humanoid")

player.CharacterRemoving:Connect(function()
    disableScript()
end)

humanoid.Died:Connect(function()
    disableScript()
end)

local animator = humanoid:FindFirstChildOfClass("Animator")
local attackAnim = Instance.new("Animation")
attackAnim.AnimationId = "rbxassetid://186934658"
local attackTrack = animator:LoadAnimation(attackAnim)

function KillTarget(target)
    if not scriptActive then return end
    if target and target.Character then
        local head = target.Character:FindFirstChild("Head")
        if head then
            local args = {
                [1] = "SetLocked",
                [2] = {
                    [1] = head
                },
                [3] = false
            }
            remote:InvokeServer(unpack(args))
            task.wait(0.1)
            local args2 = {
                [1] = "Remove",
                [2] = {
                    [1] = head
                }
            }
            remote:InvokeServer(unpack(args2))
        end
    end
end

local function attack()
    if not scriptActive then return end
    attackTrack:Play()
    local hitPlayer = nil
    local touchedConnection

    local function onTouch(other)
        if not scriptActive then return end
        local otherPlayer = Players:GetPlayerFromCharacter(other.Parent)
        if otherPlayer and otherPlayer ~= player then
            hitPlayer = otherPlayer
        end
    end

    touchedConnection = arm.Touched:Connect(onTouch)
    task.wait(0.5)
    if touchedConnection then
        touchedConnection:Disconnect()
    end
    if hitPlayer then
        RequestCommand:InvokeServer(";music 82500396906354 ;volume 0.5")
        KillTarget(hitPlayer)
        task.wait(1)
        RequestCommand:InvokeServer(";unmusic")
    else
        RequestCommand:InvokeServer(";music 28144425 ;pitch 0.6 ;volume 7")
        task.wait(0.8)
        RequestCommand:InvokeServer(";unmusic")
    end
end

local canAttack = true
local function attackWithCooldown()
    if not scriptActive or not canAttack then return end
    canAttack = false
    attack()
    task.delay(2.2, function()
        canAttack = true
    end)
end

inputConnection = UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    if not scriptActive then 
        return 
    end
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        attackWithCooldown()
    end
end)

local player = game.Players.LocalPlayer
local char = player.Character
local backpack = player.Backpack

local function getf3x()
    for _, v in ipairs(backpack:GetChildren()) do
        if v:FindFirstChild("SyncAPI") then
            return v
        end
    end
    for _, v in ipairs(char:GetChildren()) do
        if v:FindFirstChild("SyncAPI") then
            return v
        end
    end
    return nil
end

local f3x = getf3x()
if not f3x then
    warn("you dont have f3x skid")
end
local syncapi = f3x.SyncAPI
local serverendpoint = syncapi.ServerEndpoint

function _(args)
    serverendpoint:InvokeServer(unpack(args))
end

local function fire(part)
    local argsCreate = {
        [1] = "CreateDecorations",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["DecorationType"] = "Fire"
            }
        }
    }
    local argsSync = {
        [1] = "SyncDecorate",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["DecorationType"] = "Fire",
                ["Size"] = 15,
                ["Heat"] = 15,
                ["Color"] = Color3.fromRGB(255, 0, 0),
                ["SecondaryColor"] = Color3.fromRGB(255, 0, 0)
            }
        }
    }
    _(argsCreate)
    _(argsSync)
end

function delete(part)
    local args = {
        [1] = "Remove",
        [2] = {
            [1] = part
        }
    }
    _(args)
end

function MovePart(part, cf)
    local args = {
        "SyncMove",
        {
            {
                Part = part,
                CFrame = cf
            }
        }
    }
    _(args)
end

local function resize(part, size, cf)
    local args = {
        "SyncResize",
        {
            {
                Part = part,
                CFrame = cf,
                Size = size
            }
        }
    }
    _(args)
end

local function syncmaterial(part, mate)
    local args = {
        "SyncMaterial",
        {
            {
                Part = part,
                Material = mate
            }
        }
    }
    _(args)
end

local function transparency(part, trans)
    local args = {
        "SyncMaterial",
        {
            {
                Part = part,
                Transparency = trans
            }
        }
    }
    _(args)
end

local function color(part, color)
    local args = {
        "SyncColor",
        {
            {
                Part = part,
                Color = color,
                UnionColoring = false
            }
        }
    }
    _(args)
end

local function syncmeshid(part, id)
    local args = {
        "SyncMesh",
        {
            {
                Part = part,
                MeshId = "rbxassetid://" .. id
            }
        }
    }
    _(args)
end

function destroy(part)
    local args = {
        [1] = "Remove",
        [2] = {
            [1] = part
        }
    }
    _(args)
end

local function makemesh(part)
    local args = {
        "CreateMeshes",
        {
            {
                Part = part
            }
        }
    }
    _(args)
end

local function syncmeshsize(part, vectora)
    local args = {
        "SyncMesh",
        {
            {
                Part = part,
                Scale = vectora
            }
        }
    }
    _(args)
end

local function syncmeshtexture(part, id)
    local args = {
        "SyncMesh",
        {
            {
                Part = part,
                TextureId = "rbxassetid://" .. id
            }
        }
    }
    _(args)
end

local function name(part, stringa)
    local args = {
        "SetName",
        { part },
        stringa
    }
    _(args)
end

local function lock(part, boolean)
    local args = {
        "SetLocked",
        { part },
        boolean
    }
    _(args)
end

local function setcollision(part, booleana)
    local args = {
        "SyncCollision",
        {
            {
                Part = part,
                CanCollide = booleana
            }
        }
    }
    _(args)
end

local function setanchor(part, boolean)
    local args = {
        "SyncAnchor",
        {
            {
                Part = part,
                Anchored = boolean
            }
        }
    }
    _(args)
end

local function createdecal(part, side)
    local args = {
        "CreateTextures",
        {
            {
                Part = part,
                Face = side,
                TextureType = "Decal"
            }
        }
    }
    _(args)
end

local function setdecal(part, asset, side)
    local args = {
        "SyncTexture",
        {
            {
                Part = part,
                Face = side,
                TextureType = "Decal",
                Texture = "rbxassetid://" .. asset
            }
        }
    }
    _(args)
end

local function addlight(part)
    local args = {
        [1] = "CreateLights",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["LightType"] = "PointLight"
            }
        }
    }
    serverendpoint:InvokeServer(unpack(args))
end

local function synclight(part, brightness, range)
    local args = {
        [1] = "SyncLighting",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["LightType"] = "PointLight",
                ["Brightness"] = brightness,
                ["Range"] = range,
                ["Color"] = Color3.new(0.35, 0, 0)
            }
        }
    }
    serverendpoint:InvokeServer(unpack(args))
end

for _, v in ipairs(workspace:GetDescendants()) do
    if v:IsA("BasePart") or v:IsA("UnionOperation") then
        task.spawn(function()
            addlight(v)
            synclight(v, 0.2, 35)
        end)
    end
end

descendantConnection = workspace.DescendantAdded:Connect(function(descendant)
    if descendant:IsA("BasePart") or descendant:IsA("UnionOperation") then
        task.wait(0.5) -- Wait a bit for the part to be fully loaded
        task.spawn(function()
            addlight(descendant)
            synclight(descendant, 0.2, 35)
        end)
    end
end)

while task.wait(0.1) do
    if not scriptActive then break end -- Only break if script is disabled
    
    spawn(function()
        if not char or not char.Parent or not char:FindFirstChild("HumanoidRootPart") then
            return
        end
        
        local hrp = char.HumanoidRootPart
        local pos = hrp.CFrame * CFrame.new(0, -3.2, 0)
        local trail = serverendpoint:InvokeServer("CreatePart", "Normal", pos, char)

        setcollision(trail, false)
        syncmaterial(trail, Enum.Material.Granite)
        color(trail, Color3.new(0, 0, 0))
        resize(trail, Vector3.new(10, 0.5, 10), trail.CFrame)
        fire(trail)

        addlight(trail)
        synclight(trail, 5, 20)

        task.wait(1)
        delete(trail)
    end)
end

end)
BT("Canada Spam", function()
local player = game.Players.LocalPlayer
			local char = player.Character
			local tool
			for i,v in player:GetDescendants() do
				if v.Name == "SyncAPI" then
					tool = v.Parent
				end
			end
			for i,v in game.ReplicatedStorage:GetDescendants() do
				if v.Name == "SyncAPI" then
					tool = v.Parent
				end
			end
			remote = tool.SyncAPI.ServerEndpoint
			function _(args)
				remote:InvokeServer(unpack(args))
			end
			function SetCollision(part,boolean)
				local args = {
					[1] = "SyncCollision",
					[2] = {
						[1] = {
							["Part"] = part,
							["CanCollide"] = boolean
						}
					}
				}
				_(args)
			end
			function SetAnchor(boolean,part)
				local args = {
					[1] = "SyncAnchor",
					[2] = {
						[1] = {
							["Part"] = part,
							["Anchored"] = boolean
						}
					}
				}
				_(args)
			end
			function CreatePart(cf,parent)
				local args = {
					[1] = "CreatePart",
					[2] = "Normal",
					[3] = cf,
					[4] = parent
				}
				_(args)
			end
			function DestroyPart(part)
				local args = {
					[1] = "Remove",
					[2] = {
						[1] = part
					}
				}
				_(args)
			end
			function MovePart(part,cf)
				local args = {
					[1] = "SyncMove",
					[2] = {
						[1] = {
							["Part"] = part,
							["CFrame"] = cf
						}
					}
				}
				_(args)
			end
			function Resize(part,size,cf)
				local args = {
					[1] = "SyncResize",
					[2] = {
						[1] = {
							["Part"] = part,
							["CFrame"] = cf,
							["Size"] = size
						}
					}
				}
				_(args)
			end
			function AddMesh(part)
				local args = {
					[1] = "CreateMeshes",
					[2] = {
						[1] = {
							["Part"] = part
						}
					}
				}
				_(args)
			end
	
			function SetMesh(part,meshid)
				local args = {
					[1] = "SyncMesh",
					[2] = {
						[1] = {
							["Part"] = part,
							["MeshId"] = "rbxassetid://"..meshid
						}
					}
				}
				_(args)
			end
			function SetTexture(part, texid)
				local args = {
					[1] = "SyncMesh",
					[2] = {
						[1] = {
							["Part"] = part,
							["TextureId"] = "rbxassetid://"..texid
						}
					}
				}
				_(args)
			end
			function SetName(part, stringg)
				local args = {
					[1] = "SetName",
					[2] = {
						[1] = part
					},
					[3] = stringg
				}
	
				_(args)
			end
			function MeshResize(part,size)
				local args = {
					[1] = "SyncMesh",
					[2] = {
						[1] = {
							["Part"] = part,
							["Scale"] = size
						}
					}
				}
				_(args)
			end
			function Weld(part1, part2,lead)
				local args = {
					[1] = "CreateWelds",
					[2] = {
						[1] = part1,
						[2] = part2
					},
					[3] = lead
				}
				_(args)
	
			end
			function SetLocked(part,boolean)
				local args = {
					[1] = "SetLocked",
					[2] = {
						[1] = part
					},
					[3] = boolean
				}
				_(args)
			end
			function SetTrans(part,int)
				local args = {
					[1] = "SyncMaterial",
					[2] = {
						[1] = {
							["Part"] = part,
							["Transparency"] = int
						}
					}
				}
				_(args)
			end
			function CreateSpotlight(part)
				local args = {
					[1] = "CreateLights",
					[2] = {
						[1] = {
							["Part"] = part,
							["LightType"] = "SpotLight"
						}
					}
				}
				_(args)
			end
			function SyncLighting(part,brightness)
				local args = {
					[1] = "SyncLighting",
					[2] = {
						[1] = {
							["Part"] = part,
							["LightType"] = "SpotLight",
							["Brightness"] = brightness
						}
					}
				}
				_(args)
			end
			function Color(part,color)
				local args = {
					[1] = "SyncColor",
					[2] = {
						[1] = {
							["Part"] = part,
							["Color"] = color --[[Color3]],
							["UnionColoring"] = false
						}
					}
				}
				_(args)
			end
			function SpawnDecal(part,side)
				local args = {
					[1] = "CreateTextures",
					[2] = {
						[1] = {
							["Part"] = part,
							["Face"] = side,
							["TextureType"] = "Decal"
						}
					}
				}
	
				_(args)
			end
			function AddDecal(part,asset,side)
				local args = {
					[1] = "SyncTexture",
					[2] = {
						[1] = {
							["Part"] = part,
							["Face"] = side,
							["TextureType"] = "Decal",
							["Texture"] = "rbxassetid://".. asset
						}
					}
				}
				_(args)
			end
	
			function spam(id)
				for i,v in game.workspace:GetDescendants() do
					if v:IsA("BasePart") then
						spawn(function()
							SetLocked(v,false)
							SpawnDecal(v,Enum.NormalId.Front)
							AddDecal(v,id,Enum.NormalId.Front)
	
							SpawnDecal(v,Enum.NormalId.Back)
							AddDecal(v,id,Enum.NormalId.Back)
	
							SpawnDecal(v,Enum.NormalId.Right)
							AddDecal(v,id,Enum.NormalId.Right)
	
							SpawnDecal(v,Enum.NormalId.Left)
							AddDecal(v,id,Enum.NormalId.Left)
	
							SpawnDecal(v,Enum.NormalId.Bottom)
							AddDecal(v,id,Enum.NormalId.Bottom)
	
							SpawnDecal(v,Enum.NormalId.Top)
							AddDecal(v,id,Enum.NormalId.Top)
						end)
					end
				end 
			end
			spam("6924369153")
end)

BT("Obunga SkyBox", function()
RequestCommandSilent:InvokeServer(";fogcolor black ;time 6")
local player = game.Players.LocalPlayer

    local char = player.Character

    local tool

    for i,v in player:GetDescendants() do

        if v.Name == "SyncAPI" then

            tool = v.Parent

        end

    end

    for i,v in game.ReplicatedStorage:GetDescendants() do

        if v.Name == "SyncAPI" then

            tool = v.Parent

        end

    end


    remote = tool.SyncAPI.ServerEndpoint

    function _(args)

        remote:InvokeServer(unpack(args))

    end

    function SetCollision(part,boolean)

        local args = {

            [1] = "SyncCollision",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["CanCollide"] = boolean

                }

            }

        }

        _(args)

    end

    function SetAnchor(boolean,part)

        local args = {

            [1] = "SyncAnchor",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["Anchored"] = boolean

                }

            }

        }

        _(args)

    end

    function CreatePart(cf,parent)

        local args = {

            [1] = "CreatePart",

            [2] = "Normal",

            [3] = cf,

            [4] = parent

        }

        _(args)

    end

    function DestroyPart(part)

        local args = {

            [1] = "Remove",

            [2] = {

                [1] = part

            }

        }

        _(args)

    end

    function MovePart(part,cf)

        local args = {

            [1] = "SyncMove",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["CFrame"] = cf

                }

            }

        }

        _(args)

    end

    function Resize(part,size,cf)

        local args = {

            [1] = "SyncResize",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["CFrame"] = cf,

                    ["Size"] = size

                }

            }

        }

       _(args)

    end

    function AddMesh(part)

        local args = {

            [1] = "CreateMeshes",

            [2] = {

                [1] = {

                    ["Part"] = part

                }

            }

        }

        _(args)

    end

    function SetMesh(part,meshid)

        local args = {

            [1] = "SyncMesh",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["MeshId"] = "rbxassetid://"..meshid

                }

            }

        }

        _(args)

    end

    function SetTexture(part, texid)

        local args = {

            [1] = "SyncMesh",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["TextureId"] = "rbxassetid://"..texid

                }

            }

        }

        _(args)

    end

    function SetName(part, stringg)

        local args = {

            [1] = "SetName",

            [2] = {

                [1] = part

            },

            [3] = stringg

        }

        _(args)

    end

    function MeshResize(part,size)

        local args = {

            [1] = "SyncMesh",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["Scale"] = size

                }

            }

        }

        _(args)

    end

    function Weld(part1, part2,lead)

        local args = {

            [1] = "CreateWelds",

            [2] = {

                [1] = part1,

                [2] = part2

            },

            [3] = lead

        }

        _(args)

    end

    function SetLocked(part,boolean)

        local args = {

            [1] = "SetLocked",

            [2] = {

                [1] = part

            },

            [3] = boolean

        }

        _(args)

    end

    function SetTrans(part,int)

        local args = {

            [1] = "SyncMaterial",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["Transparency"] = int

                }

            }

        }

        _(args)

    end

    function CreateSpotlight(part)

        local args = {

           [1] = "CreateLights",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["LightType"] = "SpotLight"

                }

            }

        }

        _(args)

    end

    function SyncLighting(part,brightness)

        local args = {

            [1] = "SyncLighting",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["LightType"] = "SpotLight",

                    ["Brightness"] = brightness

                }

            }

        }

        _(args)

    end

    function Color(part,color)

        local args = {

            [1] = "SyncColor",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["Color"] = color --[[Color3]],

                    ["UnionColoring"] = false

                }

            }

        }

        _(args)

    end

    function SpawnDecal(part,side)

        local args = {

            [1] = "CreateTextures",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["Face"] = side,

                    ["TextureType"] = "Decal"

                }

            }

        }

        _(args)

    end

    function AddDecal(part,asset,side)

        local args = {

            [1] = "SyncTexture",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["Face"] = side,

                    ["TextureType"] = "Decal",

                    ["Texture"] = "rbxassetid://".. asset

                }

            }

        }

        _(args)

    end

    function Sky(id)

        e = char.HumanoidRootPart.CFrame.x

        f = char.HumanoidRootPart.CFrame.y

        g = char.HumanoidRootPart.CFrame.z

        CreatePart(CFrame.new(math.floor(e),math.floor(f),math.floor(g)) + Vector3.new(0,6,0),workspace)

        for i,v in game.Workspace:GetDescendants() do

            if v:IsA("BasePart") and v.CFrame.x == math.floor(e) and v.CFrame.z == math.floor(g) then


                SetName(v,"Sky")

                AddMesh(v)



                SetMesh(v,"111891702759441")

                SetTexture(v,id)


                MeshResize(v,Vector3.new(61000,61000,61000))

                SetLocked(v,true)

            end

        end

    end

    Sky("84527322179693")
end)
BT("Dancing Skeleton SkyBox", function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
SilentRequest:InvokeServer(";fogcolor black")
SilentRequest:InvokeServer(";time 6")

local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

for i, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for i, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint
local RunService = game:GetService("RunService")

local function _(args)
    remote:InvokeServer(unpack(args))
end

local function CreatePart(cf, parent)
    local args = { "CreatePart", "Normal", cf, parent }
    _(args)
end

local function SetAnchor(part, boolean)
    local args = {
        "SyncAnchor",
        {
            {
                Part = part,
                Anchored = boolean
            }
        }
    }
    _(args)
end

local function AddMesh(part)
    local args = { "CreateMeshes", { { Part = part } } }
    _(args)
end

local function SetMesh(part, meshid)
    local args = {
        "SyncMesh",
        {
            {
                Part = part,
                MeshId = "rbxassetid://" .. meshid
            }
        }
    }
    _(args)
end

local function SetTexture(part, texid)
    local args = {
        "SyncMesh",
        {
            {
                Part = part,
                TextureId = texid
            }
        }
    }
    _(args)
end

local function MeshResize(part, size)
    local args = {
        "SyncMesh",
        {
            {
                Part = part,
                Scale = size
            }
        }
    }
    _(args)
end

local function SetVertexColor(part, color)
    local args = {
        "SyncMesh",
        {
            {
                Part = part,
                VertexColor = color
            }
        }
    }
    _(args)
end

local function SetTransparency(part, value)
    local args = {
        "SyncTransparency",
        {
            {
                Part = part,
                Transparency = value
            }
        }
    }
    _(args)
end

local function DestroyPart(part)
    local args = { "Remove", { part } }
    _(args)
end

local images = {
    "http://www.roblox.com/asset/?id=169585459",
    "http://www.roblox.com/asset/?id=169585475",
    "http://www.roblox.com/asset/?id=169585485",
    "http://www.roblox.com/asset/?id=169585502",
    "http://www.roblox.com/asset/?id=169585515",
    "http://www.roblox.com/asset/?id=169585502",
    "http://www.roblox.com/asset/?id=169585485",
    "http://www.roblox.com/asset/?id=169585475"
}

local skyPart
local skyLoop
local frameTime = 1/10
local lastUpdate = 0

local function CreateSky()
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local cf = hrp.CFrame
    CreatePart(CFrame.new(cf.Position + Vector3.new(0, 6, 0)), workspace)

    local found = false
    for i = 1, 50 do
        task.wait()
        for _, v in workspace:GetDescendants() do
            if v:IsA("BasePart") and (v.Position - (cf.Position + Vector3.new(0, 6, 0))).Magnitude < 1 then
                skyPart = v
                found = true
                break
            end
        end
        if found then break end
    end

    if not skyPart then return end

    SetAnchor(skyPart, true)
    AddMesh(skyPart)
    SetMesh(skyPart, "111891702759441")
    SetVertexColor(skyPart, Vector3.new(4, 4, 4))
    MeshResize(skyPart, Vector3.new(109888, 109888, 109888))
    SetTransparency(skyPart, 0)

    local index = 1
    skyLoop = RunService.Heartbeat:Connect(function(deltaTime)
        lastUpdate = lastUpdate + deltaTime
        if lastUpdate >= frameTime then
            lastUpdate = 0
            if not skyPart then
                skyLoop:Disconnect()
                return
            end
            SetTexture(skyPart, images[index])
            index = (index % #images) + 1
        end
    end)
end

local function ResetSky()
    if skyLoop then
        skyLoop:Disconnect()
        skyLoop = nil
    end
    if skyPart then
        DestroyPart(skyPart)
        skyPart = nil
    end
    task.spawn(CreateSky)
end

player.CharacterAdded:Connect(function(newChar)
    char = newChar
    ResetSky()
end)

if char and char:FindFirstChild("Humanoid") then
    char.Humanoid.Died:Connect(function()
        ResetSky()
    end)
end

CreateSky()
end)
BT("raining balls", function()
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

local function _(args)
    remote:InvokeServer(unpack(args))
end

function SetCollision(part, bool)
    _({"SyncCollision", {{Part = part, CanCollide = bool}}})
end

function SetAnchor(bool, part)
    _({"SyncAnchor", {{Part = part, Anchored = bool}}})
end

function CreatePart(cf)
    _({"CreatePart", "Ball", cf, workspace})
end

function Resize(part, size, cf)
    _({"SyncResize", {{Part = part, CFrame = cf, Size = size}}})
end

function SetName(part, name)
    _({"SetName", {part}, name})
end

function SetColor(part, color)
    _({"SyncMaterial", {{Part = part, Material = Enum.Material.Neon}}})
    _({"SyncColor", {{Part = part, Color = color}}})
end

local function randomColor3()
    return Color3.fromHSV(math.random(), 1, 1)
end

local root = player.Character:WaitForChild("HumanoidRootPart")

while task.wait(0.1) do
    local x = root.Position.X + math.random(-300, 300)
    local z = root.Position.Z + math.random(-300, 300)
    local y = root.Position.Y + math.random(150, 300)
    local cf = CFrame.new(math.floor(x), y, math.floor(z))

    spawn(function()
        CreatePart(cf)
        task.wait(0.05)
        
        for _, v in workspace:GetChildren() do
            if v:IsA("Part") and v.Name == "Part" and (v.Position - cf.Position).Magnitude < 2 then
                SetName(v, "FallingNeonBall")
                Resize(v, Vector3.new(40, 40, 40), v.CFrame)
                SetColor(v, randomColor3())
                SetCollision(v, true)
                SetAnchor(false, v)
                break
            end
        end
    end)
end

end)
BT("infinite yield", function()
loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()

end)
BT("Old Meme Particles", function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
        break
    end
end
if not tool then
    for _, v in game.ReplicatedStorage:GetDescendants() do
        if v.Name == "SyncAPI" then
            tool = v.Parent
            break
        end
    end
end
if not tool then
    error("SyncAPI tool not found")
end

local remote = tool.SyncAPI.ServerEndpoint

local function _(args)
    remote:InvokeServer(unpack(args))
end

local function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end
local function SetAnchor(part, state)
    _({"SyncAnchor", {{Part = part, Anchored = state}}})
end
local function SetCollision(part, state)
    _({"SyncCollision", {{Part = part, CanCollide = state}}})
end
local function AddMesh(part)
    _({"CreateMeshes", {{Part = part}}})
end
local function SetMesh(part, meshid)
    _({"SyncMesh", {{Part = part, MeshId = "rbxassetid://" .. meshid}}})
end
local function SetTexture(part, texid)
    _({"SyncMesh", {{Part = part, TextureId = "rbxassetid://" .. texid}}})
end
local function MeshResize(part, size)
    _({"SyncMesh", {{Part = part, Scale = size}}})
end
local function SetLocked(part, state)
    _({"SetLocked", {part}, state})
end
local function Resize(part, size, cf)
    _({"SyncResize", {{Part = part, CFrame = cf, Size = size}}})
end
local function SpawnDecal(part, face)
    _({"CreateTextures", {{Part = part, Face = face, TextureType = "Decal"}}})
end
local function AddDecal(part, asset, face)
    _({"SyncTexture", {{Part = part, Face = face, TextureType = "Decal", Texture = "rbxassetid://"..asset}}})
end
local function SetName(part, name)
    _({"SetName", {part}, name})
end
local function SetTrans(part, val)
    _({"SyncMaterial", {{Part = part, Transparency = val}}})
end
local function delete(part)
    _({"Remove", {part}})
end

local activeParticles = {}
local particleCooldowns = {}

local function createParticleForPlayer(targetPlayer, textureId, offsetY)
    local character = targetPlayer.Character
    if not character then
        targetPlayer.CharacterAdded:Wait()
        character = targetPlayer.Character
    end
    
    local humanoid = character:WaitForChild("Humanoid")
    local playerKey = targetPlayer.UserId
    
    local cooldownKey = playerKey .. "_" .. textureId
    particleCooldowns[cooldownKey] = particleCooldowns[cooldownKey] or 0
    
    while true do
        local currentTime = tick()
        if currentTime - particleCooldowns[cooldownKey] >= 2 then
            particleCooldowns[cooldownKey] = currentTime
            
            if not targetPlayer or not targetPlayer.Parent or not character or not character.Parent or humanoid.Health <= 0 then
                break
            end
            
            local head = character:FindFirstChild("Head")
            if not head then
                task.wait(1)
                continue
            end

            local spawnCFrame = head.CFrame + Vector3.new(0, 3 + offsetY, 0)
            
            task.spawn(function()  
                CreatePart(spawnCFrame, workspace)  
                task.wait(0.1)  

                local newPart = nil
                for _, v in workspace:GetChildren() do  
                    if v:IsA("Part") and (v.Position - spawnCFrame.Position).Magnitude < 1 then  
                        newPart = v
                        break
                    end  
                end
                
                if newPart then
                    SetName(newPart, "particle_" .. targetPlayer.Name .. "_" .. textureId)  
                    Resize(newPart, Vector3.new(6, 6, 0.001), newPart.CFrame)  
                    SetCollision(newPart, false)  
                    SetTrans(newPart, 1)  
                    SetAnchor(newPart, true)  
                    newPart.Orientation = Vector3.new(0, 0, 0)  

                    SpawnDecal(newPart, Enum.NormalId.Front)  
                    AddDecal(newPart, textureId, Enum.NormalId.Front)  
                    SpawnDecal(newPart, Enum.NormalId.Back)  
                    AddDecal(newPart, textureId, Enum.NormalId.Back)  

                    local particleId = #activeParticles + 1
                    activeParticles[particleId] = newPart

                    for i = 1, 40 do
                        if newPart and newPart.Parent and head and head.Parent then  
                            local currentHeadPos = head.Position
                            local newPosition = Vector3.new(
                                currentHeadPos.X,
                                spawnCFrame.Position.Y + (i * 2),
                                currentHeadPos.Z
                            )
                            Resize(newPart, newPart.Size, CFrame.new(newPosition))
                            task.wait(0.05)
                        else
                            break
                        end
                    end  

                    if newPart and newPart.Parent then
                        delete(newPart)  
                    end
                    activeParticles[particleId] = nil
                end  
            end)
        end
        task.wait(0.5)
    end
end

local function startParticleSystem()
    local textureIds = {
        "12667521510",
        "12585611688",
        "76658875202103"
    }

    local activeConnections = {}
    
    local function startForPlayer(player)
        for i, texId in ipairs(textureIds) do
            local yOffset = (i-1) * 2  -- stack textures above each other
            coroutine.wrap(function()
                createParticleForPlayer(player, texId, yOffset)
            end)()
        end
    end
    
    local function stopForPlayer(player)
        for particleId, part in pairs(activeParticles) do
            if part.Name:find(player.Name) and part.Parent then
                delete(part)
                activeParticles[particleId] = nil
            end
        end
    end
    
    for _, existingPlayer in ipairs(Players:GetPlayers()) do
        startForPlayer(existingPlayer)
    end
    
    Players.PlayerAdded:Connect(function(newPlayer)
        startForPlayer(newPlayer)
    end)
    
    Players.PlayerRemoving:Connect(function(leavingPlayer)
        stopForPlayer(leavingPlayer)
    end)
end

local function setupCleanup()
    while true do
        task.wait(10)
        for particleId, part in pairs(activeParticles) do
            if not part or not part.Parent then
                activeParticles[particleId] = nil
            end
        end
    end
end

startParticleSystem()
coroutine.wrap(setupCleanup)()
end)
BT("k00pkidd statue", function()
local player = game.Players.LocalPlayer
local char = player.Character
local tool
for i,v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end
for i,v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end
remote = tool.SyncAPI.ServerEndpoint
function _(args)
    remote:InvokeServer(unpack(args))
end
function SetCollision(part,boolean)
    local args = {
        [1] = "SyncCollision",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["CanCollide"] = boolean
            }
        }
    }
    _(args)
end
function SetAnchor(boolean,part)
    local args = {
        [1] = "SyncAnchor",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Anchored"] = boolean
            }
        }
    }
    _(args)
end
function CreatePart(cf,parent)
    local args = {
        [1] = "CreatePart",
        [2] = "Normal",
        [3] = cf,
        [4] = parent
    }
    _(args)
end
function MovePart(part,cf)
    local args = {
        [1] = "SyncMove",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["CFrame"] = cf
            }
        }
    }
    _(args)
end
function Resize(part,size,cf)
    local args = {
        [1] = "SyncResize",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["CFrame"] = cf,
                ["Size"] = size
            }
        }
    }
    _(args)
end
function AddMesh(part)
    local args = {
        [1] = "CreateMeshes",
        [2] = {
            [1] = {
                ["Part"] = part
            }
        }
    }
    _(args)
end

function SetMesh(part,meshid)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["MeshId"] = "rbxassetid://"..meshid
            }
        }
    }
    _(args)
end
function SetTexture(part, texid)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["TextureId"] = "rbxassetid://"..texid
            }
        }
    }
    _(args)
end
function SetName(part, stringg)
    local args = {
        [1] = "SetName",
        [2] = {
            [1] = part
        },
        [3] = stringg
    }
    _(args)
end
function MeshResize(part,size)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Scale"] = size
            }
        }
    }
    _(args)
end
function Weld(part1, part2,lead)
    local args = {
        [1] = "CreateWelds",
        [2] = {
            [1] = part1,
            [2] = part2
        },
        [3] = lead
    }
    _(args)
end
function SetLocked(part,boolean)
    local args = {
        [1] = "SetLocked",
        [2] = {
            [1] = part
        },
        [3] = boolean
    }
    _(args)
end
function SetTrans(part,int)
    local args = {
        [1] = "SyncMaterial",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Transparency"] = int
            }
        }
    }
    _(args)
end
function CreateSpotlight(part)
    local args = {
        [1] = "CreateLights",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["LightType"] = "SpotLight"
            }
        }
    }
    _(args)
end
function SyncLighting(part,brightness)
    local args = {
        [1] = "SyncLighting",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["LightType"] = "SpotLight",
                ["Brightness"] = brightness
            }
        }
    }
    _(args)
end
function Color(part,color)
    local args = {
        [1] = "SyncColor",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Color"] = color --[[Color3]],
                ["UnionColoring"] = false
            }
        }
    }
    _(args)
end
function SpawnDecal(part,side)
    local args = {
        [1] = "CreateTextures",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Face"] = side,
                ["TextureType"] = "Decal"
            }
        }
    }
    _(args)
end
function AddDecal(part,asset,side)
    local args = {
        [1] = "SyncTexture",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Face"] = side,
                ["TextureType"] = "Decal",
                ["Texture"] = "rbxassetid://".. asset
            }
        }
    }
    _(args)
end

function Krab(id)
    e = char.HumanoidRootPart.CFrame.x
    f = char.HumanoidRootPart.CFrame.y
    g = char.HumanoidRootPart.CFrame.z
    CreatePart(CFrame.new(math.floor(e),math.floor(f),math.floor(g)) + Vector3.new(0,7,0),workspace)
    for i,v in game.Workspace:GetDescendants() do
        if v:IsA("BasePart") and v.CFrame.x == math.floor(e) and v.CFrame.z == math.floor(g) then
            SetName(v,"Blue2spookys Krusty Krab")
            AddMesh(v)
            SetMesh(v,"1347582902")
            SetTexture(v,id)
            MeshResize(v,Vector3.new(0.1,0.1,0.1))
            SetLocked(v,true)

            local basePosition = v.Position
            local pos4 = CFrame.new(basePosition) * CFrame.new(0, 5, 0)
            CreatePart(pos4, workspace)

            for i,newPart in game.Workspace:GetDescendants() do
                if newPart:IsA("BasePart") and newPart ~= v and newPart.CFrame.x == pos4.x and newPart.CFrame.z == pos4.z then
                    SetName(newPart, "Krab Head Mesh")
                    AddMesh(newPart)
                    SetMesh(newPart, "5924046624")
                    SetTexture(newPart, "5924037225")
                    MeshResize(newPart, Vector3.new(3, 3, 3)) -- <<< Increased head size
                    SetLocked(newPart, true)
                    MovePart(newPart, newPart.CFrame * CFrame.new(0, 6.25, 0))
                    break
                end
            end
        end
    end
end

Krab("125929634799364")

end)
BT("Random Colors", function()
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local backpack = player:WaitForChild("Backpack")

local function getf3x()
	for _, v in ipairs(backpack:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then
			return v
		end
	end
	for _, v in ipairs(player.Character:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then
			return v
		end
	end
	return nil
end

local f3x = getf3x()
if not f3x then
	warn("You don't have F3X Skid")
	return
end

local syncapi = f3x:WaitForChild("SyncAPI")
local serverendpoint = syncapi:WaitForChild("ServerEndpoint")

local function fastInvoke(args)
	task.spawn(function()
		pcall(function()
			serverendpoint:InvokeServer(unpack(args))
		end)
	end)
end

local function setColor(part, color)
	fastInvoke({
		"SyncColor",
		{
			{
				["Part"] = part,
				["Color"] = color,
				["UnionColoring"] = false
			}
		}
	})
end

local function randomColor()
	return Color3.fromRGB(
		math.random(0, 255),
		math.random(0, 255),
		math.random(0, 255)
	)
end

local parts = workspace:GetDescendants()
local total = 0

for _, v in ipairs(parts) do
	if v:IsA("BasePart") or v:IsA("UnionOperation") then
		total += 1
		setColor(v, randomColor())
	end
end

end)
BT("Make Everything Meshes", function()
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local backpack = player:WaitForChild("Backpack")

local function getf3x()
	for _, v in ipairs(backpack:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then
			return v
		end
	end
	for _, v in ipairs(player.Character:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then
			return v
		end
	end
	return nil
end

local f3x = getf3x()
if not f3x then
	warn("You dont have f3x skid")
	return
end

local syncapi = f3x:WaitForChild("SyncAPI")
local serverendpoint = syncapi:WaitForChild("ServerEndpoint")

local function fastInvoke(args)
	task.spawn(function()
		pcall(function()
			serverendpoint:InvokeServer(unpack(args))
		end)
	end)
end

local meshIds = {
	"rbxassetid://9756362",    -- cone
	"rbxassetid://20329976",   -- sphere-like
	"rbxassetid://19251107",   -- cylinder
	"rbxassetid://10470609",   -- wedge
	"rbxassetid://10470606",   -- head
	"rbxassetid://1095708",    -- pyramid
	"rbxassetid://9753878"     -- random rock
}

local shapes = {
	Enum.PartType.Block,
	Enum.PartType.Ball,
	Enum.PartType.Cylinder,
	Enum.PartType.Wedge,
	Enum.PartType.CornerWedge
}

local function randomMeshId()
	return meshIds[math.random(1, #meshIds)]
end

local function randomShape()
	return shapes[math.random(1, #shapes)]
end

local function convertPart(part)
	task.spawn(function()
		pcall(function()
			if math.random() < 0.5 then
				fastInvoke({
					"SyncShape",
					{
						{
							["Part"] = part,
							["Shape"] = randomShape()
						}
					}
				})
			else
				fastInvoke({"CreateMeshes", {{["Part"] = part}}})
				fastInvoke({
					"SyncMesh",
					{
						{
							["Part"] = part,
							["MeshId"] = randomMeshId(),
							["Scale"] = Vector3.new(
								math.random(50, 200) / 100,
								math.random(50, 200) / 100,
								math.random(50, 200) / 100
							)
						}
					}
				})
			end
		end)
	end)
end

local parts = workspace:GetDescendants()
local total = 0

for _, v in ipairs(parts) do
	if v:IsA("BasePart") or v:IsA("UnionOperation") then
		total += 1
		convertPart(v)
	end
end

end)
BT("Spin all", function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";spin all 20")
end)
BT("Avatars", function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";char all k00pkiddalt")
end)

BT("Brooklyn blood pop song", function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 133251269532695")
SilentRequest:InvokeServer(";pitch 0.143")
SilentRequest:InvokeServer(";volume inf")

end)
BT("Real g00by theme!!", function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 1847661821")
SilentRequest:InvokeServer(";volume inf")

end)
BT("coffee shop", function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
pcall(function()
RequestCommand:InvokeServer(";punish all")
end)

local backpack = player.Backpack
local function getf3x()
for _, v in ipairs(backpack:GetChildren()) do
if v:FindFirstChild("SyncAPI") then return v end
end
for _, v in ipairs(char:GetChildren()) do
if v:FindFirstChild("SyncAPI") then return v end
end
return nil
end

local f3x = getf3x()
if not f3x then
warn("You don't have F3X skid")
return
end
local syncapi = f3x.SyncAPI
local serverendpoint = syncapi.ServerEndpoint

local function fastInvoke(args)
task.spawn(function()
pcall(function()
serverendpoint:InvokeServer(unpack(args))
end)
end)
end

local function delete(part)
fastInvoke({"Remove",{part}})
end

for _, v in ipairs(workspace:GetDescendants()) do
if v:IsA("BasePart") or v:IsA("UnionOperation") then
task.spawn(function()
pcall(function() delete(v) end)
end)
end
end

print("All parts deleted (fast).")
task.wait(0.8)


local function createPart(partType, cf, size, material, col, nameStr, anchored, collide, extra)
task.spawn(function()
local part = serverendpoint:InvokeServer("CreatePart", partType, cf, workspace)
if part then
fastInvoke({"SyncResize",{{["Part"]=part,["CFrame"]=cf,["Size"]=size}}})
fastInvoke({"SyncMaterial",{{["Part"]=part,["Material"]=material}}})
fastInvoke({"SyncColor",{{["Part"]=part,["Color"]=col,["UnionColoring"]=false}}})
fastInvoke({"SetName",{part}, nameStr})
fastInvoke({"SetLocked",{part}, true})
fastInvoke({"SyncAnchor",{{["Part"]=part,["Anchored"]=anchored}}})
fastInvoke({"SyncCollision",{{["Part"]=part,["CanCollide"]=collide}}})
if extra then extra(part) end
end
end)
end

local function resize(part, size, cf)
fastInvoke({"SyncResize",{{["Part"]=part,["CFrame"]=cf,["Size"]=size}}})
end

local function mat(part, mate)
fastInvoke({"SyncMaterial",{{["Part"]=part,["Material"]=mate}}})
end

local function color(part, col)
fastInvoke({"SyncColor",{{["Part"]=part,["Color"]=col,["UnionColoring"]=false}}})
end

local function transparency(part, trans)
fastInvoke({"SyncMaterial",{{["Part"]=part,["Transparency"]=trans}}})
end

local function setcollision(part, bool)
fastInvoke({"SyncCollision",{{["Part"]=part,["CanCollide"]=bool}}})
end

local function setanchor(part, bool)
fastInvoke({"SyncAnchor",{{["Part"]=part,["Anchored"]=bool}}})
end

local function createtexture(part, side)
fastInvoke({"CreateTextures",{{["Part"]=part,["Face"]=side,["TextureType"]="Texture"}}})
end

local function createdecal(part, side)
fastInvoke({"CreateTextures",{{["Part"]=part,["Face"]=side,["TextureType"]="Decal"}}})
end

local function setdecal(part, asset, side)
fastInvoke({"SyncTexture",{{["Part"]=part,["Face"]=side,["TextureType"]="Decal",["Texture"]="rbxassetid://"..asset}}})
end

local function makemesh(part)
fastInvoke({"CreateMeshes",{{["Part"]=part}}})
end

local function syncmeshid(part, id)
fastInvoke({"SyncMesh",{{["Part"]=part,["MeshId"]="rbxassetid://"..id}}})
end

local function syncmeshsize(part, vectora)
fastInvoke({"SyncMesh",{{["Part"]=part,["Scale"]=vectora}}})
end

local function syncmeshtexture(part, id)
fastInvoke({"SyncMesh",{{["Part"]=part,["TextureId"]="rbxassetid://"..id}}})
end

function MovePart(part, cf)
fastInvoke({"SyncMove",{{["Part"]=part,["CFrame"]=cf}}})
end

function floor(part, face)  
	fastInvoke({  
		[1] = "SyncTexture",  
		[2] = {  
			[1] = {  
				["Part"] = part,  
				["Face"] = face,  
				["TextureType"] = "Texture",  
				["Texture"] = "rbxassetid://135172958780980",  
				["StudsPerTileV"] = 2,  
				["StudsPerTileU"] = 2  
			}  
		}  
	})  
end  

function getwooded(part, face)  
	fastInvoke({  
		[1] = "SyncTexture",  
		[2] = {  
			[1] = {  
				["Part"] = part,  
				["Face"] = face,  
				["TextureType"] = "Texture",  
				["Texture"] = "rbxassetid://94153618",  
				["StudsPerTileV"] = 10,  
				["StudsPerTileU"] = 10  
			}  
		}  
	})  
end

function getFlooredLMFAO(part, face)
fastInvoke({
[1] = "SyncTexture",
[2] = {
[1] = {
["Part"] = part,
["Face"] = face,
["TextureType"] = "Texture",
["Texture"] = "rbxassetid://55420352",
["StudsPerTileV"] = 10,
["StudsPerTileU"] = 10
}
}
})
end

local function light(part)
fastInvoke({"CreateLights",{{["Part"]=part,["LightType"]="PointLight"}}})
fastInvoke({"SyncLighting",{{["Part"]=part,["LightType"]="PointLight",["Color"]=Color3.fromRGB(255,255,255),["Range"]=50}}})
end

local function RealmV2()
local parts = {
{CFrame.new(-47.979, 0, -26.237), Vector3.new(63, 1, 66), Enum.Material.SmoothPlastic, Color3.fromRGB(230, 230, 230), "Floor", function(p) 
	createtexture(p, Enum.NormalId.Top)
	getFlooredLMFAO(p, Enum.NormalId.Top)
end},

{CFrame.new(-67.979, 2.25, -34.687), Vector3.new(23, 5.5, 1.1), Enum.Material.WoodPlanks, Color3.fromRGB(10, 10, 10), "Wall1"},
{CFrame.new(-67.979, 9, -34.737), Vector3.new(23, 19, 1), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "Wall2"},
{CFrame.new(-67.979, 9, -46.437), Vector3.new(23, 19, 24.4), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "Wall3"},
{CFrame.new(-47.979, 9, -58.737), Vector3.new(63, 19, 1), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "Wall4", function(p)
	createtexture(p, Enum.NormalId.Back)
	getwooded(p, Enum.NormalId.Back)
end},
{CFrame.new(-15.979, 9, -26.237), Vector3.new(1, 19, 66), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "Wall5", function(p)
	createtexture(p, Enum.NormalId.Left)
	getwooded(p, Enum.NormalId.Left)
end},
{CFrame.new(-79.979, 9, -26.237), Vector3.new(1, 19, 66), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "Wall6", function(p)
	createtexture(p, Enum.NormalId.Right)
	getwooded(p, Enum.NormalId.Right)
end},
{CFrame.new(-20.979, 15, 6.263), Vector3.new(11, 7, 1), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "Wall7"},
{CFrame.new(-25.479, 9, 6.263), Vector3.new(2, 19, 1), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "Wall8"},
{CFrame.new(-52.479, 1.5, 6.263), Vector3.new(56, 4, 1), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "Wall9", function(p)
	createtexture(p, Enum.NormalId.Front)
	getwooded(p, Enum.NormalId.Front)
end},
{CFrame.new(-49.979, 8.5, 6.613), Vector3.new(47, 10, 0.1), Enum.Material.Glass, Color3.fromRGB(52, 216, 235), "GlassWall", function(p)
	transparency(p, 0.7)
end},
{CFrame.new(-76.479, 9, 6.263), Vector3.new(6, 19, 1), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "Wall10"},
{CFrame.new(-47.979, 19, -26.237), Vector3.new(63, 1, 66), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "Ceiling", function(p)
	light(p)
end},
{CFrame.new(-20.479, 6.05, 6.263), Vector3.new(8, 10.9, 1), Enum.Material.Glass, Color3.fromRGB(52, 216, 235), "GlassWall2", function(p)
	transparency(p, 0.7)
	setcollision(p, false)
end},

{CFrame.new(-25.28, 1.4, -34.805), Vector3.new(15.7, 4.2, 2), Enum.Material.SmoothPlastic, Color3.fromRGB(0, 0, 0), "Struct1"},
{CFrame.new(-49.78, 1.75, -34.805), Vector3.new(13.5, 3.5, 2), Enum.Material.SmoothPlastic, Color3.new(1, 1, 1), "Struct2"},
{CFrame.new(-38.13, 3.1, -35.755), Vector3.new(10, 6.2, 0.1), Enum.Material.SmoothPlastic, Color3.new(1, 1, 1), "Struct3"},
{CFrame.new(-38.13, 5.15, -34.805), Vector3.new(10, 0.3, 2), Enum.Material.SmoothPlastic, Color3.new(1, 1, 1), "Struct4"},
{CFrame.new(-38.13, 3.15, -34.805), Vector3.new(10, 0.3, 2), Enum.Material.SmoothPlastic, Color3.new(1, 1, 1), "Struct5"},
{CFrame.new(-38.13, 0.75, -34.805), Vector3.new(10, 1.5, 2), Enum.Material.SmoothPlastic, Color3.new(1, 1, 1), "Struct6"},

{CFrame.new(-49.479, 9, 6.263), Vector3.new(10, 19, 1), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "Wall11", function(p)
	createtexture(p, Enum.NormalId.Front)
	getwooded(p, Enum.NormalId.Front)
end},
{CFrame.new(-51.479, 8, 6.263), Vector3.new(50, 1, 1), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "Wall12", function(p)
	createtexture(p, Enum.NormalId.Front)
	getwooded(p, Enum.NormalId.Front)
end},
{CFrame.new(-62.979, 9, 6.263), Vector3.new(1, 19, 1), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "Wall13", function(p)
	createtexture(p, Enum.NormalId.Front)
	getwooded(p, Enum.NormalId.Front)
end},
{CFrame.new(-49.979, 16, 6.263), Vector3.new(51, 5, 1), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "Wall14", function(p)
	createtexture(p, Enum.NormalId.Front)
	getwooded(p, Enum.NormalId.Front)
end},
{CFrame.new(-53.479, 13.5, 10.129), Vector3.new(54, 1, 9), Enum.Material.SmoothPlastic, Color3.fromRGB(5, 5, 5), "Platform"},

{CFrame.new(-76.429, 16.393, 8.886), Vector3.new(0.1, 7.4, 0.1), Enum.Material.SmoothPlastic, Color3.new(1, 1, 1), "Angled1", function(p)
	MovePart(p, p.CFrame * CFrame.Angles(math.rad(-44.998), 0, 0))
end},
{CFrame.new(-57.329, 16.393, 8.886), Vector3.new(0.1, 7.4, 0.1), Enum.Material.SmoothPlastic, Color3.new(1, 1, 1), "Angled2", function(p)
	MovePart(p, p.CFrame * CFrame.Angles(math.rad(-44.998), 0, 0))
end},
{CFrame.new(-37.829, 16.393, 8.886), Vector3.new(0.1, 7.4, 0.1), Enum.Material.SmoothPlastic, Color3.new(1, 1, 1), "Angled3", function(p)
	MovePart(p, p.CFrame * CFrame.Angles(math.rad(-44.998), 0, 0))
end},

{CFrame.new(-25.479, 11, 7.763), Vector3.new(2, 23, 4), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "DoorFrame1"},
{CFrame.new(-16.479, 11, 7.763), Vector3.new(2, 23, 4), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "DoorFrame2"},
{CFrame.new(-20.979, 17, 7.763), Vector3.new(11, 11, 4), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "DoorFrameTop"},

{CFrame.new(-50.369, -0.436, -27.163), Vector3.new(84.7, 0.8, 95.4), Enum.Material.Concrete, Color3.fromRGB(100, 100, 100), "Foundation1"},
{CFrame.new(-41.816, -0.836, -9.237), Vector3.new(504, 1, 474), Enum.Material.SmoothPlastic, Color3.fromRGB(200, 200, 200), "Foundation2", function(p)
	createtexture(p, Enum.NormalId.Top)
	floor(p, Enum.NormalId.Top)
end}
}

for _, partData in ipairs(parts) do
createPart("Normal", partData[1], partData[2], partData[3], partData[4], partData[5], true, true, partData[6])
end

task.wait(0.5)

local doorPositions = {
CFrame.new(-30.818, 2.5, 0.635),
CFrame.new(-45.818, 2.5, 0.635),
CFrame.new(-61.818, 2.5, 0.635)
}

for _, pos in ipairs(doorPositions) do
task.spawn(function()
local door = serverendpoint:InvokeServer("CreatePart", "Normal", pos, workspace)
if door then
makemesh(door)
syncmeshid(door, "108885615243219")
color(door, Color3.fromRGB(10, 10, 10))
MovePart(door, door.CFrame * CFrame.Angles(0, math.rad(90), 0))
fastInvoke({"SetName",{door}, "Door"})
fastInvoke({"SetLocked",{door}, true})
fastInvoke({"SyncAnchor",{{["Part"]=door,["Anchored"]=true}}})
end
end)
end

task.spawn(function()
local Koohat = CFrame.new(-27.064, 10.6, -37.637)
local hat1 = serverendpoint:InvokeServer("CreatePart", "Normal", Koohat, workspace)
if hat1 then
makemesh(hat1)
syncmeshid(hat1, "5924046624")
syncmeshtexture(hat1, "5924037225")
syncmeshsize(hat1, Vector3.new(1.5, 1.5, 1.5))
fastInvoke({"SetLocked",{hat1}, true})
fastInvoke({"SyncAnchor",{{["Part"]=hat1,["Anchored"]=true}}})
end
end)

task.spawn(function()
local koopPos = CFrame.new(-26.896, 5, -37.605)
local K00pkid = serverendpoint:InvokeServer("CreatePart", "Normal", koopPos, workspace)
if K00pkid then
resize(K00pkid, Vector3.new(8, 10, 2), koopPos)
makemesh(K00pkid)
syncmeshid(K00pkid, "7879233630")
syncmeshtexture(K00pkid, "125929634799364")
syncmeshsize(K00pkid, Vector3.new(2, 2, 2))
MovePart(K00pkid, K00pkid.CFrame * CFrame.Angles(0, math.rad(-179.997), 0))
fastInvoke({"SetLocked",{K00pkid}, true})
fastInvoke({"SyncAnchor",{{["Part"]=K00pkid,["Anchored"]=true}}})
end
end)

task.spawn(function()
local pos7 = CFrame.new(-0.703, 6.164, 7.43)
local text2 = serverendpoint:InvokeServer("CreatePart", "Normal", pos7, workspace)
if text2 then
setcollision(text2, false)
resize(text2, Vector3.new(29, 14, 1), pos7)
transparency(text2, 1)
createdecal(text2, Enum.NormalId.Back)
setdecal(text2, "83540930154917", Enum.NormalId.Back)
end
end)

task.spawn(function()
local pos7 = CFrame.new(-43.816, -0.836, 54.263)
local text2 = serverendpoint:InvokeServer("CreatePart", "Spawn", pos7, workspace)
if text2 then
setcollision(text2, false)
resize(text2, Vector3.new(1, 1, 1), pos7)
transparency(text2, 1)
end
end)

task.spawn(function()
local Koohat = CFrame.new(-21.579, 4.744, -35.271)
local hat1 = serverendpoint:InvokeServer("CreatePart", "Normal", Koohat, workspace)
if hat1 then
makemesh(hat1)
syncmeshid(hat1, "10970208924")
syncmeshsize(hat1, Vector3.new(0.005, 0.005, 0.005))
syncmeshtexture(hat1, "10970209066")
fastInvoke({"SetLocked",{hat1}, true})
fastInvoke({"SyncAnchor",{{["Part"]=hat1,["Anchored"]=true}}})
end
end)

task.spawn(function()
local position = CFrame.new(-26.944, 13.05, -37.165)
local base = serverendpoint:InvokeServer("CreatePart", "Normal", position, workspace)
if base then
resize(base, Vector3.new(16.5, 14.1, 0.1), position)
transparency(base, 1)
setcollision(base, false)
createdecal(base, Enum.NormalId.Back)
setdecal(base, "88544851923301", Enum.NormalId.Back)
end
end)

task.spawn(function()
local Koohat = CFrame.new(-27.063, 8.828, -37.605)
local hat1 = serverendpoint:InvokeServer("CreatePart", "Normal", Koohat, workspace)
if hat1 then
makemesh(hat1)
syncmeshid(hat1, "5560742556")
syncmeshsize(hat1, Vector3.new(2, 2, 2))
color(hat1, Color3.fromRGB(35, 177, 77))
MovePart(hat1, hat1.CFrame * CFrame.Angles(0, math.rad(180), 0))
createdecal(hat1, Enum.NormalId.Back)
setdecal(hat1, "25321744", Enum.NormalId.Back)
fastInvoke({"SetLocked",{hat1}, true})
fastInvoke({"SyncAnchor",{{["Part"]=hat1,["Anchored"]=true}}})
end
end)

end

local function realm()
RealmV2()

task.wait(2)

local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";fogcolor black ;time 0")
        
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

local tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)
    remote:InvokeServer(unpack(args))
end

function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end

function SetAnchor(part, state)
    _({"SyncAnchor", {{["Part"] = part, ["Anchored"] = state}}})
end

function AddMesh(part)
    _({"CreateMeshes", {{["Part"] = part}}})
end

function SetMesh(part, meshid)
    _({"SyncMesh", {{["Part"] = part, ["MeshId"] = "rbxassetid://" .. meshid}}})
end

function SetTexture(part, texid)
    _({"SyncMesh", {{["Part"] = part, ["TextureId"] = "rbxassetid://" .. texid}}})
end

function MeshResize(part, size)
    _({"SyncMesh", {{["Part"] = part, ["Scale"] = size}}})
end

function SetVertexColor(part, color)
    _({"SyncMesh", {{["Part"] = part, ["VertexColor"] = color}}})
end

function Sky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = hrp.CFrame
    
    CreatePart(CFrame.new(cf.Position + Vector3.new(0, 6, 0)), workspace)
    
    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") and v.Position == cf.Position + Vector3.new(0, 6, 0) then
            SetAnchor(v, true)
            AddMesh(v)
            SetMesh(v, "111891702759441")
            SetTexture(v, id)
            SetVertexColor(v, Vector3.new(5, 5, 5))
            MeshResize(v, Vector3.new(109888, 109888, 109888))
        end
    end
end
Sky("9820931824")

end

realm()

task.wait(3)
pcall(function()
RequestCommand:InvokeServer(";time 0 ;fogcolor black ;music 1846575559")
wait(1.5)
end)
RequestCommand:InvokeServer(";res all")
RequestCommand:InvokeServer(";volume 5")
end)
BT("OnlyOneTime Mosque", function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local backpack = player:WaitForChild("Backpack")
pcall(function()
	local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
	RequestCommand:InvokeServer(";btools me")
	wait(0.4)
	RequestCommand:InvokeServer(";punish all")
end)
local function getf3x()
	for _, v in ipairs(backpack:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then
			return v
		end
	end
	for _, v in ipairs(char:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then
			return v
		end
	end
end

local f3x = getf3x()
if not f3x then
	warn("you dont have f3x skid")
	return
end

local endpoint = f3x.SyncAPI.ServerEndpoint
local function fastInvoke(args)
	task.spawn(function()
		pcall(function()
			endpoint:InvokeServer(unpack(args))
		end)
	end)
end
for _, v in ipairs(workspace:GetDescendants()) do
	if v:IsA("BasePart") or v:IsA("UnionOperation") then
		fastInvoke({"Remove", {v}})
	end
end
task.wait(1)
local function resize(part, size, cf)
	fastInvoke({"SyncResize", {{Part = part, CFrame = cf, Size = size}}})
end

local function material(part, mat)
	fastInvoke({"SyncMaterial", {{Part = part, Material = mat}}})
end

local function color(part, col)
	fastInvoke({"SyncColor", {{Part = part, Color = col, UnionColoring = false}}})
end

local function transparency(part, t)
	fastInvoke({"SyncMaterial", {{Part = part, Transparency = t}}})
end

local function mesh(part, id, texture, scale)
	fastInvoke({"CreateMeshes", {{Part = part}}})
	if id then fastInvoke({"SyncMesh", {{Part = part, MeshId = "rbxassetid://" .. id}}}) end
	if texture then fastInvoke({"SyncMesh", {{Part = part, TextureId = "rbxassetid://" .. texture}}}) end
	if scale then fastInvoke({"SyncMesh", {{Part = part, Scale = scale}}}) end
end

local function light(part)
	fastInvoke({"CreateLights", {{Part = part, LightType = "PointLight"}}})
	fastInvoke({"SyncLighting", {{Part = part, LightType = "PointLight", Color = Color3.fromRGB(255,255,255), Brightness = 3, Range = 60}}})
end

local function light2(part)
	fastInvoke({"CreateLights", {{Part = part, LightType = "PointLight"}}})
	fastInvoke({"SyncLighting", {{Part = part, LightType = "PointLight", Color = Color3.fromRGB(255,255,255), Range = 60}}})
end

local function decal(part, face, id)
	fastInvoke({"CreateTextures", {{Part = part, Face = face, TextureType = "Decal"}}})
	fastInvoke({"SyncTexture", {{Part = part, Face = face, TextureType = "Decal", Texture = "rbxassetid://" .. id}}})
end

local function texture(part, face, id, studsU, studsV)
	local args = {
		"SyncTexture",
		{{
			Part = part,
			Face = face,
			TextureType = "Texture",
			Texture = "rbxassetid://" .. id,
			StudsPerTileU = studsU or 1,
			StudsPerTileV = studsV or 1
		}}
	}
	fastInvoke(args)
end

local function movePart(part, cf)
	fastInvoke({"SyncMove", {{Part = part, CFrame = cf}}})
end

local function setLock(part, locked)
	fastInvoke({"SetLocked", {part}, locked})
end

local function setCollision(part, collide)
	fastInvoke({"SyncCollision", {{Part = part, CanCollide = collide}}})
end

local function setAnchor(part, anchored)
	fastInvoke({"SyncAnchor", {{Part = part, Anchored = anchored}}})
end

local function powerYourBalls(part)
	fastInvoke({"CreateDecorations", {{Part = part, DecorationType = "Fire"}}})
	fastInvoke({"SyncDecorate", {{
		Part = part,
		DecorationType = "Fire",
		Size = 10,
		Heat = 25,
		Color = Color3.fromRGB(51, 51, 255),
		SecondaryColor = Color3.fromRGB(255, 0, 0)
	}}})
end
local function quickPart(type, cf, size, mat, col, trans, meshId, meshTex, meshScale, extra)
	task.spawn(function()
		local part = endpoint:InvokeServer("CreatePart", type, cf, workspace.Terrain)
		if part then
			resize(part, size, cf)
			if mat then material(part, mat) end
			if col then color(part, col) end
			if trans then transparency(part, trans) end
			if meshId or meshTex or meshScale then mesh(part, meshId, meshTex, meshScale) end
			if extra then extra(part) end
		end
		return part
	end)
end
local function buildMosque()
	-- Floor
	local cf2 = CFrame.new(-23.874, 49, 11.852)
	quickPart("Normal", cf2, Vector3.new(130, 1, 89), Enum.Material.Concrete)
	local wall2 = quickPart("Normal", CFrame.new(-24.599, 24.5, -32.58), Vector3.new(138, 49, 2), Enum.Material.Concrete, nil, nil, nil, nil, nil, function(p)
		setLock(p, true)
	end)
	
	local wall1 = quickPart("Normal", CFrame.new(-24.599, 24.5, 55.42), Vector3.new(138, 49, 2), Enum.Material.Concrete, nil, nil, nil, nil, nil, function(p)
		setLock(p, true)
	end)
	local rules = quickPart("Normal", CFrame.new(-23.874, 0, 11.852), Vector3.new(130, 1, 89), Enum.Material.Carpet, Color3.fromRGB(255, 0, 0), nil, nil, nil, nil, function(p)
		fastInvoke({"CreateTextures", {{Part = p, Face = Enum.NormalId.Top, TextureType = "Texture"}}})
		texture(p, Enum.NormalId.Top, "124151427651571", 15, 15)
	end)
	local wall3 = quickPart("Normal", CFrame.new(38.901, 24.5, 11.92), Vector3.new(1, 49, 91), Enum.Material.Concrete)
	local wall4 = quickPart("Normal", CFrame.new(-89.099, 24.5, 11.92), Vector3.new(1, 49, 91), Enum.Material.Concrete)
	local StatueStand = quickPart("Normal", CFrame.new(-76.971, 2.5, 8.748), Vector3.new(13, 5, 16), nil, Color3.fromRGB(56, 56, 56), nil, "14103096952", nil, Vector3.new(10, 10, 10))
	local Only = quickPart("Normal", CFrame.new(-77.241, 12, 8.652), Vector3.new(12, 16, 4), nil, nil, nil, "74312427006016", "81858311576221", Vector3.new(3, 3, 3), function(p)
		movePart(p, p.CFrame * CFrame.Angles(0, math.rad(-90), 0))
	end)
	local islaThingy = quickPart("Normal", CFrame.new(-88.764, 28.4, 8.967), Vector3.new(1, 15, 15), nil, Color3.fromRGB(181, 165, 40), nil, "109062984999424", nil, nil, function(p)
		movePart(p, p.CFrame * CFrame.Angles(0, math.rad(-90), 0))
	end)
	local K00pkid = quickPart("Normal", CFrame.new(2.625, 3, 50.54), Vector3.new(4, 5, 2), nil, nil, nil, "102738449791511", "138187799112356", nil, function(p)
		movePart(p, p.CFrame * CFrame.Angles(0, math.rad(-90), 0))
	end)
	local textrekt = quickPart("Normal", CFrame.new(-50.999, 13.6, 53.92), Vector3.new(32.2, 17, 1), nil, nil, 1, nil, nil, nil, function(p)
		decal(p, Enum.NormalId.Front, "122962728398260")
	end)
	
	local skele = quickPart("Normal", CFrame.new(-0.999, 20.6, 53.92), Vector3.new(48.2, 31, 1), nil, nil, nil, nil, nil, nil, function(p)
		decal(p, Enum.NormalId.Front, "12766927785")
	end)
	
	local text1 = quickPart("Normal", CFrame.new(37.073, 12.4, 51.473), Vector3.new(5.1, 7, 6.9), nil, nil, 1, nil, nil, nil, function(p)
		decal(p, Enum.NormalId.Left, "119603015180003")
	end)
	local PC = quickPart("Normal", CFrame.new(35.425, 5.5, 40.95), Vector3.new(1, 1, 1), nil, nil, nil, "8657366243", "82138087829769", Vector3.new(2, 2, 2), function(p)
		movePart(p, p.CFrame * CFrame.Angles(0, math.rad(90), 0))
	end)
	local Plank1 = quickPart("Normal", CFrame.new(33.156, 3, 49.646), Vector3.new(0.5, 6, 0.5), Enum.Material.WoodPlanks, Color3.fromRGB(99, 59, 5))
	local Plank2 = quickPart("Normal", CFrame.new(32.906, 6.25, 49.896), Vector3.new(1, 3.5, 6), Enum.Material.WoodPlanks, Color3.fromRGB(99, 59, 5))
	local tablePart = quickPart("Normal", CFrame.new(35.884, 2, 42.073), Vector3.new(4, 4, 8), Enum.Material.WoodPlanks, Color3.fromRGB(99, 59, 5))
	
	local text2 = quickPart("Normal", CFrame.new(32.384, 6.7, 50.268), Vector3.new(0.5, 8, 12.5), nil, nil, 1, nil, nil, nil, function(p)
		setCollision(p, false)
		decal(p, Enum.NormalId.Left, "73038332719588")
	end)
	local door = quickPart("Normal", CFrame.new(37.196, 6.5, 12.417), Vector3.new(1, 1, 1), nil, Color3.fromRGB(99, 59, 5), nil, "10857433732")
	local wall7 = quickPart("Normal", CFrame.new(3.168, 1.35, 46.557), Vector3.new(16.2, 2.7, 0.8), nil, Color3.fromRGB(0, 255, 0))
	local wall8 = quickPart("Normal", CFrame.new(10.968, 1.35, 50.407), Vector3.new(0.6, 2.7, 7.1), nil, Color3.fromRGB(255, 0, 0))
	local wall9 = quickPart("Normal", CFrame.new(-4.382, 1.35, 50.607), Vector3.new(0.6, 2.7, 7.1), nil, Color3.fromRGB(0, 0, 255))
	local bubblechat = quickPart("Normal", CFrame.new(2.795, 8, 50.413), Vector3.new(11.4, 8, 0.1), nil, nil, 1, nil, nil, nil, function(p)
		setCollision(p, false)
		decal(p, Enum.NormalId.Front, "102002754753325")
	end)
	local islaThingy2 = quickPart("Normal", CFrame.new(-80.264, 3.4, 40.467), Vector3.new(1, 1, 1), nil, Color3.fromRGB(181, 165, 40), nil, "109062984999424", nil, Vector3.new(0.3, 0.3, 0.3), function(p)
		movePart(p, p.CFrame * CFrame.Angles(0, math.rad(-90), 0))
	end)
	local idk = quickPart("Normal", CFrame.new(-80.285, 18.5, -16.084), Vector3.new(1, 1, 1), nil, nil, nil, "112516303122108", "139786158359857", nil, function(p)
		movePart(p, p.CFrame * CFrame.Angles(0, math.rad(-90), 0))
	end)
	local spawner = quickPart("Spawn", CFrame.new(20.371, -0.1, 12.897), Vector3.new(1, 1, 1))
	local stairs = quickPart("Normal", CFrame.new(-78.191, 4.164, -15.858), Vector3.new(12, 1, 4), nil, nil, 1, nil, nil, nil, function(p)
		movePart(p, p.CFrame * CFrame.Angles(0, 0, math.rad(-45)))
	end)
	local BallsPit = quickPart("Normal", CFrame.new(4.095, 1.5, 53.781), Vector3.new(1, 1, 1), nil, nil, nil, "8200798154", "127138541855595", Vector3.new(0.34, 0.3, 0.3))
	local loader = quickPart("Normal", CFrame.new(-32.145, 20.55, -31.554), Vector3.new(68.2, 41.1, 1), nil, nil, 1, nil, nil, nil, function(p)
		decal(p, Enum.NormalId.Back, "12755371369")
	end)
	local Plank3 = quickPart("Normal", CFrame.new(-80.942, 2.7, 40.11), Vector3.new(0.8, 5.4, 7.4), Enum.Material.WoodPlanks, Color3.fromRGB(99, 59, 5))
	local Plank4 = quickPart("Normal", CFrame.new(-84.842, 1.6, 40.11), Vector3.new(8.6, 3.2, 7.4), Enum.Material.WoodPlanks, Color3.fromRGB(99, 59, 5))
	local Plank5 = quickPart("Normal", CFrame.new(84.842, 1.2, 39.56), Vector3.new(8.6, 2.4, 8.5), Enum.Material.WoodPlanks, Color3.fromRGB(99, 59, 5))
	local Plank6 = quickPart("Normal", CFrame.new(-84.842, 0.85, 39.11), Vector3.new(8.6, 1.7, 9.4), Enum.Material.WoodPlanks, Color3.fromRGB(99, 59, 5))
	local Plank7 = quickPart("Normal", CFrame.new(-84.842, 0.6, 38.66), Vector3.new(8.6, 1.2, 10.3), Enum.Material.WoodPlanks, Color3.fromRGB(99, 59, 5))
	local Plank8 = quickPart("Normal", CFrame.new(-85.142, 2.7, 43.76), Vector3.new(9.2, 5.4, 0.1), Enum.Material.WoodPlanks, Color3.fromRGB(99, 59, 5))
	local power = quickPart("Ball", CFrame.new(-77.182, 19, -0.77), Vector3.new(8, 5.2, 6), Enum.Material.ForceField, Color3.fromRGB(209, 5, 255), nil, nil, nil, nil, powerYourBalls)
	local Player19 = quickPart("Normal", CFrame.new(-84.042, 5.218, 40.353), Vector3.new(1, 1, 1), nil, nil, nil, "7879233630", "113929343766399", nil, function(p)
		movePart(p, p.CFrame * CFrame.Angles(0, math.rad(-90), 0))
	end)
	local bub = quickPart("Normal", CFrame.new(-83.786, 9, 40.369), Vector3.new(0.1, 9.6, 10.3), nil, nil, 1, nil, nil, nil, function(p)
		decal(p, Enum.NormalId.Right, "110299358003859")
		movePart(p, p.CFrame * CFrame.Angles(0, math.rad(15), 0))
	end)
	local OnlyMyBro = quickPart("Normal", CFrame.new(-84.57, 12.5, -15.936), Vector3.new(4, 6, 2), nil, nil, nil, "107809273608355", "107477207690813", nil, function(p)
		movePart(p, p.CFrame * CFrame.Angles(0, math.rad(-90), 0))
	end)
	local pillar1 = quickPart("Normal", CFrame.new(-88.386, 27, -30.549), Vector3.new(14, 54, 13), Enum.Material.Concrete, nil, nil, nil, nil, nil, function(p)
		setLock(p, true)
		light2(p)
	end)
	
	local pillar2 = quickPart("Normal", CFrame.new(-91.386, 27, 54.451), Vector3.new(14, 54, 13), Enum.Material.Concrete, nil, nil, nil, nil, nil, function(p)
		setLock(p, true)
		light2(p)
	end)
	
	local pillar3 = quickPart("Normal", CFrame.new(37.614, 27, -30.549), Vector3.new(14, 54, 13), Enum.Material.Concrete, nil, nil, nil, nil, nil, function(p)
		setLock(p, true)
		light2(p)
	end)
	
	local pillar4 = quickPart("Normal", CFrame.new(41.614, 27, 54.451), Vector3.new(14, 54, 13), Enum.Material.Concrete, nil, nil, nil, nil, nil, function(p)
		setLock(p, true)
		light2(p)
	end)
	local windowPositions = {
		CFrame.new(37.756, 29.106, 43.241),
		CFrame.new(37.756, 28.706, -5.959),
		CFrame.new(37.756, 29.106, -18.959),
		CFrame.new(37.756, 12.706, 43.741),
		CFrame.new(37.756, 12.706, 30.841),
		CFrame.new(37.756, 12.706, -5.959),
		CFrame.new(37.756, 12.706, -19.259),
		CFrame.new(37.756, 28.706, 30.841)
	}
	
	for _, pos in ipairs(windowPositions) do
		quickPart("Normal", pos, Vector3.new(1, 1, 1), nil, Color3.fromRGB(255, 255, 255), nil, "2300405926", nil, Vector3.new(2, 2, 2), function(p)
			movePart(p, p.CFrame * CFrame.Angles(0, math.rad(90), 0))
		end)
	end
end

buildMosque()

task.wait(2)
pcall(function()
	local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
	RequestCommand:InvokeServer(";music 6038063555 ;volume inf")
RequestCommand:InvokeServer(";res all")
end)

print("mosque build.")
	
end)
BT("coffee shop 2", function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
local player = game.Players.LocalPlayer
local char = player.Character
local backpack = player.Backpack

local function getf3x()
	for _, v in ipairs(backpack:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then
			return v
		end
	end
	for _, v in ipairs(char:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then
			return v
		end
	end
	return nil
end

local f3x = getf3x()
if not f3x then
	warn("you dont have f3x skid")
end
local syncapi = f3x.SyncAPI
local serverendpoint = syncapi.ServerEndpoint

local function _(args)
serverendpoint:InvokeServer(unpack(args))
end

local function createtexture(part, side)
	local args = {
		"CreateTextures",
		{
			{
				Part = part,
				Face = side,
				TextureType = "Texture"
			}
		}
	}
	_(args)
end

function floor(part, face)
			local args = {
				[1] = "SyncTexture",
				[2] = {
					[1] = {
						["Part"] = part,
						["Face"] = face,
						["TextureType"] = "Texture",
						["Texture"] = "rbxassetid://135172958780980",
						["StudsPerTileV"] = 2,
						["StudsPerTileU"] = 2
					}
				}
			}
			_(args)
		end

function DestroyPart(part)
    local args = {
        [1] = "Remove",
        [2] = {
            [1] = part
        }
    }
    _(args)
end
local function unanchorall()
	for _, v in ipairs(workspace:GetDescendants()) do
		if v:IsA("BasePart") or v:IsA("UnionOperation") then
			spawn(function()
				DestroyPart(v)
			end)
		end
	end
end

local function realm()
RequestCommand:InvokeServer(";punish all")
	unanchorall()

	task.wait(1)
 
local function GetGitModel(ModelUrl, ModelName) 
    if not isfile(ModelName..".txt") then 
        writefile(ModelName..".txt", game:HttpGet(ModelUrl)) 
    end 

    local success, model = pcall(function()
        return game:GetObjects((getcustomasset or getsynasset)(ModelName..".txt"))[1] 
    end)

    if not success then
        warn("retard download a new executor")
        return nil
    end

    model.Name = ModelName 
    return model 
end 

local imported_model = GetGitModel("https://github.com/Kotyara19k-Doorsspawner/funni-models/raw/refs/heads/main/funni.rbxmx", "totallyNotk00pzCafe")




imported_model.Parent = game.Lighting


for _, v in next, imported_model:GetDescendants() do
    pcall(function()
        v.Anchored = true
    end)
end

local plr = game:GetService("Players").LocalPlayer
local f3x_name = "Building Tools"
local destination = workspace

coroutine.wrap(function()
    task.wait(10)
    imported_model.Parent = nil
end)()

function f3xbuildpart(part, cframe, destination, size, transparency, colour, material, collision, fake_part)
local allPartsData = {}
		

table.insert(allPartsData, {
    Type = fake_part:IsA("WedgePart") and "Wedge" or fake_part:IsA("Seat") and "Seat" or fake_part:IsA("VehicleSeat") and "VehicleSeat" or fake_part:IsA("TrussPart") and "Truss" or fake_part:IsA("SpawnLocation") and "Spawn" or
        fake_part.Shape == Enum.PartType.Block and "Normal" or
        fake_part.Shape == Enum.PartType.Ball and "Ball" or
        fake_part.Shape == Enum.PartType.Cylinder and "Cylinder",
    CFrame = fake_part.CFrame,
    Size = fake_part.Size,
    Transparency = fake_part.Transparency,
    Color = fake_part.Color,
    Material = fake_part.Material,
    Collision = fake_part.CanCollide,
    Ref = fake_part,
})

    local sync = plr.Backpack:FindFirstChild(f3x_name).SyncAPI.ServerEndpoint
local partMap = {}


for _, data in ipairs(allPartsData) do
    local created = sync:InvokeServer("CreatePart", data.Type, data.CFrame, destination)
    partMap[data.Ref] = created
end

for _, data in ipairs(allPartsData) do
    local created = partMap[data.Ref]
    if not created then continue end

    spawn(function()
        if data.Size ~= Vector3.new(4,1,2) then
            sync:InvokeServer("SyncResize", {
                { Part = created, CFrame = created.CFrame, Size = data.Size }
            })
        end

        if data.Transparency ~= 0 then
            sync:InvokeServer("SyncMaterial", {
                { Part = created, Transparency = data.Transparency }
            })
        end

        if data.Color ~= BrickColor.new("Medium stone grey").Color then
            sync:InvokeServer("SyncColor", {
                { Part = created, Color = data.Color, UnionColoring = true }
            })
        end

        if data.Material ~= "Plastic" then
            sync:InvokeServer("SyncMaterial", {
                { Part = created, Material = data.Material }
            })
        end

        if data.Collision ~= true then
            sync:InvokeServer("SyncCollision", {
                { Part = created, CanCollide = data.Collision }
            })
        end

        local ref = data.Ref

        local texture = ref:FindFirstChildOfClass("Texture")
        if texture then
            sync:InvokeServer("CreateTextures", {
                { Part = created, Face = texture.Face, TextureType = "Texture" }
            })
            sync:InvokeServer("SyncTexture", {
                { Part = created, Face = texture.Face, TextureType = "Texture", StudsPerTileU = texture.StudsPerTileU, StudsPerTileV = texture.StudsPerTileV, Texture = texture.Texture, Transparency = texture.Transparency }
            })
        end

        local decal = ref:FindFirstChildOfClass("Decal")
        if decal then
            sync:InvokeServer("CreateTextures", {
                { Part = created, Face = decal.Face, TextureType = "Decal" }
            })
            sync:InvokeServer("SyncTexture", {
                { Part = created, Face = decal.Face, TextureType = "Decal", Texture = decal.Texture, Transparency = decal.Transparency }
            })
        end

        local mesh = ref:FindFirstChildOfClass("SpecialMesh")
        if mesh then
            sync:InvokeServer("CreateMeshes", {
                { Part = created }
            })
            sync:InvokeServer("SyncMesh", {
                { Part = created, MeshId = mesh.MeshId, TextureId = mesh.TextureId, Scale = mesh.Scale }
            })
        end

        local light1 = ref:FindFirstChildOfClass("SpotLight")
        if light1 then
            sync:InvokeServer("CreateLights", {
                { Part = created, LightType = "SpotLight" }
            })
            sync:InvokeServer("SyncLighting", {
                { Part = created, LightType = "SpotLight", Color = light1.Color, Range = light1.Range, Face = light1.Face, Angle = light1.Angle, Shadows = light1.Shadows }
            })
        end

        local light2 = ref:FindFirstChildOfClass("PointLight")
        if light2 then
            sync:InvokeServer("CreateLights", {
                { Part = created, LightType = "PointLight" }
            })
            sync:InvokeServer("SyncLighting", {
                { Part = created, LightType = "PointLight", Color = light2.Color, Range = light2.Range, Shadows = light2.Shadows }
            })
              
           end
       end)
    end
end

for _, part in next, imported_model:GetDescendants() do
   local function spawnpart(fn)
			task.spawn(fn)
		end
    if part:IsA("Part") then
        if part.Shape == Enum.PartType.Block then
spawnpart(function()
            f3xbuildpart("Normal", part.CFrame, destination, part.Size, part.Transparency, part.Color, part.Material, part.CanCollide, part)
end)
        elseif part.Shape == Enum.PartType.Ball then
spawnpart(function()
            f3xbuildpart("Ball", part.CFrame, destination, part.Size, part.Transparency, part.Color, part.Material, part.CanCollide, part)
end)
        elseif part.Shape == Enum.PartType.Cylinder then
spawnpart(function()
            f3xbuildpart("Cylinder", part.CFrame, destination, part.Size, part.Transparency, part.Color, part.Material, part.CanCollide, part)
end)
        end
    elseif part:IsA("WedgePart") then
spawnpart(function()
        f3xbuildpart("Wedge", part.CFrame, destination, part.Size, part.Transparency, part.Color, part.Material, part.CanCollide, part)
end)
    elseif part:IsA("Seat") then
spawnpart(function()
        f3xbuildpart("Seat", part.CFrame, destination, part.Size, part.Transparency, part.Color, part.Material, part.CanCollide, part)
end)
    elseif part:IsA("TrussPart") then
spawnpart(function()
        f3xbuildpart("Truss", part.CFrame, destination, part.Size, part.Transparency, part.Color, part.Material, part.CanCollide, part)
end)
    elseif part:IsA("VehicleSeat") then
spawnpart(function()
        f3xbuildpart("VehicleSeat", part.CFrame, destination, part.Size, part.Transparency, part.Color, part.Material, part.CanCollide, part)
end)
        elseif part:IsA("SpawnLocation") then
spawnpart(function()
        f3xbuildpart("Spawn", part.CFrame, destination, part.Size, part.Transparency, part.Color, part.Material, part.CanCollide, part)
      end)
    end
end

print("Finished build.")
wait(3)


	for _, v in ipairs(workspace:GetDescendants()) do
    if v:IsA("BasePart") and v.Size == Vector3.new(512, 20, 512) then
             createtexture(v, Enum.NormalId.Top)
            floor(v, Enum.NormalId.Top)
        end
    end

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
RequestCommand:InvokeServer(";fogcolor black ;time 0")

local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local backpack = player:WaitForChild("Backpack")

local function getf3x()
	for _, v in ipairs(backpack:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then
			return v
		end
	end
	for _, v in ipairs(char:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then
			return v
		end
	end
	return nil
end

local f3x = getf3x()
if not f3x then
	warn("you dont have f3x skid")
	return
end

local syncapi = f3x.SyncAPI
local serverendpoint = syncapi.ServerEndpoint

local function _(args)
	serverendpoint:InvokeServer(unpack(args))
end

local function makemesh(part)
	_({
		"CreateMeshes",
		{
			{ Part = part }
		}
	})
end

local function syncmeshid(part, id)
	_({
		"SyncMesh",
		{
			{
				Part = part,
				MeshId = "rbxassetid://" .. id
			}
		}
	})
end

local function syncmeshtexture(part, id)
	_({
		"SyncMesh",
		{
			{
				Part = part,
				TextureId = "rbxassetid://" .. id
			}
		}
	})
end

local function syncmeshsize(part, scale)
	_({
		"SyncMesh",
		{
			{
				Part = part,
				Scale = scale
			}
		}
	})
end

local function setvertexcolor(part, vec3)
	_({
		"SyncMesh",
		{
			{
				Part = part,
				VertexColor = vec3
			}
		}
	})
end

local function setanchor(part, state)
	_({
		"SyncAnchor",
		{
			{
				Part = part,
				Anchored = state
			}
		}
	})
end

local function name(part, stringa)
	_({
		"SetName",
		{ part },
		stringa
	})
end

local function makerealmbase()
	local pos = CFrame.new(0, 0, 0)
	local sky = serverendpoint:InvokeServer("CreatePart", "Normal", pos, workspace.Terrain)

	setanchor(sky, true)
	makemesh(sky)
	syncmeshid(sky, "111891702759441")
	syncmeshsize(sky, Vector3.new(109888, 109888, 109888))
	syncmeshtexture(sky, "9820931824")
	setvertexcolor(sky, Vector3.new(5, 5, 5))
	name(sky, "Sky")
end

makerealmbase()
end

realm()
wait(1)
RequestCommand:InvokeServer(";music 1846575559 ;volume 3 ;respawn all")

end)


